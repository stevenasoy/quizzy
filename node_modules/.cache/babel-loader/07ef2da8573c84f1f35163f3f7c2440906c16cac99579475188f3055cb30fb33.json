{"ast":null,"code":"import _objectSpread from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.math.log10.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\r\n * Spaced Repetition Algorithm Module\r\n * Based on Anki's implementation of SuperMemo 2 Algorithm\r\n */\n\n/**\r\n * Convert performance score to Anki-style quality rating\r\n * @param {number} performance - Raw performance score (0-1)\r\n * @param {number} responseTime - Time taken to answer in milliseconds (optional)\r\n * @returns {number} Quality rating (0-5)\r\n */\nfunction getQualityRating(performance) {\n  var responseTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (performance === 0) return 0; // Complete blackout\n\n  // If we have response time, use it to fine-tune the rating\n  if (responseTime !== null) {\n    var timeBasedPenalty = Math.min(2, responseTime / 10000); // Penalty for taking >10s\n    performance = Math.max(0, performance - timeBasedPenalty * 0.2);\n  }\n\n  // Convert performance to Anki's 0-5 scale\n  if (performance < 0.2) return 1; // Wrong, but remembered when shown\n  if (performance < 0.4) return 2; // Wrong, but familiar\n  if (performance < 0.6) return 3; // Correct with effort\n  if (performance < 0.8) return 4; // Correct with hesitation\n  return 5; // Perfect response\n}\n\n/**\r\n * Calculate ease factor adjustment\r\n * @param {number} quality - Quality rating (0-5)\r\n * @returns {number} Ease factor adjustment\r\n */\nfunction calculateEaseAdjustment(quality) {\n  // Anki's ease factor adjustment formula\n  return 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02);\n}\n\n/**\r\n * Calculate interval modifier based on card maturity\r\n * @param {Object} questionState - Current state of the question\r\n * @returns {number} Interval modifier\r\n */\nfunction getIntervalModifier(questionState) {\n  var maturityBonus = Math.min(0.2, questionState.repetitions * 0.02);\n  var intervalPenalty = Math.max(-0.2, -Math.log10(questionState.interval) * 0.05);\n  return 1 + maturityBonus + intervalPenalty;\n}\n\n/**\r\n * Calculate the next review interval for a question\r\n * @param {Object} questionState - Current state of the question\r\n * @param {number} performance - Performance score (0-1)\r\n * @param {number} responseTime - Time taken to answer in milliseconds (optional)\r\n * @returns {Object} Updated question state with next review date\r\n */\nexport function calculateNextReview(questionState, performance) {\n  var responseTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  // Initialize state if new question\n  if (!questionState) {\n    questionState = {\n      easeFactor: 2.5,\n      interval: 0,\n      repetitions: 0,\n      lapses: 0,\n      lastReviewDate: null,\n      reviewHistory: []\n    };\n  }\n  var quality = getQualityRating(performance, responseTime);\n  var intervalModifier = getIntervalModifier(questionState);\n\n  // Calculate new ease factor (Anki style)\n  var newEaseFactor = questionState.easeFactor + calculateEaseAdjustment(quality);\n  newEaseFactor = Math.max(1.3, newEaseFactor); // Minimum ease factor\n\n  // Calculate new interval\n  var newInterval;\n  if (quality < 3) {\n    // Failed response\n    newInterval = 1;\n    questionState.repetitions = 0;\n    questionState.lapses++;\n\n    // Apply lapse penalty to ease factor\n    newEaseFactor = Math.max(1.3, newEaseFactor * 0.85);\n  } else {\n    // Successful response\n    if (questionState.repetitions === 0) {\n      newInterval = 1;\n    } else if (questionState.repetitions === 1) {\n      newInterval = 6;\n    } else {\n      // Apply interval modifier for mature cards\n      newInterval = Math.round(questionState.interval * questionState.easeFactor * intervalModifier);\n    }\n    questionState.repetitions++;\n  }\n\n  // Apply random fuzz to interval (Anki style)\n  var fuzz = 0.95 + Math.random() * 0.1; // Â±5% random interval adjustment\n  newInterval = Math.round(newInterval * fuzz);\n\n  // Calculate next review date\n  var nextReviewDate = new Date();\n  nextReviewDate.setDate(nextReviewDate.getDate() + newInterval);\n\n  // Update review history\n  var reviewRecord = {\n    date: new Date(),\n    quality: quality,\n    performance: performance,\n    responseTime: responseTime,\n    interval: newInterval,\n    easeFactor: newEaseFactor\n  };\n  return {\n    easeFactor: newEaseFactor,\n    interval: newInterval,\n    repetitions: questionState.repetitions,\n    lapses: questionState.lapses,\n    lastReviewDate: new Date(),\n    nextReviewDate: nextReviewDate,\n    reviewHistory: [].concat(_toConsumableArray(questionState.reviewHistory || []), [reviewRecord])\n  };\n}\n\n/**\r\n * Get questions due for review with Anki-style priority\r\n * @param {Array} questions - Array of questions with their spaced repetition state\r\n * @returns {Array} Questions that are due for review\r\n */\nexport function getDueQuestions(questions) {\n  var now = new Date();\n  return questions.filter(function (q) {\n    if (!q.spacedRepetition) return true; // New questions are always due\n    return q.spacedRepetition.nextReviewDate <= now;\n  });\n}\n\n/**\r\n * Calculate review priority for questions (Anki-style)\r\n * @param {Array} questions - Array of questions with their spaced repetition state\r\n * @returns {Array} Questions sorted by review priority\r\n */\nexport function calculateReviewPriority(questions) {\n  var now = new Date();\n  return questions.map(function (q) {\n    var priority = 0;\n    if (!q.spacedRepetition) {\n      priority = 100; // New questions get high priority\n    } else {\n      var daysOverdue = (now - new Date(q.spacedRepetition.nextReviewDate)) / (1000 * 60 * 60 * 24);\n      var maturityFactor = Math.min(1, q.spacedRepetition.repetitions / 10);\n      var lapsePenalty = q.spacedRepetition.lapses * 0.1;\n\n      // Priority formula considering multiple factors\n      priority = (daysOverdue + 1) * (\n      // Base priority from days overdue\n      3.5 - q.spacedRepetition.easeFactor) * (\n      // Harder cards get higher priority\n      1 + lapsePenalty) * (\n      // More lapses = higher priority\n      1 - maturityFactor * 0.5) // Less mature cards get higher priority\n      ;\n\n      // Boost priority for overdue reviews\n      if (daysOverdue > 0) {\n        priority *= 1 + Math.min(daysOverdue * 0.1, 1);\n      }\n    }\n    return _objectSpread(_objectSpread({}, q), {}, {\n      priority: priority\n    });\n  }).sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n}\n\n/**\r\n * Update question state after review\r\n * @param {Object} question - Question object\r\n * @param {number} performance - Performance score (0-1)\r\n * @param {number} responseTime - Time taken to answer in milliseconds (optional)\r\n * @returns {Object} Updated question object\r\n */\nexport function updateQuestionAfterReview(question, performance) {\n  var responseTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var updatedState = calculateNextReview(question.spacedRepetition, performance, responseTime);\n  return _objectSpread(_objectSpread({}, question), {}, {\n    spacedRepetition: updatedState\n  });\n}\n\n/**\r\n * Get mastery level of a question based on its spaced repetition data\r\n * @param {Object} question - Question with spaced repetition data\r\n * @returns {string} Mastery level ('new', 'learning', or 'mastered')\r\n */\nexport function getMasteryLevel(question) {\n  if (!question.spacedRepetition) return 'new';\n  var _question$spacedRepet = question.spacedRepetition,\n    repetitions = _question$spacedRepet.repetitions,\n    interval = _question$spacedRepet.interval;\n  if (repetitions === 0) return 'new';\n  if (interval < 7) return 'learning';\n  return 'mastered';\n}\n\n/**\r\n * Get review forecast for the next n days\r\n * @param {Array} questions - Array of questions with spaced repetition data\r\n * @param {number} days - Number of days to forecast\r\n * @returns {Array} Array of review counts for each day\r\n */\nexport function getReviewForecast(questions) {\n  var days = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;\n  var forecast = new Array(days).fill(0);\n  var now = new Date();\n  questions.forEach(function (question) {\n    var _question$spacedRepet2;\n    if (!((_question$spacedRepet2 = question.spacedRepetition) !== null && _question$spacedRepet2 !== void 0 && _question$spacedRepet2.nextReviewDate)) {\n      forecast[0]++; // New questions are due today\n      return;\n    }\n    var reviewDate = new Date(question.spacedRepetition.nextReviewDate);\n    var dayDiff = Math.floor((reviewDate - now) / (1000 * 60 * 60 * 24));\n    if (dayDiff >= 0 && dayDiff < days) {\n      forecast[dayDiff]++;\n    }\n  });\n  return forecast;\n}","map":{"version":3,"names":["getQualityRating","performance","responseTime","arguments","length","undefined","timeBasedPenalty","Math","min","max","calculateEaseAdjustment","quality","getIntervalModifier","questionState","maturityBonus","repetitions","intervalPenalty","log10","interval","calculateNextReview","easeFactor","lapses","lastReviewDate","reviewHistory","intervalModifier","newEaseFactor","newInterval","round","fuzz","random","nextReviewDate","Date","setDate","getDate","reviewRecord","date","concat","_toConsumableArray","getDueQuestions","questions","now","filter","q","spacedRepetition","calculateReviewPriority","map","priority","daysOverdue","maturityFactor","lapsePenalty","_objectSpread","sort","a","b","updateQuestionAfterReview","question","updatedState","getMasteryLevel","_question$spacedRepet","getReviewForecast","days","forecast","Array","fill","forEach","_question$spacedRepet2","reviewDate","dayDiff","floor"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/spaced-repetition/index.js"],"sourcesContent":["/**\r\n * Spaced Repetition Algorithm Module\r\n * Based on Anki's implementation of SuperMemo 2 Algorithm\r\n */\r\n\r\n/**\r\n * Convert performance score to Anki-style quality rating\r\n * @param {number} performance - Raw performance score (0-1)\r\n * @param {number} responseTime - Time taken to answer in milliseconds (optional)\r\n * @returns {number} Quality rating (0-5)\r\n */\r\nfunction getQualityRating(performance, responseTime = null) {\r\n  if (performance === 0) return 0; // Complete blackout\r\n  \r\n  // If we have response time, use it to fine-tune the rating\r\n  if (responseTime !== null) {\r\n    const timeBasedPenalty = Math.min(2, responseTime / 10000); // Penalty for taking >10s\r\n    performance = Math.max(0, performance - timeBasedPenalty * 0.2);\r\n  }\r\n\r\n  // Convert performance to Anki's 0-5 scale\r\n  if (performance < 0.2) return 1; // Wrong, but remembered when shown\r\n  if (performance < 0.4) return 2; // Wrong, but familiar\r\n  if (performance < 0.6) return 3; // Correct with effort\r\n  if (performance < 0.8) return 4; // Correct with hesitation\r\n  return 5; // Perfect response\r\n}\r\n\r\n/**\r\n * Calculate ease factor adjustment\r\n * @param {number} quality - Quality rating (0-5)\r\n * @returns {number} Ease factor adjustment\r\n */\r\nfunction calculateEaseAdjustment(quality) {\r\n  // Anki's ease factor adjustment formula\r\n  return 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02);\r\n}\r\n\r\n/**\r\n * Calculate interval modifier based on card maturity\r\n * @param {Object} questionState - Current state of the question\r\n * @returns {number} Interval modifier\r\n */\r\nfunction getIntervalModifier(questionState) {\r\n  const maturityBonus = Math.min(0.2, questionState.repetitions * 0.02);\r\n  const intervalPenalty = Math.max(-0.2, -Math.log10(questionState.interval) * 0.05);\r\n  return 1 + maturityBonus + intervalPenalty;\r\n}\r\n\r\n/**\r\n * Calculate the next review interval for a question\r\n * @param {Object} questionState - Current state of the question\r\n * @param {number} performance - Performance score (0-1)\r\n * @param {number} responseTime - Time taken to answer in milliseconds (optional)\r\n * @returns {Object} Updated question state with next review date\r\n */\r\nexport function calculateNextReview(questionState, performance, responseTime = null) {\r\n  // Initialize state if new question\r\n  if (!questionState) {\r\n    questionState = {\r\n      easeFactor: 2.5,\r\n      interval: 0,\r\n      repetitions: 0,\r\n      lapses: 0,\r\n      lastReviewDate: null,\r\n      reviewHistory: []\r\n    };\r\n  }\r\n\r\n  const quality = getQualityRating(performance, responseTime);\r\n  const intervalModifier = getIntervalModifier(questionState);\r\n  \r\n  // Calculate new ease factor (Anki style)\r\n  let newEaseFactor = questionState.easeFactor + calculateEaseAdjustment(quality);\r\n  newEaseFactor = Math.max(1.3, newEaseFactor); // Minimum ease factor\r\n\r\n  // Calculate new interval\r\n  let newInterval;\r\n  if (quality < 3) {\r\n    // Failed response\r\n    newInterval = 1;\r\n    questionState.repetitions = 0;\r\n    questionState.lapses++;\r\n    \r\n    // Apply lapse penalty to ease factor\r\n    newEaseFactor = Math.max(1.3, newEaseFactor * 0.85);\r\n  } else {\r\n    // Successful response\r\n    if (questionState.repetitions === 0) {\r\n      newInterval = 1;\r\n    } else if (questionState.repetitions === 1) {\r\n      newInterval = 6;\r\n    } else {\r\n      // Apply interval modifier for mature cards\r\n      newInterval = Math.round(questionState.interval * questionState.easeFactor * intervalModifier);\r\n    }\r\n    questionState.repetitions++;\r\n  }\r\n\r\n  // Apply random fuzz to interval (Anki style)\r\n  const fuzz = 0.95 + Math.random() * 0.1; // Â±5% random interval adjustment\r\n  newInterval = Math.round(newInterval * fuzz);\r\n\r\n  // Calculate next review date\r\n  const nextReviewDate = new Date();\r\n  nextReviewDate.setDate(nextReviewDate.getDate() + newInterval);\r\n\r\n  // Update review history\r\n  const reviewRecord = {\r\n    date: new Date(),\r\n    quality,\r\n    performance,\r\n    responseTime,\r\n    interval: newInterval,\r\n    easeFactor: newEaseFactor\r\n  };\r\n\r\n  return {\r\n    easeFactor: newEaseFactor,\r\n    interval: newInterval,\r\n    repetitions: questionState.repetitions,\r\n    lapses: questionState.lapses,\r\n    lastReviewDate: new Date(),\r\n    nextReviewDate: nextReviewDate,\r\n    reviewHistory: [...(questionState.reviewHistory || []), reviewRecord]\r\n  };\r\n}\r\n\r\n/**\r\n * Get questions due for review with Anki-style priority\r\n * @param {Array} questions - Array of questions with their spaced repetition state\r\n * @returns {Array} Questions that are due for review\r\n */\r\nexport function getDueQuestions(questions) {\r\n  const now = new Date();\r\n  return questions.filter(q => {\r\n    if (!q.spacedRepetition) return true; // New questions are always due\r\n    return q.spacedRepetition.nextReviewDate <= now;\r\n  });\r\n}\r\n\r\n/**\r\n * Calculate review priority for questions (Anki-style)\r\n * @param {Array} questions - Array of questions with their spaced repetition state\r\n * @returns {Array} Questions sorted by review priority\r\n */\r\nexport function calculateReviewPriority(questions) {\r\n  const now = new Date();\r\n  return questions.map(q => {\r\n    let priority = 0;\r\n    \r\n    if (!q.spacedRepetition) {\r\n      priority = 100; // New questions get high priority\r\n    } else {\r\n      const daysOverdue = (now - new Date(q.spacedRepetition.nextReviewDate)) / (1000 * 60 * 60 * 24);\r\n      const maturityFactor = Math.min(1, q.spacedRepetition.repetitions / 10);\r\n      const lapsePenalty = q.spacedRepetition.lapses * 0.1;\r\n      \r\n      // Priority formula considering multiple factors\r\n      priority = (\r\n        (daysOverdue + 1) * // Base priority from days overdue\r\n        (3.5 - q.spacedRepetition.easeFactor) * // Harder cards get higher priority\r\n        (1 + lapsePenalty) * // More lapses = higher priority\r\n        (1 - maturityFactor * 0.5) // Less mature cards get higher priority\r\n      );\r\n\r\n      // Boost priority for overdue reviews\r\n      if (daysOverdue > 0) {\r\n        priority *= (1 + Math.min(daysOverdue * 0.1, 1));\r\n      }\r\n    }\r\n    \r\n    return { ...q, priority };\r\n  }).sort((a, b) => b.priority - a.priority);\r\n}\r\n\r\n/**\r\n * Update question state after review\r\n * @param {Object} question - Question object\r\n * @param {number} performance - Performance score (0-1)\r\n * @param {number} responseTime - Time taken to answer in milliseconds (optional)\r\n * @returns {Object} Updated question object\r\n */\r\nexport function updateQuestionAfterReview(question, performance, responseTime = null) {\r\n  const updatedState = calculateNextReview(\r\n    question.spacedRepetition,\r\n    performance,\r\n    responseTime\r\n  );\r\n  \r\n  return {\r\n    ...question,\r\n    spacedRepetition: updatedState\r\n  };\r\n}\r\n\r\n/**\r\n * Get mastery level of a question based on its spaced repetition data\r\n * @param {Object} question - Question with spaced repetition data\r\n * @returns {string} Mastery level ('new', 'learning', or 'mastered')\r\n */\r\nexport function getMasteryLevel(question) {\r\n  if (!question.spacedRepetition) return 'new';\r\n  \r\n  const { repetitions, interval } = question.spacedRepetition;\r\n  \r\n  if (repetitions === 0) return 'new';\r\n  if (interval < 7) return 'learning';\r\n  return 'mastered';\r\n}\r\n\r\n/**\r\n * Get review forecast for the next n days\r\n * @param {Array} questions - Array of questions with spaced repetition data\r\n * @param {number} days - Number of days to forecast\r\n * @returns {Array} Array of review counts for each day\r\n */\r\nexport function getReviewForecast(questions, days = 7) {\r\n  const forecast = new Array(days).fill(0);\r\n  const now = new Date();\r\n  \r\n  questions.forEach(question => {\r\n    if (!question.spacedRepetition?.nextReviewDate) {\r\n      forecast[0]++; // New questions are due today\r\n      return;\r\n    }\r\n    \r\n    const reviewDate = new Date(question.spacedRepetition.nextReviewDate);\r\n    const dayDiff = Math.floor((reviewDate - now) / (1000 * 60 * 60 * 24));\r\n    \r\n    if (dayDiff >= 0 && dayDiff < days) {\r\n      forecast[dayDiff]++;\r\n    }\r\n  });\r\n  \r\n  return forecast;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
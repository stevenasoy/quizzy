{"ast":null,"code":"import _objectSpread from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/**\r\n * Difficulty Adaptation Algorithm Module\r\n */\n\n/**\r\n * Calculate the next question's difficulty based on user performance\r\n * @param {Array} previousResponses - Array of previous question responses\r\n * @param {number} consecutiveCorrect - Number of consecutive correct answers\r\n * @param {number} consecutiveIncorrect - Number of consecutive incorrect answers\r\n * @returns {string} Next question difficulty level\r\n */\nexport function calculateNextDifficulty(previousResponses, consecutiveCorrect, consecutiveIncorrect) {\n  // If no previous responses, start with medium\n  if (!previousResponses || previousResponses.length === 0) {\n    return 'medium';\n  }\n\n  // Get current difficulty from last question\n  var currentDifficulty = previousResponses[previousResponses.length - 1].difficulty || 'medium';\n\n  // Calculate recent performance (last 3 questions)\n  var recentResponses = previousResponses.slice(-3);\n  var recentCorrectRate = recentResponses.filter(function (r) {\n    return r.correct;\n  }).length / recentResponses.length;\n\n  // Adjust difficulty based on performance patterns\n  if (currentDifficulty === 'easy') {\n    if (consecutiveCorrect >= 2 || recentCorrectRate >= 0.8) {\n      return 'medium';\n    }\n  } else if (currentDifficulty === 'medium') {\n    if (consecutiveCorrect >= 2 && recentCorrectRate >= 0.8) {\n      return 'hard';\n    } else if (consecutiveIncorrect >= 2 || recentCorrectRate <= 0.3) {\n      return 'easy';\n    }\n  } else if (currentDifficulty === 'hard') {\n    if (consecutiveIncorrect >= 2 || recentCorrectRate <= 0.5) {\n      return 'medium';\n    }\n  }\n\n  // If no adjustment needed, maintain current difficulty\n  return currentDifficulty;\n}\n\n/**\r\n * Select the next question from available questions based on calculated difficulty\r\n * @param {Array} availableQuestions - Array of unused questions\r\n * @param {string} targetDifficulty - Target difficulty level\r\n * @returns {Object} Selected question and remaining questions\r\n */\nexport function selectNextQuestion(availableQuestions, targetDifficulty) {\n  if (!availableQuestions || availableQuestions.length === 0) {\n    return {\n      question: null,\n      remainingQuestions: []\n    };\n  }\n\n  // First try to find a question of target difficulty\n  var question = availableQuestions.find(function (q) {\n    return q.difficulty === targetDifficulty;\n  });\n\n  // If no question of target difficulty, find closest difficulty\n  if (!question) {\n    if (targetDifficulty === 'hard') {\n      question = availableQuestions.find(function (q) {\n        return q.difficulty === 'medium';\n      });\n    } else if (targetDifficulty === 'easy') {\n      question = availableQuestions.find(function (q) {\n        return q.difficulty === 'medium';\n      });\n    } else {\n      // If medium not found, take any question\n      question = availableQuestions[0];\n    }\n  }\n\n  // If still no question found, take the first available\n  if (!question) {\n    question = availableQuestions[0];\n  }\n\n  // Remove selected question from available questions\n  var remainingQuestions = availableQuestions.filter(function (q) {\n    return q !== question;\n  });\n  return {\n    question: question,\n    remainingQuestions: remainingQuestions\n  };\n}\n\n/**\r\n * Initialize adaptive quiz state\r\n * @param {Array} questions - Array of all questions\r\n * @returns {Object} Initial quiz state\r\n */\nexport function initializeAdaptiveQuiz(questions) {\n  return {\n    availableQuestions: _toConsumableArray(questions),\n    usedQuestions: [],\n    consecutiveCorrect: 0,\n    consecutiveIncorrect: 0,\n    currentDifficulty: 'medium'\n  };\n}\n\n/**\r\n * Update quiz state based on user's answer\r\n * @param {Object} quizState - Current quiz state\r\n * @param {Object} response - User's response to current question\r\n * @returns {Object} Updated quiz state\r\n */\nexport function updateQuizState(quizState, response) {\n  var newState = _objectSpread({}, quizState);\n\n  // Update consecutive counters\n  if (response.correct) {\n    newState.consecutiveCorrect += 1;\n    newState.consecutiveIncorrect = 0;\n  } else {\n    newState.consecutiveIncorrect += 1;\n    newState.consecutiveCorrect = 0;\n  }\n\n  // Add response to used questions\n  newState.usedQuestions.push(response);\n\n  // Calculate next difficulty\n  newState.currentDifficulty = calculateNextDifficulty(newState.usedQuestions, newState.consecutiveCorrect, newState.consecutiveIncorrect);\n  return newState;\n}","map":{"version":3,"names":["calculateNextDifficulty","previousResponses","consecutiveCorrect","consecutiveIncorrect","length","currentDifficulty","difficulty","recentResponses","slice","recentCorrectRate","filter","r","correct","selectNextQuestion","availableQuestions","targetDifficulty","question","remainingQuestions","find","q","initializeAdaptiveQuiz","questions","_toConsumableArray","usedQuestions","updateQuizState","quizState","response","newState","_objectSpread","push"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/difficulty-adaptation/index.js"],"sourcesContent":["/**\r\n * Difficulty Adaptation Algorithm Module\r\n */\r\n\r\n/**\r\n * Calculate the next question's difficulty based on user performance\r\n * @param {Array} previousResponses - Array of previous question responses\r\n * @param {number} consecutiveCorrect - Number of consecutive correct answers\r\n * @param {number} consecutiveIncorrect - Number of consecutive incorrect answers\r\n * @returns {string} Next question difficulty level\r\n */\r\nexport function calculateNextDifficulty(previousResponses, consecutiveCorrect, consecutiveIncorrect) {\r\n  // If no previous responses, start with medium\r\n  if (!previousResponses || previousResponses.length === 0) {\r\n    return 'medium';\r\n  }\r\n\r\n  // Get current difficulty from last question\r\n  const currentDifficulty = previousResponses[previousResponses.length - 1].difficulty || 'medium';\r\n  \r\n  // Calculate recent performance (last 3 questions)\r\n  const recentResponses = previousResponses.slice(-3);\r\n  const recentCorrectRate = recentResponses.filter(r => r.correct).length / recentResponses.length;\r\n\r\n  // Adjust difficulty based on performance patterns\r\n  if (currentDifficulty === 'easy') {\r\n    if (consecutiveCorrect >= 2 || recentCorrectRate >= 0.8) {\r\n      return 'medium';\r\n    }\r\n  } else if (currentDifficulty === 'medium') {\r\n    if (consecutiveCorrect >= 2 && recentCorrectRate >= 0.8) {\r\n      return 'hard';\r\n    } else if (consecutiveIncorrect >= 2 || recentCorrectRate <= 0.3) {\r\n      return 'easy';\r\n    }\r\n  } else if (currentDifficulty === 'hard') {\r\n    if (consecutiveIncorrect >= 2 || recentCorrectRate <= 0.5) {\r\n      return 'medium';\r\n    }\r\n  }\r\n\r\n  // If no adjustment needed, maintain current difficulty\r\n  return currentDifficulty;\r\n}\r\n\r\n/**\r\n * Select the next question from available questions based on calculated difficulty\r\n * @param {Array} availableQuestions - Array of unused questions\r\n * @param {string} targetDifficulty - Target difficulty level\r\n * @returns {Object} Selected question and remaining questions\r\n */\r\nexport function selectNextQuestion(availableQuestions, targetDifficulty) {\r\n  if (!availableQuestions || availableQuestions.length === 0) {\r\n    return { question: null, remainingQuestions: [] };\r\n  }\r\n\r\n  // First try to find a question of target difficulty\r\n  let question = availableQuestions.find(q => q.difficulty === targetDifficulty);\r\n\r\n  // If no question of target difficulty, find closest difficulty\r\n  if (!question) {\r\n    if (targetDifficulty === 'hard') {\r\n      question = availableQuestions.find(q => q.difficulty === 'medium');\r\n    } else if (targetDifficulty === 'easy') {\r\n      question = availableQuestions.find(q => q.difficulty === 'medium');\r\n    } else {\r\n      // If medium not found, take any question\r\n      question = availableQuestions[0];\r\n    }\r\n  }\r\n\r\n  // If still no question found, take the first available\r\n  if (!question) {\r\n    question = availableQuestions[0];\r\n  }\r\n\r\n  // Remove selected question from available questions\r\n  const remainingQuestions = availableQuestions.filter(q => q !== question);\r\n\r\n  return { question, remainingQuestions };\r\n}\r\n\r\n/**\r\n * Initialize adaptive quiz state\r\n * @param {Array} questions - Array of all questions\r\n * @returns {Object} Initial quiz state\r\n */\r\nexport function initializeAdaptiveQuiz(questions) {\r\n  return {\r\n    availableQuestions: [...questions],\r\n    usedQuestions: [],\r\n    consecutiveCorrect: 0,\r\n    consecutiveIncorrect: 0,\r\n    currentDifficulty: 'medium'\r\n  };\r\n}\r\n\r\n/**\r\n * Update quiz state based on user's answer\r\n * @param {Object} quizState - Current quiz state\r\n * @param {Object} response - User's response to current question\r\n * @returns {Object} Updated quiz state\r\n */\r\nexport function updateQuizState(quizState, response) {\r\n  const newState = { ...quizState };\r\n\r\n  // Update consecutive counters\r\n  if (response.correct) {\r\n    newState.consecutiveCorrect += 1;\r\n    newState.consecutiveIncorrect = 0;\r\n  } else {\r\n    newState.consecutiveIncorrect += 1;\r\n    newState.consecutiveCorrect = 0;\r\n  }\r\n\r\n  // Add response to used questions\r\n  newState.usedQuestions.push(response);\r\n\r\n  // Calculate next difficulty\r\n  newState.currentDifficulty = calculateNextDifficulty(\r\n    newState.usedQuestions,\r\n    newState.consecutiveCorrect,\r\n    newState.consecutiveIncorrect\r\n  );\r\n\r\n  return newState;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
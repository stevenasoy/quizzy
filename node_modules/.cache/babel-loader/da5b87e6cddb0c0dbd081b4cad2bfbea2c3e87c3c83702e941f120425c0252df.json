{"ast":null,"code":"import _objectSpread from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/**\r\n * Difficulty Adaptation Algorithm Module\r\n */\n\n/**\r\n * Calculate the next question's difficulty based on user performance\r\n * @param {Array} previousResponses - Array of previous question responses\r\n * @returns {string} Next question difficulty level\r\n */\nexport function calculateNextDifficulty(previousResponses) {\n  // If no previous responses, start with medium\n  if (!previousResponses || previousResponses.length === 0) {\n    return 'medium';\n  }\n\n  // Get current difficulty from last question\n  var currentDifficulty = previousResponses[previousResponses.length - 1].difficulty || 'medium';\n\n  // Get whether the last answer was correct\n  var lastResponse = previousResponses[previousResponses.length - 1];\n  var wasCorrect = lastResponse.correct;\n\n  // New difficulty progression logic\n  switch (currentDifficulty) {\n    case 'medium':\n      // From medium: correct → hard, incorrect → easy\n      return wasCorrect ? 'hard' : 'easy';\n    case 'hard':\n      // From hard: correct → stay hard, incorrect → medium\n      return wasCorrect ? 'hard' : 'medium';\n    case 'easy':\n      // From easy: correct → medium, incorrect → stay easy\n      return wasCorrect ? 'medium' : 'easy';\n    default:\n      // Default to medium if something unexpected happens\n      return 'medium';\n  }\n}\n\n/**\r\n * Select the next question from available questions based on calculated difficulty\r\n * @param {Array} availableQuestions - Array of unused questions\r\n * @param {string} targetDifficulty - Target difficulty level\r\n * @returns {Object} Selected question and remaining questions\r\n */\nexport function selectNextQuestion(availableQuestions, targetDifficulty) {\n  if (!availableQuestions || availableQuestions.length === 0) {\n    return {\n      question: null,\n      remainingQuestions: []\n    };\n  }\n\n  // First try to find a question of target difficulty\n  var question = availableQuestions.find(function (q) {\n    return q.difficulty === targetDifficulty;\n  });\n\n  // If no question of target difficulty, find closest difficulty\n  if (!question) {\n    if (targetDifficulty === 'hard') {\n      question = availableQuestions.find(function (q) {\n        return q.difficulty === 'medium';\n      });\n    } else if (targetDifficulty === 'easy') {\n      question = availableQuestions.find(function (q) {\n        return q.difficulty === 'medium';\n      });\n    } else {\n      // If medium not found, take any question\n      question = availableQuestions[0];\n    }\n  }\n\n  // If still no question found, take the first available\n  if (!question) {\n    question = availableQuestions[0];\n  }\n\n  // Remove selected question from available questions\n  var remainingQuestions = availableQuestions.filter(function (q) {\n    return q !== question;\n  });\n  return {\n    question: question,\n    remainingQuestions: remainingQuestions\n  };\n}\n\n/**\r\n * Initialize adaptive quiz state\r\n * @param {Array} questions - Array of all questions\r\n * @returns {Object} Initial quiz state\r\n */\nexport function initializeAdaptiveQuiz(questions) {\n  return {\n    availableQuestions: _toConsumableArray(questions),\n    usedQuestions: [],\n    consecutiveCorrect: 0,\n    consecutiveIncorrect: 0,\n    currentDifficulty: 'medium'\n  };\n}\n\n/**\r\n * Update quiz state based on user's answer\r\n * @param {Object} quizState - Current quiz state\r\n * @param {Object} response - User's response to current question\r\n * @returns {Object} Updated quiz state\r\n */\nexport function updateQuizState(quizState, response) {\n  var newState = _objectSpread({}, quizState);\n\n  // Update consecutive counters\n  if (response.correct) {\n    newState.consecutiveCorrect += 1;\n    newState.consecutiveIncorrect = 0;\n  } else {\n    newState.consecutiveIncorrect += 1;\n    newState.consecutiveCorrect = 0;\n  }\n\n  // Add response to used questions\n  newState.usedQuestions.push(response);\n\n  // Calculate next difficulty\n  newState.currentDifficulty = calculateNextDifficulty(newState.usedQuestions);\n  return newState;\n}","map":{"version":3,"names":["calculateNextDifficulty","previousResponses","length","currentDifficulty","difficulty","lastResponse","wasCorrect","correct","selectNextQuestion","availableQuestions","targetDifficulty","question","remainingQuestions","find","q","filter","initializeAdaptiveQuiz","questions","_toConsumableArray","usedQuestions","consecutiveCorrect","consecutiveIncorrect","updateQuizState","quizState","response","newState","_objectSpread","push"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/difficulty-adaptation/index.js"],"sourcesContent":["/**\r\n * Difficulty Adaptation Algorithm Module\r\n */\r\n\r\n/**\r\n * Calculate the next question's difficulty based on user performance\r\n * @param {Array} previousResponses - Array of previous question responses\r\n * @returns {string} Next question difficulty level\r\n */\r\nexport function calculateNextDifficulty(previousResponses) {\r\n  // If no previous responses, start with medium\r\n  if (!previousResponses || previousResponses.length === 0) {\r\n    return 'medium';\r\n  }\r\n\r\n  // Get current difficulty from last question\r\n  const currentDifficulty = previousResponses[previousResponses.length - 1].difficulty || 'medium';\r\n  \r\n  // Get whether the last answer was correct\r\n  const lastResponse = previousResponses[previousResponses.length - 1];\r\n  const wasCorrect = lastResponse.correct;\r\n\r\n  // New difficulty progression logic\r\n  switch (currentDifficulty) {\r\n    case 'medium':\r\n      // From medium: correct → hard, incorrect → easy\r\n      return wasCorrect ? 'hard' : 'easy';\r\n      \r\n    case 'hard':\r\n      // From hard: correct → stay hard, incorrect → medium\r\n      return wasCorrect ? 'hard' : 'medium';\r\n      \r\n    case 'easy':\r\n      // From easy: correct → medium, incorrect → stay easy\r\n      return wasCorrect ? 'medium' : 'easy';\r\n      \r\n    default:\r\n      // Default to medium if something unexpected happens\r\n      return 'medium';\r\n  }\r\n}\r\n\r\n/**\r\n * Select the next question from available questions based on calculated difficulty\r\n * @param {Array} availableQuestions - Array of unused questions\r\n * @param {string} targetDifficulty - Target difficulty level\r\n * @returns {Object} Selected question and remaining questions\r\n */\r\nexport function selectNextQuestion(availableQuestions, targetDifficulty) {\r\n  if (!availableQuestions || availableQuestions.length === 0) {\r\n    return { question: null, remainingQuestions: [] };\r\n  }\r\n\r\n  // First try to find a question of target difficulty\r\n  let question = availableQuestions.find(q => q.difficulty === targetDifficulty);\r\n\r\n  // If no question of target difficulty, find closest difficulty\r\n  if (!question) {\r\n    if (targetDifficulty === 'hard') {\r\n      question = availableQuestions.find(q => q.difficulty === 'medium');\r\n    } else if (targetDifficulty === 'easy') {\r\n      question = availableQuestions.find(q => q.difficulty === 'medium');\r\n    } else {\r\n      // If medium not found, take any question\r\n      question = availableQuestions[0];\r\n    }\r\n  }\r\n\r\n  // If still no question found, take the first available\r\n  if (!question) {\r\n    question = availableQuestions[0];\r\n  }\r\n\r\n  // Remove selected question from available questions\r\n  const remainingQuestions = availableQuestions.filter(q => q !== question);\r\n\r\n  return { question, remainingQuestions };\r\n}\r\n\r\n/**\r\n * Initialize adaptive quiz state\r\n * @param {Array} questions - Array of all questions\r\n * @returns {Object} Initial quiz state\r\n */\r\nexport function initializeAdaptiveQuiz(questions) {\r\n  return {\r\n    availableQuestions: [...questions],\r\n    usedQuestions: [],\r\n    consecutiveCorrect: 0,\r\n    consecutiveIncorrect: 0,\r\n    currentDifficulty: 'medium'\r\n  };\r\n}\r\n\r\n/**\r\n * Update quiz state based on user's answer\r\n * @param {Object} quizState - Current quiz state\r\n * @param {Object} response - User's response to current question\r\n * @returns {Object} Updated quiz state\r\n */\r\nexport function updateQuizState(quizState, response) {\r\n  const newState = { ...quizState };\r\n\r\n  // Update consecutive counters\r\n  if (response.correct) {\r\n    newState.consecutiveCorrect += 1;\r\n    newState.consecutiveIncorrect = 0;\r\n  } else {\r\n    newState.consecutiveIncorrect += 1;\r\n    newState.consecutiveCorrect = 0;\r\n  }\r\n\r\n  // Add response to used questions\r\n  newState.usedQuestions.push(response);\r\n\r\n  // Calculate next difficulty\r\n  newState.currentDifficulty = calculateNextDifficulty(\r\n    newState.usedQuestions\r\n  );\r\n\r\n  return newState;\r\n} "],"mappings":";;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,uBAAuBA,CAACC,iBAAiB,EAAE;EACzD;EACA,IAAI,CAACA,iBAAiB,IAAIA,iBAAiB,CAACC,MAAM,KAAK,CAAC,EAAE;IACxD,OAAO,QAAQ;EACjB;;EAEA;EACA,IAAMC,iBAAiB,GAAGF,iBAAiB,CAACA,iBAAiB,CAACC,MAAM,GAAG,CAAC,CAAC,CAACE,UAAU,IAAI,QAAQ;;EAEhG;EACA,IAAMC,YAAY,GAAGJ,iBAAiB,CAACA,iBAAiB,CAACC,MAAM,GAAG,CAAC,CAAC;EACpE,IAAMI,UAAU,GAAGD,YAAY,CAACE,OAAO;;EAEvC;EACA,QAAQJ,iBAAiB;IACvB,KAAK,QAAQ;MACX;MACA,OAAOG,UAAU,GAAG,MAAM,GAAG,MAAM;IAErC,KAAK,MAAM;MACT;MACA,OAAOA,UAAU,GAAG,MAAM,GAAG,QAAQ;IAEvC,KAAK,MAAM;MACT;MACA,OAAOA,UAAU,GAAG,QAAQ,GAAG,MAAM;IAEvC;MACE;MACA,OAAO,QAAQ;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,kBAAkBA,CAACC,kBAAkB,EAAEC,gBAAgB,EAAE;EACvE,IAAI,CAACD,kBAAkB,IAAIA,kBAAkB,CAACP,MAAM,KAAK,CAAC,EAAE;IAC1D,OAAO;MAAES,QAAQ,EAAE,IAAI;MAAEC,kBAAkB,EAAE;IAAG,CAAC;EACnD;;EAEA;EACA,IAAID,QAAQ,GAAGF,kBAAkB,CAACI,IAAI,CAAC,UAAAC,CAAC;IAAA,OAAIA,CAAC,CAACV,UAAU,KAAKM,gBAAgB;EAAA,EAAC;;EAE9E;EACA,IAAI,CAACC,QAAQ,EAAE;IACb,IAAID,gBAAgB,KAAK,MAAM,EAAE;MAC/BC,QAAQ,GAAGF,kBAAkB,CAACI,IAAI,CAAC,UAAAC,CAAC;QAAA,OAAIA,CAAC,CAACV,UAAU,KAAK,QAAQ;MAAA,EAAC;IACpE,CAAC,MAAM,IAAIM,gBAAgB,KAAK,MAAM,EAAE;MACtCC,QAAQ,GAAGF,kBAAkB,CAACI,IAAI,CAAC,UAAAC,CAAC;QAAA,OAAIA,CAAC,CAACV,UAAU,KAAK,QAAQ;MAAA,EAAC;IACpE,CAAC,MAAM;MACL;MACAO,QAAQ,GAAGF,kBAAkB,CAAC,CAAC,CAAC;IAClC;EACF;;EAEA;EACA,IAAI,CAACE,QAAQ,EAAE;IACbA,QAAQ,GAAGF,kBAAkB,CAAC,CAAC,CAAC;EAClC;;EAEA;EACA,IAAMG,kBAAkB,GAAGH,kBAAkB,CAACM,MAAM,CAAC,UAAAD,CAAC;IAAA,OAAIA,CAAC,KAAKH,QAAQ;EAAA,EAAC;EAEzE,OAAO;IAAEA,QAAQ,EAARA,QAAQ;IAAEC,kBAAkB,EAAlBA;EAAmB,CAAC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,sBAAsBA,CAACC,SAAS,EAAE;EAChD,OAAO;IACLR,kBAAkB,EAAAS,kBAAA,CAAMD,SAAS,CAAC;IAClCE,aAAa,EAAE,EAAE;IACjBC,kBAAkB,EAAE,CAAC;IACrBC,oBAAoB,EAAE,CAAC;IACvBlB,iBAAiB,EAAE;EACrB,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASmB,eAAeA,CAACC,SAAS,EAAEC,QAAQ,EAAE;EACnD,IAAMC,QAAQ,GAAAC,aAAA,KAAQH,SAAS,CAAE;;EAEjC;EACA,IAAIC,QAAQ,CAACjB,OAAO,EAAE;IACpBkB,QAAQ,CAACL,kBAAkB,IAAI,CAAC;IAChCK,QAAQ,CAACJ,oBAAoB,GAAG,CAAC;EACnC,CAAC,MAAM;IACLI,QAAQ,CAACJ,oBAAoB,IAAI,CAAC;IAClCI,QAAQ,CAACL,kBAAkB,GAAG,CAAC;EACjC;;EAEA;EACAK,QAAQ,CAACN,aAAa,CAACQ,IAAI,CAACH,QAAQ,CAAC;;EAErC;EACAC,QAAQ,CAACtB,iBAAiB,GAAGH,uBAAuB,CAClDyB,QAAQ,CAACN,aACX,CAAC;EAED,OAAOM,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
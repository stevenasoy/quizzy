{"ast":null,"code":"import _slicedToArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * Question Management Module\r\n */\n\n/**\r\n * Implements Fisher-Yates shuffle algorithm\r\n * @param {Array} array - Array to shuffle\r\n * @returns {Array} Shuffled array\r\n */\nexport function shuffleQuestions(array) {\n  var shuffled = _toConsumableArray(array);\n  for (var i = shuffled.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var _ref = [shuffled[j], shuffled[i]];\n    shuffled[i] = _ref[0];\n    shuffled[j] = _ref[1];\n  }\n  return shuffled;\n}\n\n/**\r\n * Distributes questions by difficulty\r\n * @param {Array} questions - Array of questions\r\n * @param {number} targetCount - Desired number of questions\r\n * @returns {Array} Balanced question set\r\n */\nexport function distributeByDifficulty(questions, targetCount) {\n  // Default distribution\n  var distribution = {\n    easy: 0.4,\n    medium: 0.4,\n    hard: 0.2\n  };\n\n  // Calculate targets for each difficulty\n  var targets = {\n    easy: Math.round(targetCount * distribution.easy),\n    medium: Math.round(targetCount * distribution.medium),\n    hard: Math.round(targetCount * distribution.hard)\n  };\n  var selectedQuestions = [];\n\n  // Select questions by difficulty\n  Object.entries(targets).forEach(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      difficulty = _ref3[0],\n      count = _ref3[1];\n    var difficultyQuestions = questions.filter(function (q) {\n      return q.difficulty === difficulty && !selectedQuestions.includes(q);\n    });\n\n    // Shuffle to randomize selection\n    var shuffled = shuffleQuestions(difficultyQuestions);\n    selectedQuestions.push.apply(selectedQuestions, _toConsumableArray(shuffled.slice(0, count)));\n  });\n\n  // If we don't have enough questions of the right difficulties,\n  // fill in with whatever questions are available\n  while (selectedQuestions.length < targetCount && questions.length > selectedQuestions.length) {\n    var remainingQuestions = questions.filter(function (q) {\n      return !selectedQuestions.includes(q);\n    });\n    var shuffled = shuffleQuestions(remainingQuestions);\n    selectedQuestions.push(shuffled[0]);\n  }\n  return selectedQuestions;\n}\n\n/**\r\n * Creates topic clusters from questions\r\n * @param {Array} questions - Array of questions\r\n * @returns {Array} Topic clusters\r\n */\nfunction createTopicClusters(questions) {\n  var clusters = [];\n  var processedQuestions = new Set();\n  questions.forEach(function (question, i) {\n    if (processedQuestions.has(i)) return;\n    var cluster = {\n      questions: [question],\n      topics: extractTopics(question)\n    };\n\n    // Find related questions\n    questions.forEach(function (otherQuestion, j) {\n      if (i !== j && !processedQuestions.has(j)) {\n        var similarity = calculateTopicSimilarity(cluster.topics, extractTopics(otherQuestion));\n        if (similarity > 0.3) {\n          // Threshold for topic similarity\n          cluster.questions.push(otherQuestion);\n          cluster.topics = _toConsumableArray(new Set([].concat(_toConsumableArray(cluster.topics), _toConsumableArray(extractTopics(otherQuestion)))));\n          processedQuestions.add(j);\n        }\n      }\n    });\n    clusters.push(cluster);\n    processedQuestions.add(i);\n  });\n  return clusters;\n}\n\n/**\r\n * Extracts topics from a question\r\n * @param {Object} question - Question object\r\n * @returns {Array} Extracted topics\r\n */\nfunction extractTopics(question) {\n  var topics = new Set();\n\n  // Extract from question text\n  var words = question.text.toLowerCase().split(/\\W+/);\n  var noiseWords = new Set(['what', 'when', 'where', 'why', 'how', 'is', 'are', 'the', 'a', 'an']);\n  words.forEach(function (word) {\n    if (word.length > 3 && !noiseWords.has(word)) {\n      topics.add(word);\n    }\n  });\n\n  // Extract from options for multiple choice\n  if (question.type === 'multiple-choice') {\n    Object.values(question.options).forEach(function (option) {\n      option.toLowerCase().split(/\\W+/).forEach(function (word) {\n        if (word.length > 3 && !noiseWords.has(word)) {\n          topics.add(word);\n        }\n      });\n    });\n  }\n  return Array.from(topics);\n}\n\n/**\r\n * Calculates topic similarity between two sets of topics\r\n * @param {Array} topics1 - First set of topics\r\n * @param {Array} topics2 - Second set of topics\r\n * @returns {number} Similarity score\r\n */\nfunction calculateTopicSimilarity(topics1, topics2) {\n  var set1 = new Set(topics1);\n  var set2 = new Set(topics2);\n  var intersection = new Set(_toConsumableArray(set1).filter(function (x) {\n    return set2.has(x);\n  }));\n  var union = new Set([].concat(_toConsumableArray(set1), _toConsumableArray(set2)));\n  return intersection.size / union.size;\n}\n\n/**\r\n * Gets user performance history\r\n * @returns {Array} Performance history\r\n */\nfunction getPerformanceHistory() {\n  try {\n    var history = localStorage.getItem('quizHistory');\n    return history ? JSON.parse(history) : [];\n  } catch (error) {\n    console.error('Error loading quiz history:', error);\n    return [];\n  }\n}\n\n/**\r\n * Calculates difficulty distribution based on performance\r\n * @param {Array} history - Performance history\r\n * @returns {Object} Difficulty distribution\r\n */\nfunction calculateDifficultyDistribution(history) {\n  if (!history.length) {\n    return {\n      easy: 0.4,\n      medium: 0.4,\n      hard: 0.2\n    }; // Default distribution\n  }\n\n  // Calculate average performance\n  var recentQuizzes = history.slice(0, 5); // Consider last 5 quizzes\n  var avgScore = recentQuizzes.reduce(function (sum, quiz) {\n    return sum + quiz.actualScore;\n  }, 0) / recentQuizzes.length;\n\n  // Adjust distribution based on performance\n  if (avgScore >= 85) {\n    return {\n      easy: 0.2,\n      medium: 0.5,\n      hard: 0.3\n    }; // Increase difficulty\n  } else if (avgScore >= 70) {\n    return {\n      easy: 0.3,\n      medium: 0.4,\n      hard: 0.3\n    }; // Balanced\n  } else {\n    return {\n      easy: 0.5,\n      medium: 0.3,\n      hard: 0.2\n    }; // More easy questions\n  }\n}\n\n/**\r\n * Selects questions from a cluster\r\n * @param {Object} cluster - Topic cluster\r\n * @param {number} targetCount - Target questions from cluster\r\n * @param {Object} distribution - Difficulty distribution\r\n * @returns {Array} Selected questions\r\n */\nfunction selectQuestionsFromCluster(cluster, targetCount, distribution) {\n  var questions = _toConsumableArray(cluster.questions);\n  var selected = [];\n\n  // Calculate targets for each difficulty\n  var targets = {\n    easy: Math.round(targetCount * distribution.easy),\n    medium: Math.round(targetCount * distribution.medium),\n    hard: Math.round(targetCount * distribution.hard)\n  };\n\n  // Select questions by difficulty\n  Object.entries(targets).forEach(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      difficulty = _ref5[0],\n      count = _ref5[1];\n    var difficultyQuestions = questions.filter(function (q) {\n      return q.difficulty === difficulty && !selected.includes(q);\n    });\n\n    // Shuffle to randomize selection\n    var shuffled = shuffleQuestions(difficultyQuestions);\n    selected.push.apply(selected, _toConsumableArray(shuffled.slice(0, count)));\n  });\n  return selected;\n}\n\n/**\r\n * Ensures minimum coverage of all difficulty levels\r\n * @param {Array} questions - Selected questions\r\n * @param {number} targetCount - Target question count\r\n * @returns {Array} Adjusted question set\r\n */\nfunction ensureMinimumDifficultyCoverage(questions, targetCount) {\n  var difficulties = ['easy', 'medium', 'hard'];\n  var minPerDifficulty = Math.max(1, Math.floor(targetCount * 0.2));\n  var counts = questions.reduce(function (acc, q) {\n    acc[q.difficulty] = (acc[q.difficulty] || 0) + 1;\n    return acc;\n  }, {});\n\n  // Ensure minimum counts\n  difficulties.forEach(function (difficulty) {\n    if ((counts[difficulty] || 0) < minPerDifficulty) {\n      var needed = minPerDifficulty - (counts[difficulty] || 0);\n      var available = questions.filter(function (q) {\n        return q.difficulty === difficulty && !questions.includes(q);\n      });\n      if (available.length > 0) {\n        var toAdd = shuffleQuestions(available).slice(0, needed);\n        // Remove questions from over-represented difficulties\n        var overRepresented = difficulties.find(function (d) {\n          return (counts[d] || 0) > minPerDifficulty + 1;\n        });\n        if (overRepresented) {\n          var toRemove = questions.filter(function (q) {\n            return q.difficulty === overRepresented;\n          }).slice(0, needed);\n          questions = questions.filter(function (q) {\n            return !toRemove.includes(q);\n          });\n        }\n        questions = [].concat(_toConsumableArray(questions), _toConsumableArray(toAdd));\n      }\n    }\n  });\n  return questions;\n}","map":{"version":3,"names":["shuffleQuestions","array","shuffled","_toConsumableArray","i","length","j","Math","floor","random","_ref","distributeByDifficulty","questions","targetCount","distribution","easy","medium","hard","targets","round","selectedQuestions","Object","entries","forEach","_ref2","_ref3","_slicedToArray","difficulty","count","difficultyQuestions","filter","q","includes","push","apply","slice","remainingQuestions","createTopicClusters","clusters","processedQuestions","Set","question","has","cluster","topics","extractTopics","otherQuestion","similarity","calculateTopicSimilarity","concat","add","words","text","toLowerCase","split","noiseWords","word","type","values","options","option","Array","from","topics1","topics2","set1","set2","intersection","x","union","size","getPerformanceHistory","history","localStorage","getItem","JSON","parse","error","console","calculateDifficultyDistribution","recentQuizzes","avgScore","reduce","sum","quiz","actualScore","selectQuestionsFromCluster","selected","_ref4","_ref5","ensureMinimumDifficultyCoverage","difficulties","minPerDifficulty","max","counts","acc","needed","available","toAdd","overRepresented","find","d","toRemove"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/question-management/index.js"],"sourcesContent":["/**\r\n * Question Management Module\r\n */\r\n\r\n/**\r\n * Implements Fisher-Yates shuffle algorithm\r\n * @param {Array} array - Array to shuffle\r\n * @returns {Array} Shuffled array\r\n */\r\nexport function shuffleQuestions(array) {\r\n  const shuffled = [...array];\r\n  for (let i = shuffled.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\r\n  }\r\n  return shuffled;\r\n}\r\n\r\n/**\r\n * Distributes questions by difficulty\r\n * @param {Array} questions - Array of questions\r\n * @param {number} targetCount - Desired number of questions\r\n * @returns {Array} Balanced question set\r\n */\r\nexport function distributeByDifficulty(questions, targetCount) {\r\n  // Default distribution\r\n  const distribution = { easy: 0.4, medium: 0.4, hard: 0.2 };\r\n  \r\n  // Calculate targets for each difficulty\r\n  const targets = {\r\n    easy: Math.round(targetCount * distribution.easy),\r\n    medium: Math.round(targetCount * distribution.medium),\r\n    hard: Math.round(targetCount * distribution.hard)\r\n  };\r\n  \r\n  const selectedQuestions = [];\r\n  \r\n  // Select questions by difficulty\r\n  Object.entries(targets).forEach(([difficulty, count]) => {\r\n    const difficultyQuestions = questions.filter(q => \r\n      q.difficulty === difficulty && !selectedQuestions.includes(q)\r\n    );\r\n    \r\n    // Shuffle to randomize selection\r\n    const shuffled = shuffleQuestions(difficultyQuestions);\r\n    selectedQuestions.push(...shuffled.slice(0, count));\r\n  });\r\n  \r\n  // If we don't have enough questions of the right difficulties,\r\n  // fill in with whatever questions are available\r\n  while (selectedQuestions.length < targetCount && questions.length > selectedQuestions.length) {\r\n    const remainingQuestions = questions.filter(q => !selectedQuestions.includes(q));\r\n    const shuffled = shuffleQuestions(remainingQuestions);\r\n    selectedQuestions.push(shuffled[0]);\r\n  }\r\n  \r\n  return selectedQuestions;\r\n}\r\n\r\n/**\r\n * Creates topic clusters from questions\r\n * @param {Array} questions - Array of questions\r\n * @returns {Array} Topic clusters\r\n */\r\nfunction createTopicClusters(questions) {\r\n  const clusters = [];\r\n  const processedQuestions = new Set();\r\n  \r\n  questions.forEach((question, i) => {\r\n    if (processedQuestions.has(i)) return;\r\n    \r\n    const cluster = {\r\n      questions: [question],\r\n      topics: extractTopics(question)\r\n    };\r\n    \r\n    // Find related questions\r\n    questions.forEach((otherQuestion, j) => {\r\n      if (i !== j && !processedQuestions.has(j)) {\r\n        const similarity = calculateTopicSimilarity(\r\n          cluster.topics,\r\n          extractTopics(otherQuestion)\r\n        );\r\n        \r\n        if (similarity > 0.3) { // Threshold for topic similarity\r\n          cluster.questions.push(otherQuestion);\r\n          cluster.topics = [...new Set([\r\n            ...cluster.topics,\r\n            ...extractTopics(otherQuestion)\r\n          ])];\r\n          processedQuestions.add(j);\r\n        }\r\n      }\r\n    });\r\n    \r\n    clusters.push(cluster);\r\n    processedQuestions.add(i);\r\n  });\r\n  \r\n  return clusters;\r\n}\r\n\r\n/**\r\n * Extracts topics from a question\r\n * @param {Object} question - Question object\r\n * @returns {Array} Extracted topics\r\n */\r\nfunction extractTopics(question) {\r\n  const topics = new Set();\r\n  \r\n  // Extract from question text\r\n  const words = question.text.toLowerCase().split(/\\W+/);\r\n  const noiseWords = new Set(['what', 'when', 'where', 'why', 'how', 'is', 'are', 'the', 'a', 'an']);\r\n  \r\n  words.forEach(word => {\r\n    if (word.length > 3 && !noiseWords.has(word)) {\r\n      topics.add(word);\r\n    }\r\n  });\r\n  \r\n  // Extract from options for multiple choice\r\n  if (question.type === 'multiple-choice') {\r\n    Object.values(question.options).forEach(option => {\r\n      option.toLowerCase().split(/\\W+/).forEach(word => {\r\n        if (word.length > 3 && !noiseWords.has(word)) {\r\n          topics.add(word);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  \r\n  return Array.from(topics);\r\n}\r\n\r\n/**\r\n * Calculates topic similarity between two sets of topics\r\n * @param {Array} topics1 - First set of topics\r\n * @param {Array} topics2 - Second set of topics\r\n * @returns {number} Similarity score\r\n */\r\nfunction calculateTopicSimilarity(topics1, topics2) {\r\n  const set1 = new Set(topics1);\r\n  const set2 = new Set(topics2);\r\n  \r\n  const intersection = new Set([...set1].filter(x => set2.has(x)));\r\n  const union = new Set([...set1, ...set2]);\r\n  \r\n  return intersection.size / union.size;\r\n}\r\n\r\n/**\r\n * Gets user performance history\r\n * @returns {Array} Performance history\r\n */\r\nfunction getPerformanceHistory() {\r\n  try {\r\n    const history = localStorage.getItem('quizHistory');\r\n    return history ? JSON.parse(history) : [];\r\n  } catch (error) {\r\n    console.error('Error loading quiz history:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates difficulty distribution based on performance\r\n * @param {Array} history - Performance history\r\n * @returns {Object} Difficulty distribution\r\n */\r\nfunction calculateDifficultyDistribution(history) {\r\n  if (!history.length) {\r\n    return { easy: 0.4, medium: 0.4, hard: 0.2 }; // Default distribution\r\n  }\r\n  \r\n  // Calculate average performance\r\n  const recentQuizzes = history.slice(0, 5); // Consider last 5 quizzes\r\n  const avgScore = recentQuizzes.reduce((sum, quiz) => \r\n    sum + quiz.actualScore, 0\r\n  ) / recentQuizzes.length;\r\n  \r\n  // Adjust distribution based on performance\r\n  if (avgScore >= 85) {\r\n    return { easy: 0.2, medium: 0.5, hard: 0.3 }; // Increase difficulty\r\n  } else if (avgScore >= 70) {\r\n    return { easy: 0.3, medium: 0.4, hard: 0.3 }; // Balanced\r\n  } else {\r\n    return { easy: 0.5, medium: 0.3, hard: 0.2 }; // More easy questions\r\n  }\r\n}\r\n\r\n/**\r\n * Selects questions from a cluster\r\n * @param {Object} cluster - Topic cluster\r\n * @param {number} targetCount - Target questions from cluster\r\n * @param {Object} distribution - Difficulty distribution\r\n * @returns {Array} Selected questions\r\n */\r\nfunction selectQuestionsFromCluster(cluster, targetCount, distribution) {\r\n  const questions = [...cluster.questions];\r\n  const selected = [];\r\n  \r\n  // Calculate targets for each difficulty\r\n  const targets = {\r\n    easy: Math.round(targetCount * distribution.easy),\r\n    medium: Math.round(targetCount * distribution.medium),\r\n    hard: Math.round(targetCount * distribution.hard)\r\n  };\r\n  \r\n  // Select questions by difficulty\r\n  Object.entries(targets).forEach(([difficulty, count]) => {\r\n    const difficultyQuestions = questions.filter(q => \r\n      q.difficulty === difficulty && !selected.includes(q)\r\n    );\r\n    \r\n    // Shuffle to randomize selection\r\n    const shuffled = shuffleQuestions(difficultyQuestions);\r\n    selected.push(...shuffled.slice(0, count));\r\n  });\r\n  \r\n  return selected;\r\n}\r\n\r\n/**\r\n * Ensures minimum coverage of all difficulty levels\r\n * @param {Array} questions - Selected questions\r\n * @param {number} targetCount - Target question count\r\n * @returns {Array} Adjusted question set\r\n */\r\nfunction ensureMinimumDifficultyCoverage(questions, targetCount) {\r\n  const difficulties = ['easy', 'medium', 'hard'];\r\n  const minPerDifficulty = Math.max(1, Math.floor(targetCount * 0.2));\r\n  \r\n  const counts = questions.reduce((acc, q) => {\r\n    acc[q.difficulty] = (acc[q.difficulty] || 0) + 1;\r\n    return acc;\r\n  }, {});\r\n  \r\n  // Ensure minimum counts\r\n  difficulties.forEach(difficulty => {\r\n    if ((counts[difficulty] || 0) < minPerDifficulty) {\r\n      const needed = minPerDifficulty - (counts[difficulty] || 0);\r\n      const available = questions.filter(q => \r\n        q.difficulty === difficulty && !questions.includes(q)\r\n      );\r\n      \r\n      if (available.length > 0) {\r\n        const toAdd = shuffleQuestions(available).slice(0, needed);\r\n        // Remove questions from over-represented difficulties\r\n        const overRepresented = difficulties.find(d => \r\n          (counts[d] || 0) > minPerDifficulty + 1\r\n        );\r\n        \r\n        if (overRepresented) {\r\n          const toRemove = questions.filter(q => q.difficulty === overRepresented)\r\n            .slice(0, needed);\r\n          questions = questions.filter(q => !toRemove.includes(q));\r\n        }\r\n        \r\n        questions = [...questions, ...toAdd];\r\n      }\r\n    }\r\n  });\r\n  \r\n  return questions;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
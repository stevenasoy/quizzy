{"ast":null,"code":"import _slicedToArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * Question Management Algorithms Module\r\n */\n\n/**\r\n * Implements Fisher-Yates shuffle algorithm\r\n * @param {Array} array - Array to shuffle\r\n * @returns {Array} Shuffled array\r\n */\nexport function shuffleQuestions(array) {\n  var shuffled = _toConsumableArray(array);\n  for (var i = shuffled.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var _ref = [shuffled[j], shuffled[i]];\n    shuffled[i] = _ref[0];\n    shuffled[j] = _ref[1];\n  }\n  return shuffled;\n}\n\n/**\r\n * Distributes questions by difficulty and topic clusters\r\n * @param {Array} questions - Array of questions\r\n * @param {number} targetCount - Desired number of questions\r\n * @returns {Array} Balanced question set\r\n */\nexport function distributeByDifficulty(questions, targetCount) {\n  // First, cluster questions by topic\n  var clusters = createTopicClusters(questions);\n\n  // Calculate target questions per cluster\n  var targetPerCluster = Math.ceil(targetCount / clusters.length);\n\n  // Get user performance history\n  var performanceHistory = getPerformanceHistory();\n\n  // Adjust difficulty distribution based on performance\n  var difficultyDistribution = calculateDifficultyDistribution(performanceHistory);\n  var selectedQuestions = [];\n\n  // Select questions from each cluster\n  clusters.forEach(function (cluster) {\n    var clusterQuestions = selectQuestionsFromCluster(cluster, targetPerCluster, difficultyDistribution);\n    selectedQuestions = [].concat(_toConsumableArray(selectedQuestions), _toConsumableArray(clusterQuestions));\n  });\n\n  // Trim to exact target count if needed\n  if (selectedQuestions.length > targetCount) {\n    selectedQuestions = selectedQuestions.slice(0, targetCount);\n  }\n\n  // Ensure minimum coverage of all difficulty levels\n  selectedQuestions = ensureMinimumDifficultyCoverage(selectedQuestions, targetCount);\n  return selectedQuestions;\n}\n\n/**\r\n * Creates topic clusters from questions\r\n * @param {Array} questions - Array of questions\r\n * @returns {Array} Topic clusters\r\n */\nfunction createTopicClusters(questions) {\n  var clusters = [];\n  var processedQuestions = new Set();\n  questions.forEach(function (question, i) {\n    if (processedQuestions.has(i)) return;\n    var cluster = {\n      questions: [question],\n      topics: extractTopics(question)\n    };\n\n    // Find related questions\n    questions.forEach(function (otherQuestion, j) {\n      if (i !== j && !processedQuestions.has(j)) {\n        var similarity = calculateTopicSimilarity(cluster.topics, extractTopics(otherQuestion));\n        if (similarity > 0.3) {\n          // Threshold for topic similarity\n          cluster.questions.push(otherQuestion);\n          cluster.topics = _toConsumableArray(new Set([].concat(_toConsumableArray(cluster.topics), _toConsumableArray(extractTopics(otherQuestion)))));\n          processedQuestions.add(j);\n        }\n      }\n    });\n    clusters.push(cluster);\n    processedQuestions.add(i);\n  });\n  return clusters;\n}\n\n/**\r\n * Extracts topics from a question\r\n * @param {Object} question - Question object\r\n * @returns {Array} Extracted topics\r\n */\nfunction extractTopics(question) {\n  var topics = new Set();\n\n  // Extract from question text\n  var words = question.text.toLowerCase().split(/\\W+/);\n  var noiseWords = new Set(['what', 'when', 'where', 'why', 'how', 'is', 'are', 'the', 'a', 'an']);\n  words.forEach(function (word) {\n    if (word.length > 3 && !noiseWords.has(word)) {\n      topics.add(word);\n    }\n  });\n\n  // Extract from options for multiple choice\n  if (question.type === 'multiple-choice') {\n    Object.values(question.options).forEach(function (option) {\n      option.toLowerCase().split(/\\W+/).forEach(function (word) {\n        if (word.length > 3 && !noiseWords.has(word)) {\n          topics.add(word);\n        }\n      });\n    });\n  }\n  return Array.from(topics);\n}\n\n/**\r\n * Calculates topic similarity between two sets of topics\r\n * @param {Array} topics1 - First set of topics\r\n * @param {Array} topics2 - Second set of topics\r\n * @returns {number} Similarity score\r\n */\nfunction calculateTopicSimilarity(topics1, topics2) {\n  var set1 = new Set(topics1);\n  var set2 = new Set(topics2);\n  var intersection = new Set(_toConsumableArray(set1).filter(function (x) {\n    return set2.has(x);\n  }));\n  var union = new Set([].concat(_toConsumableArray(set1), _toConsumableArray(set2)));\n  return intersection.size / union.size;\n}\n\n/**\r\n * Gets user performance history\r\n * @returns {Array} Performance history\r\n */\nfunction getPerformanceHistory() {\n  try {\n    var history = localStorage.getItem('quizHistory');\n    return history ? JSON.parse(history) : [];\n  } catch (error) {\n    console.error('Error loading quiz history:', error);\n    return [];\n  }\n}\n\n/**\r\n * Calculates difficulty distribution based on performance\r\n * @param {Array} history - Performance history\r\n * @returns {Object} Difficulty distribution\r\n */\nfunction calculateDifficultyDistribution(history) {\n  if (!history.length) {\n    return {\n      easy: 0.4,\n      medium: 0.4,\n      hard: 0.2\n    }; // Default distribution\n  }\n\n  // Calculate average performance\n  var recentQuizzes = history.slice(0, 5); // Consider last 5 quizzes\n  var avgScore = recentQuizzes.reduce(function (sum, quiz) {\n    return sum + quiz.actualScore;\n  }, 0) / recentQuizzes.length;\n\n  // Adjust distribution based on performance\n  if (avgScore >= 85) {\n    return {\n      easy: 0.2,\n      medium: 0.5,\n      hard: 0.3\n    }; // Increase difficulty\n  } else if (avgScore >= 70) {\n    return {\n      easy: 0.3,\n      medium: 0.4,\n      hard: 0.3\n    }; // Balanced\n  } else {\n    return {\n      easy: 0.5,\n      medium: 0.3,\n      hard: 0.2\n    }; // More easy questions\n  }\n}\n\n/**\r\n * Selects questions from a cluster\r\n * @param {Object} cluster - Topic cluster\r\n * @param {number} targetCount - Target questions from cluster\r\n * @param {Object} distribution - Difficulty distribution\r\n * @returns {Array} Selected questions\r\n */\nfunction selectQuestionsFromCluster(cluster, targetCount, distribution) {\n  var questions = _toConsumableArray(cluster.questions);\n  var selected = [];\n\n  // Calculate targets for each difficulty\n  var targets = {\n    easy: Math.round(targetCount * distribution.easy),\n    medium: Math.round(targetCount * distribution.medium),\n    hard: Math.round(targetCount * distribution.hard)\n  };\n\n  // Select questions by difficulty\n  Object.entries(targets).forEach(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      difficulty = _ref3[0],\n      count = _ref3[1];\n    var difficultyQuestions = questions.filter(function (q) {\n      return q.difficulty === difficulty && !selected.includes(q);\n    });\n\n    // Shuffle to randomize selection\n    var shuffled = shuffleQuestions(difficultyQuestions);\n    selected.push.apply(selected, _toConsumableArray(shuffled.slice(0, count)));\n  });\n  return selected;\n}\n\n/**\r\n * Ensures minimum coverage of all difficulty levels\r\n * @param {Array} questions - Selected questions\r\n * @param {number} targetCount - Target question count\r\n * @returns {Array} Adjusted question set\r\n */\nfunction ensureMinimumDifficultyCoverage(questions, targetCount) {\n  var difficulties = ['easy', 'medium', 'hard'];\n  var minPerDifficulty = Math.max(1, Math.floor(targetCount * 0.2));\n  var counts = questions.reduce(function (acc, q) {\n    acc[q.difficulty] = (acc[q.difficulty] || 0) + 1;\n    return acc;\n  }, {});\n\n  // Ensure minimum counts\n  difficulties.forEach(function (difficulty) {\n    if ((counts[difficulty] || 0) < minPerDifficulty) {\n      var needed = minPerDifficulty - (counts[difficulty] || 0);\n      var available = questions.filter(function (q) {\n        return q.difficulty === difficulty && !questions.includes(q);\n      });\n      if (available.length > 0) {\n        var toAdd = shuffleQuestions(available).slice(0, needed);\n        // Remove questions from over-represented difficulties\n        var overRepresented = difficulties.find(function (d) {\n          return (counts[d] || 0) > minPerDifficulty + 1;\n        });\n        if (overRepresented) {\n          var toRemove = questions.filter(function (q) {\n            return q.difficulty === overRepresented;\n          }).slice(0, needed);\n          questions = questions.filter(function (q) {\n            return !toRemove.includes(q);\n          });\n        }\n        questions = [].concat(_toConsumableArray(questions), _toConsumableArray(toAdd));\n      }\n    }\n  });\n  return questions;\n}","map":{"version":3,"names":["shuffleQuestions","array","shuffled","_toConsumableArray","i","length","j","Math","floor","random","_ref","distributeByDifficulty","questions","targetCount","clusters","createTopicClusters","targetPerCluster","ceil","performanceHistory","getPerformanceHistory","difficultyDistribution","calculateDifficultyDistribution","selectedQuestions","forEach","cluster","clusterQuestions","selectQuestionsFromCluster","concat","slice","ensureMinimumDifficultyCoverage","processedQuestions","Set","question","has","topics","extractTopics","otherQuestion","similarity","calculateTopicSimilarity","push","add","words","text","toLowerCase","split","noiseWords","word","type","Object","values","options","option","Array","from","topics1","topics2","set1","set2","intersection","filter","x","union","size","history","localStorage","getItem","JSON","parse","error","console","easy","medium","hard","recentQuizzes","avgScore","reduce","sum","quiz","actualScore","distribution","selected","targets","round","entries","_ref2","_ref3","_slicedToArray","difficulty","count","difficultyQuestions","q","includes","apply","difficulties","minPerDifficulty","max","counts","acc","needed","available","toAdd","overRepresented","find","d","toRemove"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/question-management/index.js"],"sourcesContent":["/**\r\n * Question Management Algorithms Module\r\n */\r\n\r\n/**\r\n * Implements Fisher-Yates shuffle algorithm\r\n * @param {Array} array - Array to shuffle\r\n * @returns {Array} Shuffled array\r\n */\r\nexport function shuffleQuestions(array) {\r\n  const shuffled = [...array];\r\n  for (let i = shuffled.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\r\n  }\r\n  return shuffled;\r\n}\r\n\r\n/**\r\n * Distributes questions by difficulty and topic clusters\r\n * @param {Array} questions - Array of questions\r\n * @param {number} targetCount - Desired number of questions\r\n * @returns {Array} Balanced question set\r\n */\r\nexport function distributeByDifficulty(questions, targetCount) {\r\n  // First, cluster questions by topic\r\n  const clusters = createTopicClusters(questions);\r\n  \r\n  // Calculate target questions per cluster\r\n  const targetPerCluster = Math.ceil(targetCount / clusters.length);\r\n  \r\n  // Get user performance history\r\n  const performanceHistory = getPerformanceHistory();\r\n  \r\n  // Adjust difficulty distribution based on performance\r\n  const difficultyDistribution = calculateDifficultyDistribution(performanceHistory);\r\n  \r\n  let selectedQuestions = [];\r\n  \r\n  // Select questions from each cluster\r\n  clusters.forEach(cluster => {\r\n    const clusterQuestions = selectQuestionsFromCluster(\r\n      cluster,\r\n      targetPerCluster,\r\n      difficultyDistribution\r\n    );\r\n    selectedQuestions = [...selectedQuestions, ...clusterQuestions];\r\n  });\r\n  \r\n  // Trim to exact target count if needed\r\n  if (selectedQuestions.length > targetCount) {\r\n    selectedQuestions = selectedQuestions.slice(0, targetCount);\r\n  }\r\n  \r\n  // Ensure minimum coverage of all difficulty levels\r\n  selectedQuestions = ensureMinimumDifficultyCoverage(selectedQuestions, targetCount);\r\n  \r\n  return selectedQuestions;\r\n}\r\n\r\n/**\r\n * Creates topic clusters from questions\r\n * @param {Array} questions - Array of questions\r\n * @returns {Array} Topic clusters\r\n */\r\nfunction createTopicClusters(questions) {\r\n  const clusters = [];\r\n  const processedQuestions = new Set();\r\n  \r\n  questions.forEach((question, i) => {\r\n    if (processedQuestions.has(i)) return;\r\n    \r\n    const cluster = {\r\n      questions: [question],\r\n      topics: extractTopics(question)\r\n    };\r\n    \r\n    // Find related questions\r\n    questions.forEach((otherQuestion, j) => {\r\n      if (i !== j && !processedQuestions.has(j)) {\r\n        const similarity = calculateTopicSimilarity(\r\n          cluster.topics,\r\n          extractTopics(otherQuestion)\r\n        );\r\n        \r\n        if (similarity > 0.3) { // Threshold for topic similarity\r\n          cluster.questions.push(otherQuestion);\r\n          cluster.topics = [...new Set([\r\n            ...cluster.topics,\r\n            ...extractTopics(otherQuestion)\r\n          ])];\r\n          processedQuestions.add(j);\r\n        }\r\n      }\r\n    });\r\n    \r\n    clusters.push(cluster);\r\n    processedQuestions.add(i);\r\n  });\r\n  \r\n  return clusters;\r\n}\r\n\r\n/**\r\n * Extracts topics from a question\r\n * @param {Object} question - Question object\r\n * @returns {Array} Extracted topics\r\n */\r\nfunction extractTopics(question) {\r\n  const topics = new Set();\r\n  \r\n  // Extract from question text\r\n  const words = question.text.toLowerCase().split(/\\W+/);\r\n  const noiseWords = new Set(['what', 'when', 'where', 'why', 'how', 'is', 'are', 'the', 'a', 'an']);\r\n  \r\n  words.forEach(word => {\r\n    if (word.length > 3 && !noiseWords.has(word)) {\r\n      topics.add(word);\r\n    }\r\n  });\r\n  \r\n  // Extract from options for multiple choice\r\n  if (question.type === 'multiple-choice') {\r\n    Object.values(question.options).forEach(option => {\r\n      option.toLowerCase().split(/\\W+/).forEach(word => {\r\n        if (word.length > 3 && !noiseWords.has(word)) {\r\n          topics.add(word);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  \r\n  return Array.from(topics);\r\n}\r\n\r\n/**\r\n * Calculates topic similarity between two sets of topics\r\n * @param {Array} topics1 - First set of topics\r\n * @param {Array} topics2 - Second set of topics\r\n * @returns {number} Similarity score\r\n */\r\nfunction calculateTopicSimilarity(topics1, topics2) {\r\n  const set1 = new Set(topics1);\r\n  const set2 = new Set(topics2);\r\n  \r\n  const intersection = new Set([...set1].filter(x => set2.has(x)));\r\n  const union = new Set([...set1, ...set2]);\r\n  \r\n  return intersection.size / union.size;\r\n}\r\n\r\n/**\r\n * Gets user performance history\r\n * @returns {Array} Performance history\r\n */\r\nfunction getPerformanceHistory() {\r\n  try {\r\n    const history = localStorage.getItem('quizHistory');\r\n    return history ? JSON.parse(history) : [];\r\n  } catch (error) {\r\n    console.error('Error loading quiz history:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculates difficulty distribution based on performance\r\n * @param {Array} history - Performance history\r\n * @returns {Object} Difficulty distribution\r\n */\r\nfunction calculateDifficultyDistribution(history) {\r\n  if (!history.length) {\r\n    return { easy: 0.4, medium: 0.4, hard: 0.2 }; // Default distribution\r\n  }\r\n  \r\n  // Calculate average performance\r\n  const recentQuizzes = history.slice(0, 5); // Consider last 5 quizzes\r\n  const avgScore = recentQuizzes.reduce((sum, quiz) => \r\n    sum + quiz.actualScore, 0\r\n  ) / recentQuizzes.length;\r\n  \r\n  // Adjust distribution based on performance\r\n  if (avgScore >= 85) {\r\n    return { easy: 0.2, medium: 0.5, hard: 0.3 }; // Increase difficulty\r\n  } else if (avgScore >= 70) {\r\n    return { easy: 0.3, medium: 0.4, hard: 0.3 }; // Balanced\r\n  } else {\r\n    return { easy: 0.5, medium: 0.3, hard: 0.2 }; // More easy questions\r\n  }\r\n}\r\n\r\n/**\r\n * Selects questions from a cluster\r\n * @param {Object} cluster - Topic cluster\r\n * @param {number} targetCount - Target questions from cluster\r\n * @param {Object} distribution - Difficulty distribution\r\n * @returns {Array} Selected questions\r\n */\r\nfunction selectQuestionsFromCluster(cluster, targetCount, distribution) {\r\n  const questions = [...cluster.questions];\r\n  const selected = [];\r\n  \r\n  // Calculate targets for each difficulty\r\n  const targets = {\r\n    easy: Math.round(targetCount * distribution.easy),\r\n    medium: Math.round(targetCount * distribution.medium),\r\n    hard: Math.round(targetCount * distribution.hard)\r\n  };\r\n  \r\n  // Select questions by difficulty\r\n  Object.entries(targets).forEach(([difficulty, count]) => {\r\n    const difficultyQuestions = questions.filter(q => \r\n      q.difficulty === difficulty && !selected.includes(q)\r\n    );\r\n    \r\n    // Shuffle to randomize selection\r\n    const shuffled = shuffleQuestions(difficultyQuestions);\r\n    selected.push(...shuffled.slice(0, count));\r\n  });\r\n  \r\n  return selected;\r\n}\r\n\r\n/**\r\n * Ensures minimum coverage of all difficulty levels\r\n * @param {Array} questions - Selected questions\r\n * @param {number} targetCount - Target question count\r\n * @returns {Array} Adjusted question set\r\n */\r\nfunction ensureMinimumDifficultyCoverage(questions, targetCount) {\r\n  const difficulties = ['easy', 'medium', 'hard'];\r\n  const minPerDifficulty = Math.max(1, Math.floor(targetCount * 0.2));\r\n  \r\n  const counts = questions.reduce((acc, q) => {\r\n    acc[q.difficulty] = (acc[q.difficulty] || 0) + 1;\r\n    return acc;\r\n  }, {});\r\n  \r\n  // Ensure minimum counts\r\n  difficulties.forEach(difficulty => {\r\n    if ((counts[difficulty] || 0) < minPerDifficulty) {\r\n      const needed = minPerDifficulty - (counts[difficulty] || 0);\r\n      const available = questions.filter(q => \r\n        q.difficulty === difficulty && !questions.includes(q)\r\n      );\r\n      \r\n      if (available.length > 0) {\r\n        const toAdd = shuffleQuestions(available).slice(0, needed);\r\n        // Remove questions from over-represented difficulties\r\n        const overRepresented = difficulties.find(d => \r\n          (counts[d] || 0) > minPerDifficulty + 1\r\n        );\r\n        \r\n        if (overRepresented) {\r\n          const toRemove = questions.filter(q => q.difficulty === overRepresented)\r\n            .slice(0, needed);\r\n          questions = questions.filter(q => !toRemove.includes(q));\r\n        }\r\n        \r\n        questions = [...questions, ...toAdd];\r\n      }\r\n    }\r\n  });\r\n  \r\n  return questions;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\r\n * Scoring Algorithms Module with Machine Learning\r\n */\n\n/**\r\n * Calculates weighted average score with adaptive weights\r\n * @param {Object} scores - Object containing different scores\r\n * @param {Object} weights - Weight for each score type\r\n * @returns {number} Final weighted score\r\n */\nexport function calculateWeightedScore(scores, weights) {\n  // Log input for debugging\n  console.log('Calculate Weighted Score - Inputs:', {\n    scores: scores,\n    weights: weights\n  });\n  var totalScore = 0;\n  var totalWeight = 0;\n\n  // Calculate weighted sum\n  Object.keys(weights).forEach(function (key) {\n    var score = parseFloat(scores[key]) || 0;\n    var weight = parseFloat(weights[key]) || 0;\n\n    // Log each calculation\n    console.log(\"Processing \".concat(key, \":\"), {\n      score: score,\n      weight: weight,\n      contribution: score * weight\n    });\n    totalScore += score * weight;\n    totalWeight += weight;\n  });\n\n  // Prevent division by zero\n  if (totalWeight === 0) {\n    console.log('Warning: Total weight is 0, returning default score of 70');\n    return 70;\n  }\n\n  // Calculate and normalize final score\n  var finalScore = totalScore / totalWeight;\n  console.log('Calculate Weighted Score - Result:', {\n    totalScore: totalScore,\n    totalWeight: totalWeight,\n    finalScore: normalizeScore(finalScore)\n  });\n  return normalizeScore(finalScore);\n}\n\n/**\r\n * Performs multi-factor analysis for prediction\r\n * @param {Object} factors - Different factors to analyze\r\n * @returns {Object} Analysis results\r\n */\nexport function analyzeMultipleFactors(factors) {\n  var analysis = {\n    contentCoverage: factors.contentCoverage || 0,\n    complexity: factors.complexity || 0,\n    diversity: factors.diversity || 0,\n    overallScore: 0,\n    confidence: 0\n  };\n\n  // Calculate overall score\n  analysis.overallScore = calculateWeightedScore(factors, {\n    contentCoverage: 0.4,\n    complexity: 0.3,\n    diversity: 0.3\n  });\n\n  // Calculate confidence based on data completeness\n  var availableFactors = Object.keys(factors).filter(function (key) {\n    return factors[key] !== undefined;\n  }).length;\n  analysis.confidence = availableFactors / Object.keys(factors).length * 100;\n  return analysis;\n}\n\n/**\r\n * Normalizes scores to a specific range\r\n * @param {number} score - Raw score\r\n * @param {number} min - Minimum value\r\n * @param {number} max - Maximum value\r\n * @returns {number} Normalized score\r\n */\nexport function normalizeScore(score) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  return Math.max(min, Math.min(max, score));\n}\n\n/**\r\n * Predicts performance using machine learning model\r\n * @param {Object} metrics - Performance metrics\r\n * @returns {Object} Performance prediction\r\n */\nexport function predictPerformance(metrics) {\n  // Get historical data for model training\n  var historicalData = getHistoricalData();\n\n  // Train model if enough data is available\n  if (historicalData.length >= 10) {\n    trainModel(historicalData);\n  }\n\n  // Get prediction from trained model or use heuristic approach\n  var prediction = historicalData.length >= 10 ? getPredictionFromModel(metrics) : getPredictionFromHeuristics(metrics);\n\n  // Update weights based on prediction accuracy\n  updateWeights(prediction);\n  return {\n    predictedScore: normalizeScore(prediction.score),\n    confidence: prediction.confidence,\n    factors: {\n      contentComplexity: metrics.contentComplexity || 0,\n      questionDifficulty: metrics.questionDifficulty || 0,\n      contentCoverage: metrics.contentCoverage || 0,\n      topicDiversity: metrics.topicDiversity || 0\n    },\n    model: {\n      type: historicalData.length >= 10 ? 'machine-learning' : 'heuristic',\n      accuracy: prediction.accuracy,\n      dataPoints: historicalData.length\n    }\n  };\n}\n\n/**\r\n * Gets historical performance data from storage\r\n * @returns {Array} Historical data\r\n */\nfunction getHistoricalData() {\n  try {\n    var data = localStorage.getItem('performanceHistory');\n    return data ? JSON.parse(data) : [];\n  } catch (error) {\n    console.error('Error loading historical data:', error);\n    return [];\n  }\n}\n\n/**\r\n * Gets adaptive weights from storage\r\n * @returns {Object|null} Adaptive weights\r\n */\nfunction getAdaptiveWeights() {\n  try {\n    var weights = localStorage.getItem('adaptiveWeights');\n    return weights ? JSON.parse(weights) : null;\n  } catch (error) {\n    console.error('Error loading adaptive weights:', error);\n    return null;\n  }\n}\n\n/**\r\n * Trains machine learning model on historical data\r\n * @param {Array} data - Training data\r\n */\nfunction trainModel(data) {\n  // Prepare training data\n  var features = data.map(function (entry) {\n    return [entry.metrics.contentComplexity, entry.metrics.questionDifficulty, entry.metrics.contentCoverage, entry.metrics.topicDiversity];\n  });\n  var labels = data.map(function (entry) {\n    return entry.actualScore;\n  });\n\n  // Train model using simple linear regression\n  var model = trainLinearRegression(features, labels);\n\n  // Save model parameters\n  localStorage.setItem('modelParameters', JSON.stringify(model));\n}\n\n/**\r\n * Gets prediction from trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\nfunction getPredictionFromModel(metrics) {\n  try {\n    var model = JSON.parse(localStorage.getItem('modelParameters'));\n    if (!model) return getPredictionFromHeuristics(metrics);\n\n    // Prepare feature vector\n    var features = [metrics.contentComplexity, metrics.questionDifficulty, metrics.contentCoverage, metrics.topicDiversity];\n\n    // Make prediction\n    var predictedScore = predictLinearRegression(features, model);\n    var confidence = calculateModelConfidence(model, metrics);\n    return {\n      score: predictedScore,\n      confidence: confidence,\n      accuracy: model.accuracy,\n      method: 'machine-learning'\n    };\n  } catch (error) {\n    console.error('Error using ML model:', error);\n    return getPredictionFromHeuristics(metrics);\n  }\n}\n\n/**\r\n * Gets prediction using heuristic approach\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\nfunction getPredictionFromHeuristics(metrics) {\n  // Log incoming metrics\n  console.log('Heuristic Prediction - Input Metrics:', metrics);\n\n  // Ensure metrics has valid values\n  var validMetrics = {\n    contentComplexity: Math.min(100, Math.max(0, metrics.contentComplexity || 50)),\n    questionDifficulty: Math.min(100, Math.max(0, metrics.questionDifficulty || 50)),\n    contentCoverage: Math.min(100, Math.max(0, metrics.contentCoverage || 50)),\n    topicDiversity: Math.min(100, Math.max(0, metrics.topicDiversity || 50))\n  };\n\n  // Log validated metrics\n  console.log('Heuristic Prediction - Validated Metrics:', validMetrics);\n\n  // Calculate base prediction considering content factors\n  var contentScore = calculateContentScore(validMetrics);\n\n  // Calculate question-based adjustment\n  var questionAdjustment = calculateQuestionAdjustment(validMetrics);\n\n  // Calculate diversity bonus\n  var diversityBonus = calculateDiversityBonus(validMetrics.topicDiversity);\n\n  // Calculate final base score\n  var baseScore = Math.min(100, contentScore + questionAdjustment + diversityBonus);\n\n  // Calculate confidence based on metric availability and values\n  var confidence = calculateConfidence(validMetrics);\n\n  // Adjust score based on confidence\n  var adjustedScore = baseScore * (confidence / 100);\n\n  // Ensure final score is between 0 and 100\n  var finalScore = normalizeScore(adjustedScore);\n\n  // Log prediction details\n  console.log('Heuristic Prediction - Details:', {\n    contentScore: contentScore,\n    questionAdjustment: questionAdjustment,\n    diversityBonus: diversityBonus,\n    baseScore: baseScore,\n    confidence: confidence,\n    adjustedScore: adjustedScore,\n    finalScore: finalScore\n  });\n  return {\n    score: finalScore,\n    confidence: confidence,\n    accuracy: 0.7,\n    method: 'heuristic'\n  };\n}\n\n/**\r\n * Calculates score based on content metrics\r\n * @param {Object} metrics - Validated metrics\r\n * @returns {number} Content-based score\r\n */\nfunction calculateContentScore(metrics) {\n  // Higher content coverage should lead to better predicted performance\n  var coverageWeight = 0.4;\n  var complexityWeight = 0.6;\n\n  // Inverse relationship with complexity (higher complexity = lower base score)\n  var complexityScore = 100 - metrics.contentComplexity * 0.3;\n\n  // Direct relationship with coverage\n  var coverageScore = metrics.contentCoverage;\n  return complexityScore * complexityWeight + coverageScore * coverageWeight;\n}\n\n/**\r\n * Calculates adjustment based on question metrics\r\n * @param {Object} metrics - Validated metrics\r\n * @returns {number} Question-based adjustment\r\n */\nfunction calculateQuestionAdjustment(metrics) {\n  // Base adjustment on question difficulty\n  var difficultyImpact = (100 - metrics.questionDifficulty) * 0.2;\n\n  // Add bonus for balanced difficulty distribution\n  var balanceBonus = metrics.questionDifficulty > 40 && metrics.questionDifficulty < 60 ? 5 : 0;\n  return difficultyImpact + balanceBonus;\n}\n\n/**\r\n * Calculates bonus based on topic diversity\r\n * @param {number} diversity - Topic diversity score\r\n * @returns {number} Diversity bonus\r\n */\nfunction calculateDiversityBonus(diversity) {\n  // Higher diversity should give a small bonus to predicted score\n  // as it indicates comprehensive understanding\n  return diversity > 80 ? 10 : diversity > 60 ? 5 : 0;\n}\n\n/**\r\n * Calculates confidence in prediction\r\n * @param {Object} metrics - Validated metrics\r\n * @returns {number} Confidence score\r\n */\nfunction calculateConfidence(metrics) {\n  // Calculate how many metrics are well-defined\n  var definedMetrics = Object.values(metrics).filter(function (v) {\n    return v !== undefined && v !== null;\n  }).length;\n  var totalMetrics = Object.keys(metrics).length;\n\n  // Base confidence on metric availability\n  var confidence = definedMetrics / totalMetrics * 100;\n\n  // Adjust confidence based on metric values\n  var hasExtremeDifficulty = metrics.questionDifficulty < 20 || metrics.questionDifficulty > 80;\n  var hasExtremeComplexity = metrics.contentComplexity < 20 || metrics.contentComplexity > 80;\n  if (hasExtremeDifficulty) confidence *= 0.9;\n  if (hasExtremeComplexity) confidence *= 0.9;\n  return Math.min(100, Math.max(0, confidence));\n}\n\n/**\r\n * Updates weights based on prediction accuracy\r\n * @param {Object} prediction - Prediction results\r\n */\nfunction updateWeights(prediction) {\n  var currentWeights = getAdaptiveWeights() || {\n    contentComplexity: 0.3,\n    questionDifficulty: 0.3,\n    contentCoverage: 0.2,\n    topicDiversity: 0.2\n  };\n\n  // Adjust weights based on prediction accuracy\n  if (prediction.accuracy < 0.8) {\n    var adjustedWeights = {};\n    Object.keys(currentWeights).forEach(function (key) {\n      var correlation = calculateCorrelation(getHistoricalData(), key, 'actualScore');\n      adjustedWeights[key] = normalizeWeight(currentWeights[key] * (1 + correlation));\n    });\n\n    // Normalize weights to sum to 1\n    var totalWeight = Object.values(adjustedWeights).reduce(function (a, b) {\n      return a + b;\n    }, 0);\n    Object.keys(adjustedWeights).forEach(function (key) {\n      adjustedWeights[key] /= totalWeight;\n    });\n\n    // Save adjusted weights\n    localStorage.setItem('adaptiveWeights', JSON.stringify(adjustedWeights));\n  }\n}\n\n/**\r\n * Trains simple linear regression model\r\n * @param {Array} features - Training features\r\n * @param {Array} labels - Training labels\r\n * @returns {Object} Trained model parameters\r\n */\nfunction trainLinearRegression(features, labels) {\n  var n = features.length;\n  var numFeatures = features[0].length;\n\n  // Initialize parameters\n  var weights = new Array(numFeatures).fill(0);\n  var learningRate = 0.01;\n  var iterations = 100;\n\n  // Gradient descent\n  for (var iter = 0; iter < iterations; iter++) {\n    var _predictions = features.map(function (feature) {\n      return feature.reduce(function (sum, value, i) {\n        return sum + value * weights[i];\n      }, 0);\n    });\n\n    // Update weights\n    var _loop = function _loop(j) {\n      var gradient = _predictions.reduce(function (sum, pred, i) {\n        return sum + (pred - labels[i]) * features[i][j];\n      }, 0) / n;\n      weights[j] -= learningRate * gradient;\n    };\n    for (var j = 0; j < numFeatures; j++) {\n      _loop(j);\n    }\n  }\n\n  // Calculate model accuracy\n  var predictions = features.map(function (feature) {\n    return feature.reduce(function (sum, value, i) {\n      return sum + value * weights[i];\n    }, 0);\n  });\n  var accuracy = 1 - calculateRMSE(predictions, labels) / 100;\n  return {\n    weights: weights,\n    accuracy: accuracy\n  };\n}\n\n/**\r\n * Predicts using linear regression model\r\n * @param {Array} features - Input features\r\n * @param {Object} model - Trained model\r\n * @returns {number} Predicted score\r\n */\nfunction predictLinearRegression(features, model) {\n  return features.reduce(function (sum, value, i) {\n    return sum + value * model.weights[i];\n  }, 0);\n}\n\n/**\r\n * Calculates root mean square error\r\n * @param {Array} predictions - Predicted values\r\n * @param {Array} actuals - Actual values\r\n * @returns {number} RMSE value\r\n */\nfunction calculateRMSE(predictions, actuals) {\n  var squaredErrors = predictions.map(function (pred, i) {\n    return Math.pow(pred - actuals[i], 2);\n  });\n  return Math.sqrt(squaredErrors.reduce(function (a, b) {\n    return a + b;\n  }, 0) / predictions.length);\n}\n\n/**\r\n * Calculates correlation between two variables\r\n * @param {Array} data - Historical data\r\n * @param {string} variable1 - First variable name\r\n * @param {string} variable2 - Second variable name\r\n * @returns {number} Correlation coefficient\r\n */\nfunction calculateCorrelation(data, variable1, variable2) {\n  var values1 = data.map(function (entry) {\n    return variable1.includes('.') ? entry.metrics[variable1.split('.')[1]] : entry[variable1];\n  });\n  var values2 = data.map(function (entry) {\n    return entry[variable2];\n  });\n  var mean1 = values1.reduce(function (a, b) {\n    return a + b;\n  }, 0) / values1.length;\n  var mean2 = values2.reduce(function (a, b) {\n    return a + b;\n  }, 0) / values2.length;\n  var variance1 = values1.reduce(function (sum, val) {\n    return sum + Math.pow(val - mean1, 2);\n  }, 0);\n  var variance2 = values2.reduce(function (sum, val) {\n    return sum + Math.pow(val - mean2, 2);\n  }, 0);\n  var covariance = values1.reduce(function (sum, val, i) {\n    return sum + (val - mean1) * (values2[i] - mean2);\n  }, 0);\n  return covariance / Math.sqrt(variance1 * variance2);\n}\n\n/**\r\n * Normalizes a weight value\r\n * @param {number} weight - Weight to normalize\r\n * @returns {number} Normalized weight\r\n */\nfunction normalizeWeight(weight) {\n  return Math.max(0.1, Math.min(0.5, weight));\n}\n\n/**\r\n * Calculates model confidence\r\n * @param {Object} model - Trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {number} Confidence score\r\n */\nfunction calculateModelConfidence(model, metrics) {\n  // Base confidence on model accuracy\n  var confidence = model.accuracy * 100;\n\n  // Adjust based on data completeness\n  var completeness = Object.values(metrics).filter(function (v) {\n    return v !== undefined;\n  }).length / 4;\n  confidence *= completeness;\n\n  // Adjust based on metric values being within expected ranges\n  var inRange = Object.values(metrics).every(function (v) {\n    return v >= 0 && v <= 100;\n  });\n  if (!inRange) confidence *= 0.8;\n  return Math.min(100, confidence);\n}","map":{"version":3,"names":["calculateWeightedScore","scores","weights","console","log","totalScore","totalWeight","Object","keys","forEach","key","score","parseFloat","weight","concat","contribution","finalScore","normalizeScore","analyzeMultipleFactors","factors","analysis","contentCoverage","complexity","diversity","overallScore","confidence","availableFactors","filter","undefined","length","min","arguments","max","Math","predictPerformance","metrics","historicalData","getHistoricalData","trainModel","prediction","getPredictionFromModel","getPredictionFromHeuristics","updateWeights","predictedScore","contentComplexity","questionDifficulty","topicDiversity","model","type","accuracy","dataPoints","data","localStorage","getItem","JSON","parse","error","getAdaptiveWeights","features","map","entry","labels","actualScore","trainLinearRegression","setItem","stringify","predictLinearRegression","calculateModelConfidence","method","validMetrics","contentScore","calculateContentScore","questionAdjustment","calculateQuestionAdjustment","diversityBonus","calculateDiversityBonus","baseScore","calculateConfidence","adjustedScore","coverageWeight","complexityWeight","complexityScore","coverageScore","difficultyImpact","balanceBonus","definedMetrics","values","v","totalMetrics","hasExtremeDifficulty","hasExtremeComplexity","currentWeights","adjustedWeights","correlation","calculateCorrelation","normalizeWeight","reduce","a","b","n","numFeatures","Array","fill","learningRate","iterations","iter","predictions","feature","sum","value","i","_loop","j","gradient","pred","calculateRMSE","actuals","squaredErrors","pow","sqrt","variable1","variable2","values1","includes","split","values2","mean1","mean2","variance1","val","variance2","covariance","completeness","inRange","every"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/scoring/index.js"],"sourcesContent":["/**\r\n * Scoring Algorithms Module with Machine Learning\r\n */\r\n\r\n/**\r\n * Calculates weighted average score with adaptive weights\r\n * @param {Object} scores - Object containing different scores\r\n * @param {Object} weights - Weight for each score type\r\n * @returns {number} Final weighted score\r\n */\r\nexport function calculateWeightedScore(scores, weights) {\r\n  // Log input for debugging\r\n  console.log('Calculate Weighted Score - Inputs:', { scores, weights });\r\n  \r\n  let totalScore = 0;\r\n  let totalWeight = 0;\r\n  \r\n  // Calculate weighted sum\r\n  Object.keys(weights).forEach(key => {\r\n    const score = parseFloat(scores[key]) || 0;\r\n    const weight = parseFloat(weights[key]) || 0;\r\n    \r\n    // Log each calculation\r\n    console.log(`Processing ${key}:`, { score, weight, contribution: score * weight });\r\n    \r\n    totalScore += score * weight;\r\n    totalWeight += weight;\r\n  });\r\n  \r\n  // Prevent division by zero\r\n  if (totalWeight === 0) {\r\n    console.log('Warning: Total weight is 0, returning default score of 70');\r\n    return 70;\r\n  }\r\n  \r\n  // Calculate and normalize final score\r\n  const finalScore = totalScore / totalWeight;\r\n  console.log('Calculate Weighted Score - Result:', {\r\n    totalScore,\r\n    totalWeight,\r\n    finalScore: normalizeScore(finalScore)\r\n  });\r\n  \r\n  return normalizeScore(finalScore);\r\n}\r\n\r\n/**\r\n * Performs multi-factor analysis for prediction\r\n * @param {Object} factors - Different factors to analyze\r\n * @returns {Object} Analysis results\r\n */\r\nexport function analyzeMultipleFactors(factors) {\r\n  const analysis = {\r\n    contentCoverage: factors.contentCoverage || 0,\r\n    complexity: factors.complexity || 0,\r\n    diversity: factors.diversity || 0,\r\n    overallScore: 0,\r\n    confidence: 0\r\n  };\r\n  \r\n  // Calculate overall score\r\n  analysis.overallScore = calculateWeightedScore(factors, {\r\n    contentCoverage: 0.4,\r\n    complexity: 0.3,\r\n    diversity: 0.3\r\n  });\r\n  \r\n  // Calculate confidence based on data completeness\r\n  const availableFactors = Object.keys(factors).filter(key => factors[key] !== undefined).length;\r\n  analysis.confidence = (availableFactors / Object.keys(factors).length) * 100;\r\n  \r\n  return analysis;\r\n}\r\n\r\n/**\r\n * Normalizes scores to a specific range\r\n * @param {number} score - Raw score\r\n * @param {number} min - Minimum value\r\n * @param {number} max - Maximum value\r\n * @returns {number} Normalized score\r\n */\r\nexport function normalizeScore(score, min = 0, max = 100) {\r\n  return Math.max(min, Math.min(max, score));\r\n}\r\n\r\n/**\r\n * Predicts performance using machine learning model\r\n * @param {Object} metrics - Performance metrics\r\n * @returns {Object} Performance prediction\r\n */\r\nexport function predictPerformance(metrics) {\r\n  // Get historical data for model training\r\n  const historicalData = getHistoricalData();\r\n  \r\n  // Train model if enough data is available\r\n  if (historicalData.length >= 10) {\r\n    trainModel(historicalData);\r\n  }\r\n  \r\n  // Get prediction from trained model or use heuristic approach\r\n  const prediction = historicalData.length >= 10 \r\n    ? getPredictionFromModel(metrics)\r\n    : getPredictionFromHeuristics(metrics);\r\n  \r\n  // Update weights based on prediction accuracy\r\n  updateWeights(prediction);\r\n  \r\n  return {\r\n    predictedScore: normalizeScore(prediction.score),\r\n    confidence: prediction.confidence,\r\n    factors: {\r\n      contentComplexity: metrics.contentComplexity || 0,\r\n      questionDifficulty: metrics.questionDifficulty || 0,\r\n      contentCoverage: metrics.contentCoverage || 0,\r\n      topicDiversity: metrics.topicDiversity || 0\r\n    },\r\n    model: {\r\n      type: historicalData.length >= 10 ? 'machine-learning' : 'heuristic',\r\n      accuracy: prediction.accuracy,\r\n      dataPoints: historicalData.length\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Gets historical performance data from storage\r\n * @returns {Array} Historical data\r\n */\r\nfunction getHistoricalData() {\r\n  try {\r\n    const data = localStorage.getItem('performanceHistory');\r\n    return data ? JSON.parse(data) : [];\r\n  } catch (error) {\r\n    console.error('Error loading historical data:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Gets adaptive weights from storage\r\n * @returns {Object|null} Adaptive weights\r\n */\r\nfunction getAdaptiveWeights() {\r\n  try {\r\n    const weights = localStorage.getItem('adaptiveWeights');\r\n    return weights ? JSON.parse(weights) : null;\r\n  } catch (error) {\r\n    console.error('Error loading adaptive weights:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Trains machine learning model on historical data\r\n * @param {Array} data - Training data\r\n */\r\nfunction trainModel(data) {\r\n  // Prepare training data\r\n  const features = data.map(entry => [\r\n    entry.metrics.contentComplexity,\r\n    entry.metrics.questionDifficulty,\r\n    entry.metrics.contentCoverage,\r\n    entry.metrics.topicDiversity\r\n  ]);\r\n  \r\n  const labels = data.map(entry => entry.actualScore);\r\n  \r\n  // Train model using simple linear regression\r\n  const model = trainLinearRegression(features, labels);\r\n  \r\n  // Save model parameters\r\n  localStorage.setItem('modelParameters', JSON.stringify(model));\r\n}\r\n\r\n/**\r\n * Gets prediction from trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\r\nfunction getPredictionFromModel(metrics) {\r\n  try {\r\n    const model = JSON.parse(localStorage.getItem('modelParameters'));\r\n    if (!model) return getPredictionFromHeuristics(metrics);\r\n    \r\n    // Prepare feature vector\r\n    const features = [\r\n      metrics.contentComplexity,\r\n      metrics.questionDifficulty,\r\n      metrics.contentCoverage,\r\n      metrics.topicDiversity\r\n    ];\r\n    \r\n    // Make prediction\r\n    const predictedScore = predictLinearRegression(features, model);\r\n    const confidence = calculateModelConfidence(model, metrics);\r\n    \r\n    return {\r\n      score: predictedScore,\r\n      confidence,\r\n      accuracy: model.accuracy,\r\n      method: 'machine-learning'\r\n    };\r\n  } catch (error) {\r\n    console.error('Error using ML model:', error);\r\n    return getPredictionFromHeuristics(metrics);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets prediction using heuristic approach\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\r\nfunction getPredictionFromHeuristics(metrics) {\r\n  // Log incoming metrics\r\n  console.log('Heuristic Prediction - Input Metrics:', metrics);\r\n\r\n  // Ensure metrics has valid values\r\n  const validMetrics = {\r\n    contentComplexity: Math.min(100, Math.max(0, metrics.contentComplexity || 50)),\r\n    questionDifficulty: Math.min(100, Math.max(0, metrics.questionDifficulty || 50)),\r\n    contentCoverage: Math.min(100, Math.max(0, metrics.contentCoverage || 50)),\r\n    topicDiversity: Math.min(100, Math.max(0, metrics.topicDiversity || 50))\r\n  };\r\n\r\n  // Log validated metrics\r\n  console.log('Heuristic Prediction - Validated Metrics:', validMetrics);\r\n\r\n  // Calculate base prediction considering content factors\r\n  const contentScore = calculateContentScore(validMetrics);\r\n  \r\n  // Calculate question-based adjustment\r\n  const questionAdjustment = calculateQuestionAdjustment(validMetrics);\r\n  \r\n  // Calculate diversity bonus\r\n  const diversityBonus = calculateDiversityBonus(validMetrics.topicDiversity);\r\n\r\n  // Calculate final base score\r\n  const baseScore = Math.min(100, contentScore + questionAdjustment + diversityBonus);\r\n  \r\n  // Calculate confidence based on metric availability and values\r\n  const confidence = calculateConfidence(validMetrics);\r\n  \r\n  // Adjust score based on confidence\r\n  const adjustedScore = baseScore * (confidence / 100);\r\n  \r\n  // Ensure final score is between 0 and 100\r\n  const finalScore = normalizeScore(adjustedScore);\r\n\r\n  // Log prediction details\r\n  console.log('Heuristic Prediction - Details:', {\r\n    contentScore,\r\n    questionAdjustment,\r\n    diversityBonus,\r\n    baseScore,\r\n    confidence,\r\n    adjustedScore,\r\n    finalScore\r\n  });\r\n  \r\n  return {\r\n    score: finalScore,\r\n    confidence,\r\n    accuracy: 0.7,\r\n    method: 'heuristic'\r\n  };\r\n}\r\n\r\n/**\r\n * Calculates score based on content metrics\r\n * @param {Object} metrics - Validated metrics\r\n * @returns {number} Content-based score\r\n */\r\nfunction calculateContentScore(metrics) {\r\n  // Higher content coverage should lead to better predicted performance\r\n  const coverageWeight = 0.4;\r\n  const complexityWeight = 0.6;\r\n  \r\n  // Inverse relationship with complexity (higher complexity = lower base score)\r\n  const complexityScore = 100 - (metrics.contentComplexity * 0.3);\r\n  \r\n  // Direct relationship with coverage\r\n  const coverageScore = metrics.contentCoverage;\r\n  \r\n  return (complexityScore * complexityWeight) + (coverageScore * coverageWeight);\r\n}\r\n\r\n/**\r\n * Calculates adjustment based on question metrics\r\n * @param {Object} metrics - Validated metrics\r\n * @returns {number} Question-based adjustment\r\n */\r\nfunction calculateQuestionAdjustment(metrics) {\r\n  // Base adjustment on question difficulty\r\n  const difficultyImpact = (100 - metrics.questionDifficulty) * 0.2;\r\n  \r\n  // Add bonus for balanced difficulty distribution\r\n  const balanceBonus = metrics.questionDifficulty > 40 && metrics.questionDifficulty < 60 ? 5 : 0;\r\n  \r\n  return difficultyImpact + balanceBonus;\r\n}\r\n\r\n/**\r\n * Calculates bonus based on topic diversity\r\n * @param {number} diversity - Topic diversity score\r\n * @returns {number} Diversity bonus\r\n */\r\nfunction calculateDiversityBonus(diversity) {\r\n  // Higher diversity should give a small bonus to predicted score\r\n  // as it indicates comprehensive understanding\r\n  return diversity > 80 ? 10 : diversity > 60 ? 5 : 0;\r\n}\r\n\r\n/**\r\n * Calculates confidence in prediction\r\n * @param {Object} metrics - Validated metrics\r\n * @returns {number} Confidence score\r\n */\r\nfunction calculateConfidence(metrics) {\r\n  // Calculate how many metrics are well-defined\r\n  const definedMetrics = Object.values(metrics).filter(v => v !== undefined && v !== null).length;\r\n  const totalMetrics = Object.keys(metrics).length;\r\n  \r\n  // Base confidence on metric availability\r\n  let confidence = (definedMetrics / totalMetrics) * 100;\r\n  \r\n  // Adjust confidence based on metric values\r\n  const hasExtremeDifficulty = metrics.questionDifficulty < 20 || metrics.questionDifficulty > 80;\r\n  const hasExtremeComplexity = metrics.contentComplexity < 20 || metrics.contentComplexity > 80;\r\n  \r\n  if (hasExtremeDifficulty) confidence *= 0.9;\r\n  if (hasExtremeComplexity) confidence *= 0.9;\r\n  \r\n  return Math.min(100, Math.max(0, confidence));\r\n}\r\n\r\n/**\r\n * Updates weights based on prediction accuracy\r\n * @param {Object} prediction - Prediction results\r\n */\r\nfunction updateWeights(prediction) {\r\n  const currentWeights = getAdaptiveWeights() || {\r\n    contentComplexity: 0.3,\r\n    questionDifficulty: 0.3,\r\n    contentCoverage: 0.2,\r\n    topicDiversity: 0.2\r\n  };\r\n  \r\n  // Adjust weights based on prediction accuracy\r\n  if (prediction.accuracy < 0.8) {\r\n    const adjustedWeights = {};\r\n    Object.keys(currentWeights).forEach(key => {\r\n      const correlation = calculateCorrelation(\r\n        getHistoricalData(),\r\n        key,\r\n        'actualScore'\r\n      );\r\n      adjustedWeights[key] = normalizeWeight(currentWeights[key] * (1 + correlation));\r\n    });\r\n    \r\n    // Normalize weights to sum to 1\r\n    const totalWeight = Object.values(adjustedWeights).reduce((a, b) => a + b, 0);\r\n    Object.keys(adjustedWeights).forEach(key => {\r\n      adjustedWeights[key] /= totalWeight;\r\n    });\r\n    \r\n    // Save adjusted weights\r\n    localStorage.setItem('adaptiveWeights', JSON.stringify(adjustedWeights));\r\n  }\r\n}\r\n\r\n/**\r\n * Trains simple linear regression model\r\n * @param {Array} features - Training features\r\n * @param {Array} labels - Training labels\r\n * @returns {Object} Trained model parameters\r\n */\r\nfunction trainLinearRegression(features, labels) {\r\n  const n = features.length;\r\n  const numFeatures = features[0].length;\r\n  \r\n  // Initialize parameters\r\n  const weights = new Array(numFeatures).fill(0);\r\n  const learningRate = 0.01;\r\n  const iterations = 100;\r\n  \r\n  // Gradient descent\r\n  for (let iter = 0; iter < iterations; iter++) {\r\n    const predictions = features.map(feature => \r\n      feature.reduce((sum, value, i) => sum + value * weights[i], 0)\r\n    );\r\n    \r\n    // Update weights\r\n    for (let j = 0; j < numFeatures; j++) {\r\n      const gradient = predictions.reduce((sum, pred, i) => \r\n        sum + (pred - labels[i]) * features[i][j], 0\r\n      ) / n;\r\n      \r\n      weights[j] -= learningRate * gradient;\r\n    }\r\n  }\r\n  \r\n  // Calculate model accuracy\r\n  const predictions = features.map(feature => \r\n    feature.reduce((sum, value, i) => sum + value * weights[i], 0)\r\n  );\r\n  \r\n  const accuracy = 1 - calculateRMSE(predictions, labels) / 100;\r\n  \r\n  return { weights, accuracy };\r\n}\r\n\r\n/**\r\n * Predicts using linear regression model\r\n * @param {Array} features - Input features\r\n * @param {Object} model - Trained model\r\n * @returns {number} Predicted score\r\n */\r\nfunction predictLinearRegression(features, model) {\r\n  return features.reduce((sum, value, i) => sum + value * model.weights[i], 0);\r\n}\r\n\r\n/**\r\n * Calculates root mean square error\r\n * @param {Array} predictions - Predicted values\r\n * @param {Array} actuals - Actual values\r\n * @returns {number} RMSE value\r\n */\r\nfunction calculateRMSE(predictions, actuals) {\r\n  const squaredErrors = predictions.map((pred, i) => \r\n    Math.pow(pred - actuals[i], 2)\r\n  );\r\n  return Math.sqrt(squaredErrors.reduce((a, b) => a + b, 0) / predictions.length);\r\n}\r\n\r\n/**\r\n * Calculates correlation between two variables\r\n * @param {Array} data - Historical data\r\n * @param {string} variable1 - First variable name\r\n * @param {string} variable2 - Second variable name\r\n * @returns {number} Correlation coefficient\r\n */\r\nfunction calculateCorrelation(data, variable1, variable2) {\r\n  const values1 = data.map(entry => \r\n    variable1.includes('.') \r\n      ? entry.metrics[variable1.split('.')[1]]\r\n      : entry[variable1]\r\n  );\r\n  \r\n  const values2 = data.map(entry => entry[variable2]);\r\n  \r\n  const mean1 = values1.reduce((a, b) => a + b, 0) / values1.length;\r\n  const mean2 = values2.reduce((a, b) => a + b, 0) / values2.length;\r\n  \r\n  const variance1 = values1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0);\r\n  const variance2 = values2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0);\r\n  \r\n  const covariance = values1.reduce((sum, val, i) => \r\n    sum + (val - mean1) * (values2[i] - mean2), 0\r\n  );\r\n  \r\n  return covariance / Math.sqrt(variance1 * variance2);\r\n}\r\n\r\n/**\r\n * Normalizes a weight value\r\n * @param {number} weight - Weight to normalize\r\n * @returns {number} Normalized weight\r\n */\r\nfunction normalizeWeight(weight) {\r\n  return Math.max(0.1, Math.min(0.5, weight));\r\n}\r\n\r\n/**\r\n * Calculates model confidence\r\n * @param {Object} model - Trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {number} Confidence score\r\n */\r\nfunction calculateModelConfidence(model, metrics) {\r\n  // Base confidence on model accuracy\r\n  let confidence = model.accuracy * 100;\r\n  \r\n  // Adjust based on data completeness\r\n  const completeness = Object.values(metrics).filter(v => v !== undefined).length / 4;\r\n  confidence *= completeness;\r\n  \r\n  // Adjust based on metric values being within expected ranges\r\n  const inRange = Object.values(metrics).every(v => v >= 0 && v <= 100);\r\n  if (!inRange) confidence *= 0.8;\r\n  \r\n  return Math.min(100, confidence);\r\n} "],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,sBAAsBA,CAACC,MAAM,EAAEC,OAAO,EAAE;EACtD;EACAC,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAE;IAAEH,MAAM,EAANA,MAAM;IAAEC,OAAO,EAAPA;EAAQ,CAAC,CAAC;EAEtE,IAAIG,UAAU,GAAG,CAAC;EAClB,IAAIC,WAAW,GAAG,CAAC;;EAEnB;EACAC,MAAM,CAACC,IAAI,CAACN,OAAO,CAAC,CAACO,OAAO,CAAC,UAAAC,GAAG,EAAI;IAClC,IAAMC,KAAK,GAAGC,UAAU,CAACX,MAAM,CAACS,GAAG,CAAC,CAAC,IAAI,CAAC;IAC1C,IAAMG,MAAM,GAAGD,UAAU,CAACV,OAAO,CAACQ,GAAG,CAAC,CAAC,IAAI,CAAC;;IAE5C;IACAP,OAAO,CAACC,GAAG,eAAAU,MAAA,CAAeJ,GAAG,QAAK;MAAEC,KAAK,EAALA,KAAK;MAAEE,MAAM,EAANA,MAAM;MAAEE,YAAY,EAAEJ,KAAK,GAAGE;IAAO,CAAC,CAAC;IAElFR,UAAU,IAAIM,KAAK,GAAGE,MAAM;IAC5BP,WAAW,IAAIO,MAAM;EACvB,CAAC,CAAC;;EAEF;EACA,IAAIP,WAAW,KAAK,CAAC,EAAE;IACrBH,OAAO,CAACC,GAAG,CAAC,2DAA2D,CAAC;IACxE,OAAO,EAAE;EACX;;EAEA;EACA,IAAMY,UAAU,GAAGX,UAAU,GAAGC,WAAW;EAC3CH,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAE;IAChDC,UAAU,EAAVA,UAAU;IACVC,WAAW,EAAXA,WAAW;IACXU,UAAU,EAAEC,cAAc,CAACD,UAAU;EACvC,CAAC,CAAC;EAEF,OAAOC,cAAc,CAACD,UAAU,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,sBAAsBA,CAACC,OAAO,EAAE;EAC9C,IAAMC,QAAQ,GAAG;IACfC,eAAe,EAAEF,OAAO,CAACE,eAAe,IAAI,CAAC;IAC7CC,UAAU,EAAEH,OAAO,CAACG,UAAU,IAAI,CAAC;IACnCC,SAAS,EAAEJ,OAAO,CAACI,SAAS,IAAI,CAAC;IACjCC,YAAY,EAAE,CAAC;IACfC,UAAU,EAAE;EACd,CAAC;;EAED;EACAL,QAAQ,CAACI,YAAY,GAAGxB,sBAAsB,CAACmB,OAAO,EAAE;IACtDE,eAAe,EAAE,GAAG;IACpBC,UAAU,EAAE,GAAG;IACfC,SAAS,EAAE;EACb,CAAC,CAAC;;EAEF;EACA,IAAMG,gBAAgB,GAAGnB,MAAM,CAACC,IAAI,CAACW,OAAO,CAAC,CAACQ,MAAM,CAAC,UAAAjB,GAAG;IAAA,OAAIS,OAAO,CAACT,GAAG,CAAC,KAAKkB,SAAS;EAAA,EAAC,CAACC,MAAM;EAC9FT,QAAQ,CAACK,UAAU,GAAIC,gBAAgB,GAAGnB,MAAM,CAACC,IAAI,CAACW,OAAO,CAAC,CAACU,MAAM,GAAI,GAAG;EAE5E,OAAOT,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASH,cAAcA,CAACN,KAAK,EAAsB;EAAA,IAApBmB,GAAG,GAAAC,SAAA,CAAAF,MAAA,QAAAE,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,CAAC;EAAA,IAAEC,GAAG,GAAAD,SAAA,CAAAF,MAAA,QAAAE,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAG,GAAG;EACtD,OAAOE,IAAI,CAACD,GAAG,CAACF,GAAG,EAAEG,IAAI,CAACH,GAAG,CAACE,GAAG,EAAErB,KAAK,CAAC,CAAC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuB,kBAAkBA,CAACC,OAAO,EAAE;EAC1C;EACA,IAAMC,cAAc,GAAGC,iBAAiB,CAAC,CAAC;;EAE1C;EACA,IAAID,cAAc,CAACP,MAAM,IAAI,EAAE,EAAE;IAC/BS,UAAU,CAACF,cAAc,CAAC;EAC5B;;EAEA;EACA,IAAMG,UAAU,GAAGH,cAAc,CAACP,MAAM,IAAI,EAAE,GAC1CW,sBAAsB,CAACL,OAAO,CAAC,GAC/BM,2BAA2B,CAACN,OAAO,CAAC;;EAExC;EACAO,aAAa,CAACH,UAAU,CAAC;EAEzB,OAAO;IACLI,cAAc,EAAE1B,cAAc,CAACsB,UAAU,CAAC5B,KAAK,CAAC;IAChDc,UAAU,EAAEc,UAAU,CAACd,UAAU;IACjCN,OAAO,EAAE;MACPyB,iBAAiB,EAAET,OAAO,CAACS,iBAAiB,IAAI,CAAC;MACjDC,kBAAkB,EAAEV,OAAO,CAACU,kBAAkB,IAAI,CAAC;MACnDxB,eAAe,EAAEc,OAAO,CAACd,eAAe,IAAI,CAAC;MAC7CyB,cAAc,EAAEX,OAAO,CAACW,cAAc,IAAI;IAC5C,CAAC;IACDC,KAAK,EAAE;MACLC,IAAI,EAAEZ,cAAc,CAACP,MAAM,IAAI,EAAE,GAAG,kBAAkB,GAAG,WAAW;MACpEoB,QAAQ,EAAEV,UAAU,CAACU,QAAQ;MAC7BC,UAAU,EAAEd,cAAc,CAACP;IAC7B;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,SAASQ,iBAAiBA,CAAA,EAAG;EAC3B,IAAI;IACF,IAAMc,IAAI,GAAGC,YAAY,CAACC,OAAO,CAAC,oBAAoB,CAAC;IACvD,OAAOF,IAAI,GAAGG,IAAI,CAACC,KAAK,CAACJ,IAAI,CAAC,GAAG,EAAE;EACrC,CAAC,CAAC,OAAOK,KAAK,EAAE;IACdrD,OAAO,CAACqD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACtD,OAAO,EAAE;EACX;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAAA,EAAG;EAC5B,IAAI;IACF,IAAMvD,OAAO,GAAGkD,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC;IACvD,OAAOnD,OAAO,GAAGoD,IAAI,CAACC,KAAK,CAACrD,OAAO,CAAC,GAAG,IAAI;EAC7C,CAAC,CAAC,OAAOsD,KAAK,EAAE;IACdrD,OAAO,CAACqD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvD,OAAO,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASlB,UAAUA,CAACa,IAAI,EAAE;EACxB;EACA,IAAMO,QAAQ,GAAGP,IAAI,CAACQ,GAAG,CAAC,UAAAC,KAAK;IAAA,OAAI,CACjCA,KAAK,CAACzB,OAAO,CAACS,iBAAiB,EAC/BgB,KAAK,CAACzB,OAAO,CAACU,kBAAkB,EAChCe,KAAK,CAACzB,OAAO,CAACd,eAAe,EAC7BuC,KAAK,CAACzB,OAAO,CAACW,cAAc,CAC7B;EAAA,EAAC;EAEF,IAAMe,MAAM,GAAGV,IAAI,CAACQ,GAAG,CAAC,UAAAC,KAAK;IAAA,OAAIA,KAAK,CAACE,WAAW;EAAA,EAAC;;EAEnD;EACA,IAAMf,KAAK,GAAGgB,qBAAqB,CAACL,QAAQ,EAAEG,MAAM,CAAC;;EAErD;EACAT,YAAY,CAACY,OAAO,CAAC,iBAAiB,EAAEV,IAAI,CAACW,SAAS,CAAClB,KAAK,CAAC,CAAC;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASP,sBAAsBA,CAACL,OAAO,EAAE;EACvC,IAAI;IACF,IAAMY,KAAK,GAAGO,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,CAAC;IACjE,IAAI,CAACN,KAAK,EAAE,OAAON,2BAA2B,CAACN,OAAO,CAAC;;IAEvD;IACA,IAAMuB,QAAQ,GAAG,CACfvB,OAAO,CAACS,iBAAiB,EACzBT,OAAO,CAACU,kBAAkB,EAC1BV,OAAO,CAACd,eAAe,EACvBc,OAAO,CAACW,cAAc,CACvB;;IAED;IACA,IAAMH,cAAc,GAAGuB,uBAAuB,CAACR,QAAQ,EAAEX,KAAK,CAAC;IAC/D,IAAMtB,UAAU,GAAG0C,wBAAwB,CAACpB,KAAK,EAAEZ,OAAO,CAAC;IAE3D,OAAO;MACLxB,KAAK,EAAEgC,cAAc;MACrBlB,UAAU,EAAVA,UAAU;MACVwB,QAAQ,EAAEF,KAAK,CAACE,QAAQ;MACxBmB,MAAM,EAAE;IACV,CAAC;EACH,CAAC,CAAC,OAAOZ,KAAK,EAAE;IACdrD,OAAO,CAACqD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;IAC7C,OAAOf,2BAA2B,CAACN,OAAO,CAAC;EAC7C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASM,2BAA2BA,CAACN,OAAO,EAAE;EAC5C;EACAhC,OAAO,CAACC,GAAG,CAAC,uCAAuC,EAAE+B,OAAO,CAAC;;EAE7D;EACA,IAAMkC,YAAY,GAAG;IACnBzB,iBAAiB,EAAEX,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEG,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEG,OAAO,CAACS,iBAAiB,IAAI,EAAE,CAAC,CAAC;IAC9EC,kBAAkB,EAAEZ,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEG,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEG,OAAO,CAACU,kBAAkB,IAAI,EAAE,CAAC,CAAC;IAChFxB,eAAe,EAAEY,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEG,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEG,OAAO,CAACd,eAAe,IAAI,EAAE,CAAC,CAAC;IAC1EyB,cAAc,EAAEb,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEG,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEG,OAAO,CAACW,cAAc,IAAI,EAAE,CAAC;EACzE,CAAC;;EAED;EACA3C,OAAO,CAACC,GAAG,CAAC,2CAA2C,EAAEiE,YAAY,CAAC;;EAEtE;EACA,IAAMC,YAAY,GAAGC,qBAAqB,CAACF,YAAY,CAAC;;EAExD;EACA,IAAMG,kBAAkB,GAAGC,2BAA2B,CAACJ,YAAY,CAAC;;EAEpE;EACA,IAAMK,cAAc,GAAGC,uBAAuB,CAACN,YAAY,CAACvB,cAAc,CAAC;;EAE3E;EACA,IAAM8B,SAAS,GAAG3C,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEwC,YAAY,GAAGE,kBAAkB,GAAGE,cAAc,CAAC;;EAEnF;EACA,IAAMjD,UAAU,GAAGoD,mBAAmB,CAACR,YAAY,CAAC;;EAEpD;EACA,IAAMS,aAAa,GAAGF,SAAS,IAAInD,UAAU,GAAG,GAAG,CAAC;;EAEpD;EACA,IAAMT,UAAU,GAAGC,cAAc,CAAC6D,aAAa,CAAC;;EAEhD;EACA3E,OAAO,CAACC,GAAG,CAAC,iCAAiC,EAAE;IAC7CkE,YAAY,EAAZA,YAAY;IACZE,kBAAkB,EAAlBA,kBAAkB;IAClBE,cAAc,EAAdA,cAAc;IACdE,SAAS,EAATA,SAAS;IACTnD,UAAU,EAAVA,UAAU;IACVqD,aAAa,EAAbA,aAAa;IACb9D,UAAU,EAAVA;EACF,CAAC,CAAC;EAEF,OAAO;IACLL,KAAK,EAAEK,UAAU;IACjBS,UAAU,EAAVA,UAAU;IACVwB,QAAQ,EAAE,GAAG;IACbmB,MAAM,EAAE;EACV,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASG,qBAAqBA,CAACpC,OAAO,EAAE;EACtC;EACA,IAAM4C,cAAc,GAAG,GAAG;EAC1B,IAAMC,gBAAgB,GAAG,GAAG;;EAE5B;EACA,IAAMC,eAAe,GAAG,GAAG,GAAI9C,OAAO,CAACS,iBAAiB,GAAG,GAAI;;EAE/D;EACA,IAAMsC,aAAa,GAAG/C,OAAO,CAACd,eAAe;EAE7C,OAAQ4D,eAAe,GAAGD,gBAAgB,GAAKE,aAAa,GAAGH,cAAe;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASN,2BAA2BA,CAACtC,OAAO,EAAE;EAC5C;EACA,IAAMgD,gBAAgB,GAAG,CAAC,GAAG,GAAGhD,OAAO,CAACU,kBAAkB,IAAI,GAAG;;EAEjE;EACA,IAAMuC,YAAY,GAAGjD,OAAO,CAACU,kBAAkB,GAAG,EAAE,IAAIV,OAAO,CAACU,kBAAkB,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC;EAE/F,OAAOsC,gBAAgB,GAAGC,YAAY;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAST,uBAAuBA,CAACpD,SAAS,EAAE;EAC1C;EACA;EACA,OAAOA,SAAS,GAAG,EAAE,GAAG,EAAE,GAAGA,SAAS,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASsD,mBAAmBA,CAAC1C,OAAO,EAAE;EACpC;EACA,IAAMkD,cAAc,GAAG9E,MAAM,CAAC+E,MAAM,CAACnD,OAAO,CAAC,CAACR,MAAM,CAAC,UAAA4D,CAAC;IAAA,OAAIA,CAAC,KAAK3D,SAAS,IAAI2D,CAAC,KAAK,IAAI;EAAA,EAAC,CAAC1D,MAAM;EAC/F,IAAM2D,YAAY,GAAGjF,MAAM,CAACC,IAAI,CAAC2B,OAAO,CAAC,CAACN,MAAM;;EAEhD;EACA,IAAIJ,UAAU,GAAI4D,cAAc,GAAGG,YAAY,GAAI,GAAG;;EAEtD;EACA,IAAMC,oBAAoB,GAAGtD,OAAO,CAACU,kBAAkB,GAAG,EAAE,IAAIV,OAAO,CAACU,kBAAkB,GAAG,EAAE;EAC/F,IAAM6C,oBAAoB,GAAGvD,OAAO,CAACS,iBAAiB,GAAG,EAAE,IAAIT,OAAO,CAACS,iBAAiB,GAAG,EAAE;EAE7F,IAAI6C,oBAAoB,EAAEhE,UAAU,IAAI,GAAG;EAC3C,IAAIiE,oBAAoB,EAAEjE,UAAU,IAAI,GAAG;EAE3C,OAAOQ,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEG,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEP,UAAU,CAAC,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA,SAASiB,aAAaA,CAACH,UAAU,EAAE;EACjC,IAAMoD,cAAc,GAAGlC,kBAAkB,CAAC,CAAC,IAAI;IAC7Cb,iBAAiB,EAAE,GAAG;IACtBC,kBAAkB,EAAE,GAAG;IACvBxB,eAAe,EAAE,GAAG;IACpByB,cAAc,EAAE;EAClB,CAAC;;EAED;EACA,IAAIP,UAAU,CAACU,QAAQ,GAAG,GAAG,EAAE;IAC7B,IAAM2C,eAAe,GAAG,CAAC,CAAC;IAC1BrF,MAAM,CAACC,IAAI,CAACmF,cAAc,CAAC,CAAClF,OAAO,CAAC,UAAAC,GAAG,EAAI;MACzC,IAAMmF,WAAW,GAAGC,oBAAoB,CACtCzD,iBAAiB,CAAC,CAAC,EACnB3B,GAAG,EACH,aACF,CAAC;MACDkF,eAAe,CAAClF,GAAG,CAAC,GAAGqF,eAAe,CAACJ,cAAc,CAACjF,GAAG,CAAC,IAAI,CAAC,GAAGmF,WAAW,CAAC,CAAC;IACjF,CAAC,CAAC;;IAEF;IACA,IAAMvF,WAAW,GAAGC,MAAM,CAAC+E,MAAM,CAACM,eAAe,CAAC,CAACI,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;MAAA,OAAKD,CAAC,GAAGC,CAAC;IAAA,GAAE,CAAC,CAAC;IAC7E3F,MAAM,CAACC,IAAI,CAACoF,eAAe,CAAC,CAACnF,OAAO,CAAC,UAAAC,GAAG,EAAI;MAC1CkF,eAAe,CAAClF,GAAG,CAAC,IAAIJ,WAAW;IACrC,CAAC,CAAC;;IAEF;IACA8C,YAAY,CAACY,OAAO,CAAC,iBAAiB,EAAEV,IAAI,CAACW,SAAS,CAAC2B,eAAe,CAAC,CAAC;EAC1E;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7B,qBAAqBA,CAACL,QAAQ,EAAEG,MAAM,EAAE;EAC/C,IAAMsC,CAAC,GAAGzC,QAAQ,CAAC7B,MAAM;EACzB,IAAMuE,WAAW,GAAG1C,QAAQ,CAAC,CAAC,CAAC,CAAC7B,MAAM;;EAEtC;EACA,IAAM3B,OAAO,GAAG,IAAImG,KAAK,CAACD,WAAW,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC;EAC9C,IAAMC,YAAY,GAAG,IAAI;EACzB,IAAMC,UAAU,GAAG,GAAG;;EAEtB;EACA,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGD,UAAU,EAAEC,IAAI,EAAE,EAAE;IAC5C,IAAMC,YAAW,GAAGhD,QAAQ,CAACC,GAAG,CAAC,UAAAgD,OAAO;MAAA,OACtCA,OAAO,CAACX,MAAM,CAAC,UAACY,GAAG,EAAEC,KAAK,EAAEC,CAAC;QAAA,OAAKF,GAAG,GAAGC,KAAK,GAAG3G,OAAO,CAAC4G,CAAC,CAAC;MAAA,GAAE,CAAC,CAAC;IAAA,CAChE,CAAC;;IAED;IAAA,IAAAC,KAAA,YAAAA,MAAAC,CAAA,EACsC;MACpC,IAAMC,QAAQ,GAAGP,YAAW,CAACV,MAAM,CAAC,UAACY,GAAG,EAAEM,IAAI,EAAEJ,CAAC;QAAA,OAC/CF,GAAG,GAAG,CAACM,IAAI,GAAGrD,MAAM,CAACiD,CAAC,CAAC,IAAIpD,QAAQ,CAACoD,CAAC,CAAC,CAACE,CAAC,CAAC;MAAA,GAAE,CAC7C,CAAC,GAAGb,CAAC;MAELjG,OAAO,CAAC8G,CAAC,CAAC,IAAIT,YAAY,GAAGU,QAAQ;IACvC,CAAC;IAND,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,WAAW,EAAEY,CAAC,EAAE;MAAAD,KAAA,CAAAC,CAAA;IAAA;EAOtC;;EAEA;EACA,IAAMN,WAAW,GAAGhD,QAAQ,CAACC,GAAG,CAAC,UAAAgD,OAAO;IAAA,OACtCA,OAAO,CAACX,MAAM,CAAC,UAACY,GAAG,EAAEC,KAAK,EAAEC,CAAC;MAAA,OAAKF,GAAG,GAAGC,KAAK,GAAG3G,OAAO,CAAC4G,CAAC,CAAC;IAAA,GAAE,CAAC,CAAC;EAAA,CAChE,CAAC;EAED,IAAM7D,QAAQ,GAAG,CAAC,GAAGkE,aAAa,CAACT,WAAW,EAAE7C,MAAM,CAAC,GAAG,GAAG;EAE7D,OAAO;IAAE3D,OAAO,EAAPA,OAAO;IAAE+C,QAAQ,EAARA;EAAS,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,uBAAuBA,CAACR,QAAQ,EAAEX,KAAK,EAAE;EAChD,OAAOW,QAAQ,CAACsC,MAAM,CAAC,UAACY,GAAG,EAAEC,KAAK,EAAEC,CAAC;IAAA,OAAKF,GAAG,GAAGC,KAAK,GAAG9D,KAAK,CAAC7C,OAAO,CAAC4G,CAAC,CAAC;EAAA,GAAE,CAAC,CAAC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,aAAaA,CAACT,WAAW,EAAEU,OAAO,EAAE;EAC3C,IAAMC,aAAa,GAAGX,WAAW,CAAC/C,GAAG,CAAC,UAACuD,IAAI,EAAEJ,CAAC;IAAA,OAC5C7E,IAAI,CAACqF,GAAG,CAACJ,IAAI,GAAGE,OAAO,CAACN,CAAC,CAAC,EAAE,CAAC,CAAC;EAAA,CAChC,CAAC;EACD,OAAO7E,IAAI,CAACsF,IAAI,CAACF,aAAa,CAACrB,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAA,OAAKD,CAAC,GAAGC,CAAC;EAAA,GAAE,CAAC,CAAC,GAAGQ,WAAW,CAAC7E,MAAM,CAAC;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiE,oBAAoBA,CAAC3C,IAAI,EAAEqE,SAAS,EAAEC,SAAS,EAAE;EACxD,IAAMC,OAAO,GAAGvE,IAAI,CAACQ,GAAG,CAAC,UAAAC,KAAK;IAAA,OAC5B4D,SAAS,CAACG,QAAQ,CAAC,GAAG,CAAC,GACnB/D,KAAK,CAACzB,OAAO,CAACqF,SAAS,CAACI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GACtChE,KAAK,CAAC4D,SAAS,CAAC;EAAA,CACtB,CAAC;EAED,IAAMK,OAAO,GAAG1E,IAAI,CAACQ,GAAG,CAAC,UAAAC,KAAK;IAAA,OAAIA,KAAK,CAAC6D,SAAS,CAAC;EAAA,EAAC;EAEnD,IAAMK,KAAK,GAAGJ,OAAO,CAAC1B,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAA,OAAKD,CAAC,GAAGC,CAAC;EAAA,GAAE,CAAC,CAAC,GAAGwB,OAAO,CAAC7F,MAAM;EACjE,IAAMkG,KAAK,GAAGF,OAAO,CAAC7B,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAA,OAAKD,CAAC,GAAGC,CAAC;EAAA,GAAE,CAAC,CAAC,GAAG2B,OAAO,CAAChG,MAAM;EAEjE,IAAMmG,SAAS,GAAGN,OAAO,CAAC1B,MAAM,CAAC,UAACY,GAAG,EAAEqB,GAAG;IAAA,OAAKrB,GAAG,GAAG3E,IAAI,CAACqF,GAAG,CAACW,GAAG,GAAGH,KAAK,EAAE,CAAC,CAAC;EAAA,GAAE,CAAC,CAAC;EACjF,IAAMI,SAAS,GAAGL,OAAO,CAAC7B,MAAM,CAAC,UAACY,GAAG,EAAEqB,GAAG;IAAA,OAAKrB,GAAG,GAAG3E,IAAI,CAACqF,GAAG,CAACW,GAAG,GAAGF,KAAK,EAAE,CAAC,CAAC;EAAA,GAAE,CAAC,CAAC;EAEjF,IAAMI,UAAU,GAAGT,OAAO,CAAC1B,MAAM,CAAC,UAACY,GAAG,EAAEqB,GAAG,EAAEnB,CAAC;IAAA,OAC5CF,GAAG,GAAG,CAACqB,GAAG,GAAGH,KAAK,KAAKD,OAAO,CAACf,CAAC,CAAC,GAAGiB,KAAK,CAAC;EAAA,GAAE,CAC9C,CAAC;EAED,OAAOI,UAAU,GAAGlG,IAAI,CAACsF,IAAI,CAACS,SAAS,GAAGE,SAAS,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASnC,eAAeA,CAAClF,MAAM,EAAE;EAC/B,OAAOoB,IAAI,CAACD,GAAG,CAAC,GAAG,EAAEC,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEjB,MAAM,CAAC,CAAC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsD,wBAAwBA,CAACpB,KAAK,EAAEZ,OAAO,EAAE;EAChD;EACA,IAAIV,UAAU,GAAGsB,KAAK,CAACE,QAAQ,GAAG,GAAG;;EAErC;EACA,IAAMmF,YAAY,GAAG7H,MAAM,CAAC+E,MAAM,CAACnD,OAAO,CAAC,CAACR,MAAM,CAAC,UAAA4D,CAAC;IAAA,OAAIA,CAAC,KAAK3D,SAAS;EAAA,EAAC,CAACC,MAAM,GAAG,CAAC;EACnFJ,UAAU,IAAI2G,YAAY;;EAE1B;EACA,IAAMC,OAAO,GAAG9H,MAAM,CAAC+E,MAAM,CAACnD,OAAO,CAAC,CAACmG,KAAK,CAAC,UAAA/C,CAAC;IAAA,OAAIA,CAAC,IAAI,CAAC,IAAIA,CAAC,IAAI,GAAG;EAAA,EAAC;EACrE,IAAI,CAAC8C,OAAO,EAAE5G,UAAU,IAAI,GAAG;EAE/B,OAAOQ,IAAI,CAACH,GAAG,CAAC,GAAG,EAAEL,UAAU,CAAC;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
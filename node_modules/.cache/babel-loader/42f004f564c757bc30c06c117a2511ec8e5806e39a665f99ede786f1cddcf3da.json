{"ast":null,"code":"import _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * Question Generation Module\r\n */\n\nimport { findExplanationFromContent } from '../explanation-generation';\n\n/**\r\n * Process quiz response from API and convert to question objects\r\n * @param {string} response - Raw API response text\r\n * @param {string} content - Original content for explanations\r\n * @returns {Object} Processed questions\r\n */\nexport function processQuizResponse(response, content) {\n  var questions = [];\n  var currentQuestion = null;\n\n  // Split by double newlines to separate questions\n  var sections = response.split(/\\n\\s*\\n/);\n  var _iterator = _createForOfIteratorHelper(sections),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var section = _step.value;\n      var lines = section.split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i].trim();\n        if (!line) continue;\n\n        // Check for question start\n        if (line.startsWith('Question:') || line.startsWith('True/False:')) {\n          if (currentQuestion) {\n            questions.push(currentQuestion);\n          }\n          var isMultipleChoice = line.startsWith('Question:');\n          currentQuestion = {\n            text: line.replace(/^(Question:|True\\/False:)/i, '').trim().replace(/\\*+/g, ''),\n            type: isMultipleChoice ? 'multiple-choice' : 'true-false',\n            options: isMultipleChoice ? {} : {\n              'true': 'True',\n              'false': 'False'\n            },\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n          continue;\n        }\n        if (!currentQuestion) continue;\n\n        // Handle options for multiple choice\n        if (currentQuestion.type === 'multiple-choice') {\n          var optionMatch = line.match(/^([A-D])[).]\\s*(.*)/i);\n          if (optionMatch) {\n            var letter = optionMatch[1].toUpperCase();\n            var option = optionMatch[2].trim();\n            // Remove any asterisk from the option text\n            option = option.replace(/\\*$/, '').trim();\n            currentQuestion.options[letter] = option;\n          }\n\n          // Check for answer line\n          if (line.startsWith('Answer:')) {\n            var answerMatch = line.match(/Answer:\\s*([A-D])\\*/i);\n            if (answerMatch) {\n              currentQuestion.correctAnswer = answerMatch[1].toUpperCase();\n            }\n          }\n        }\n\n        // Handle true/false answer\n        if (currentQuestion.type === 'true-false' && line.startsWith('Answer:')) {\n          var answer = line.toLowerCase();\n          if (answer.includes('true*')) {\n            currentQuestion.correctAnswer = 'true';\n          } else if (answer.includes('false*')) {\n            currentQuestion.correctAnswer = 'false';\n          }\n        }\n\n        // Handle difficulty\n        if (line.startsWith('Difficulty:')) {\n          var difficulty = line.substring(11).trim().toLowerCase();\n          if (['easy', 'medium', 'hard'].includes(difficulty)) {\n            currentQuestion.difficulty = difficulty;\n          }\n        }\n      }\n    }\n\n    // Add the last question if exists\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (currentQuestion) {\n    questions.push(currentQuestion);\n  }\n\n  // Validate questions\n  var validQuestions = questions.filter(function (q) {\n    // Basic validation\n    if (!q.text || !q.type) return false;\n\n    // Validate multiple choice questions\n    if (q.type === 'multiple-choice') {\n      var hasEnoughOptions = Object.keys(q.options).length >= 2;\n      var hasCorrectAnswer = !!q.correctAnswer && !!q.options[q.correctAnswer];\n      return hasEnoughOptions && hasCorrectAnswer;\n    }\n\n    // Validate true/false questions\n    if (q.type === 'true-false') {\n      return q.correctAnswer === 'true' || q.correctAnswer === 'false';\n    }\n    return false;\n  });\n  if (validQuestions.length === 0) {\n    throw new Error('No valid questions could be generated from the content.');\n  }\n\n  // Add explanations from content\n  validQuestions.forEach(function (q) {\n    return findExplanationFromContent(q, content);\n  });\n  return {\n    questions: validQuestions\n  };\n}\n\n/**\r\n * Check if two questions are too similar\r\n * @param {Object} q1 - First question\r\n * @param {Object} q2 - Second question\r\n * @returns {boolean} True if questions are similar\r\n */\nexport function isSimilarQuestion(q1, q2) {\n  // Convert both questions to lowercase and remove punctuation\n  var normalize = function normalize(text) {\n    return text.toLowerCase().replace(/[^\\w\\s]/g, '');\n  };\n  var q1Text = normalize(q1.text);\n  var q2Text = normalize(q2.text);\n\n  // If the questions are exactly the same, they're similar\n  if (q1Text === q2Text) return true;\n\n  // If they're different types (MC vs T/F), they're not similar\n  if (q1.type !== q2.type) return false;\n\n  // For multiple choice questions, check if the options are too similar\n  if (q1.type === 'multiple-choice' && q2.type === 'multiple-choice') {\n    var q1Options = Object.values(q1.options).map(normalize);\n    var q2Options = Object.values(q2.options).map(normalize);\n    var commonOptions = q1Options.filter(function (opt) {\n      return q2Options.includes(opt);\n    });\n    if (commonOptions.length >= 3) return true; // If 3 or more options are the same, consider them similar\n  }\n\n  // Check for word overlap ratio\n  var q1Words = new Set(q1Text.split(/\\s+/));\n  var q2Words = new Set(q2Text.split(/\\s+/));\n  var commonWords = new Set(_toConsumableArray(q1Words).filter(function (x) {\n    return q2Words.has(x);\n  }));\n  var overlapRatio = commonWords.size / Math.min(q1Words.size, q2Words.size);\n  return overlapRatio > 0.7; // If more than 70% of words overlap, consider them similar\n}","map":{"version":3,"names":["findExplanationFromContent","processQuizResponse","response","content","questions","currentQuestion","sections","split","_iterator","_createForOfIteratorHelper","_step","s","n","done","section","value","lines","i","length","line","trim","startsWith","push","isMultipleChoice","text","replace","type","options","correctAnswer","explanation","difficulty","optionMatch","match","letter","toUpperCase","option","answerMatch","answer","toLowerCase","includes","substring","err","e","f","validQuestions","filter","q","hasEnoughOptions","Object","keys","hasCorrectAnswer","Error","forEach","isSimilarQuestion","q1","q2","normalize","q1Text","q2Text","q1Options","values","map","q2Options","commonOptions","opt","q1Words","Set","q2Words","commonWords","_toConsumableArray","x","has","overlapRatio","size","Math","min"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/question-generation/index.js"],"sourcesContent":["/**\r\n * Question Generation Module\r\n */\r\n\r\nimport { findExplanationFromContent } from '../explanation-generation';\r\n\r\n/**\r\n * Process quiz response from API and convert to question objects\r\n * @param {string} response - Raw API response text\r\n * @param {string} content - Original content for explanations\r\n * @returns {Object} Processed questions\r\n */\r\nexport function processQuizResponse(response, content) {\r\n  const questions = [];\r\n  let currentQuestion = null;\r\n  \r\n  // Split by double newlines to separate questions\r\n  const sections = response.split(/\\n\\s*\\n/);\r\n  \r\n  for (const section of sections) {\r\n    const lines = section.split('\\n');\r\n    \r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      if (!line) continue;\r\n\r\n      // Check for question start\r\n      if (line.startsWith('Question:') || line.startsWith('True/False:')) {\r\n        if (currentQuestion) {\r\n          questions.push(currentQuestion);\r\n        }\r\n\r\n        const isMultipleChoice = line.startsWith('Question:');\r\n        currentQuestion = {\r\n          text: line.replace(/^(Question:|True\\/False:)/i, '').trim().replace(/\\*+/g, ''),\r\n          type: isMultipleChoice ? 'multiple-choice' : 'true-false',\r\n          options: isMultipleChoice ? {} : { 'true': 'True', 'false': 'False' },\r\n          correctAnswer: '',\r\n          explanation: '',\r\n          difficulty: 'medium'\r\n        };\r\n        continue;\r\n      }\r\n\r\n      if (!currentQuestion) continue;\r\n\r\n      // Handle options for multiple choice\r\n      if (currentQuestion.type === 'multiple-choice') {\r\n        const optionMatch = line.match(/^([A-D])[).]\\s*(.*)/i);\r\n        if (optionMatch) {\r\n          const letter = optionMatch[1].toUpperCase();\r\n          let option = optionMatch[2].trim();\r\n          // Remove any asterisk from the option text\r\n          option = option.replace(/\\*$/, '').trim();\r\n          currentQuestion.options[letter] = option;\r\n        }\r\n        \r\n        // Check for answer line\r\n        if (line.startsWith('Answer:')) {\r\n          const answerMatch = line.match(/Answer:\\s*([A-D])\\*/i);\r\n          if (answerMatch) {\r\n            currentQuestion.correctAnswer = answerMatch[1].toUpperCase();\r\n          }\r\n        }\r\n      }\r\n\r\n      // Handle true/false answer\r\n      if (currentQuestion.type === 'true-false' && line.startsWith('Answer:')) {\r\n        const answer = line.toLowerCase();\r\n        if (answer.includes('true*')) {\r\n          currentQuestion.correctAnswer = 'true';\r\n        } else if (answer.includes('false*')) {\r\n          currentQuestion.correctAnswer = 'false';\r\n        }\r\n      }\r\n\r\n      // Handle difficulty\r\n      if (line.startsWith('Difficulty:')) {\r\n        const difficulty = line.substring(11).trim().toLowerCase();\r\n        if (['easy', 'medium', 'hard'].includes(difficulty)) {\r\n          currentQuestion.difficulty = difficulty;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add the last question if exists\r\n  if (currentQuestion) {\r\n    questions.push(currentQuestion);\r\n  }\r\n\r\n  // Validate questions\r\n  const validQuestions = questions.filter(q => {\r\n    // Basic validation\r\n    if (!q.text || !q.type) return false;\r\n\r\n    // Validate multiple choice questions\r\n    if (q.type === 'multiple-choice') {\r\n      const hasEnoughOptions = Object.keys(q.options).length >= 2;\r\n      const hasCorrectAnswer = !!q.correctAnswer && !!q.options[q.correctAnswer];\r\n      return hasEnoughOptions && hasCorrectAnswer;\r\n    }\r\n\r\n    // Validate true/false questions\r\n    if (q.type === 'true-false') {\r\n      return q.correctAnswer === 'true' || q.correctAnswer === 'false';\r\n    }\r\n\r\n    return false;\r\n  });\r\n\r\n  if (validQuestions.length === 0) {\r\n    throw new Error('No valid questions could be generated from the content.');\r\n  }\r\n\r\n  // Add explanations from content\r\n  validQuestions.forEach(q => findExplanationFromContent(q, content));\r\n\r\n  return { questions: validQuestions };\r\n}\r\n\r\n/**\r\n * Check if two questions are too similar\r\n * @param {Object} q1 - First question\r\n * @param {Object} q2 - Second question\r\n * @returns {boolean} True if questions are similar\r\n */\r\nexport function isSimilarQuestion(q1, q2) {\r\n  // Convert both questions to lowercase and remove punctuation\r\n  const normalize = text => text.toLowerCase().replace(/[^\\w\\s]/g, '');\r\n  const q1Text = normalize(q1.text);\r\n  const q2Text = normalize(q2.text);\r\n\r\n  // If the questions are exactly the same, they're similar\r\n  if (q1Text === q2Text) return true;\r\n\r\n  // If they're different types (MC vs T/F), they're not similar\r\n  if (q1.type !== q2.type) return false;\r\n\r\n  // For multiple choice questions, check if the options are too similar\r\n  if (q1.type === 'multiple-choice' && q2.type === 'multiple-choice') {\r\n    const q1Options = Object.values(q1.options).map(normalize);\r\n    const q2Options = Object.values(q2.options).map(normalize);\r\n    const commonOptions = q1Options.filter(opt => q2Options.includes(opt));\r\n    if (commonOptions.length >= 3) return true; // If 3 or more options are the same, consider them similar\r\n  }\r\n\r\n  // Check for word overlap ratio\r\n  const q1Words = new Set(q1Text.split(/\\s+/));\r\n  const q2Words = new Set(q2Text.split(/\\s+/));\r\n  const commonWords = new Set([...q1Words].filter(x => q2Words.has(x)));\r\n  const overlapRatio = commonWords.size / Math.min(q1Words.size, q2Words.size);\r\n\r\n  return overlapRatio > 0.7; // If more than 70% of words overlap, consider them similar\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
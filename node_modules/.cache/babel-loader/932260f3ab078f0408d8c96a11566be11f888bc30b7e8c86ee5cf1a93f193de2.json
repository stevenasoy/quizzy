{"ast":null,"code":"import _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * Explanation Generation Module\r\n */\n\n/**\r\n * Find and generate explanation for a question from content\r\n * @param {Object} question - Question object\r\n * @param {string} content - Source content\r\n */\nexport function findExplanationFromContent(question, content) {\n  // Split content into smaller chunks (paragraphs and sentences)\n  var paragraphs = content.split(/\\n\\s*\\n/).map(function (p) {\n    return p.trim();\n  }).filter(function (p) {\n    return p.length > 0;\n  });\n  var sentences = content.split(/(?<=[.!?])\\s+/).map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s.length > 0;\n  });\n\n  // Extract key terms from question and answer\n  var questionTerms = new Set(question.text.toLowerCase().replace(/[.,?!]/g, '').split(' ').filter(function (word) {\n    return word.length > 3 && !['what', 'when', 'where', 'why', 'how', 'which', 'who', 'does', 'can', 'will', 'should', 'would', 'could', 'the', 'and', 'that'].includes(word);\n  }));\n  var answerTerms = new Set();\n  if (question.type === 'multiple-choice') {\n    // Add terms from correct answer\n    question.options[question.correctAnswer].toLowerCase().replace(/[.,?!]/g, '').split(' ').filter(function (word) {\n      return word.length > 3;\n    }).forEach(function (term) {\n      return answerTerms.add(term);\n    });\n\n    // Add key terms from incorrect options to help identify contrasting explanations\n    Object.entries(question.options).filter(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n        key = _ref2[0];\n      return key !== question.correctAnswer;\n    }).forEach(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        option = _ref4[1];\n      option.toLowerCase().replace(/[.,?!]/g, '').split(' ').filter(function (word) {\n        return word.length > 3;\n      }).forEach(function (term) {\n        return answerTerms.add(term);\n      });\n    });\n  }\n\n  // Score each paragraph\n  var scoredParagraphs = paragraphs.map(function (paragraph) {\n    var normalizedParagraph = paragraph.toLowerCase();\n    var score = 0;\n    var termMatches = 0;\n\n    // Check for exact phrase matches\n    if (normalizedParagraph.includes(question.text.toLowerCase())) {\n      score += 25;\n    }\n\n    // Check for answer phrase matches\n    if (question.type === 'multiple-choice') {\n      if (normalizedParagraph.includes(question.options[question.correctAnswer].toLowerCase())) {\n        score += 20;\n      }\n    }\n\n    // Score based on term density and relevance\n    questionTerms.forEach(function (term) {\n      if (normalizedParagraph.includes(term)) {\n        score += 5;\n        termMatches++;\n      }\n    });\n    answerTerms.forEach(function (term) {\n      if (normalizedParagraph.includes(term)) {\n        score += 3;\n        termMatches++;\n      }\n    });\n\n    // Bonus for high term density\n    var density = termMatches / paragraph.split(' ').length;\n    score += density * 20;\n\n    // Penalty for very long paragraphs\n    if (paragraph.length > 300) {\n      score *= 0.8;\n    }\n    return {\n      text: paragraph,\n      score: score,\n      termMatches: termMatches\n    };\n  }).filter(function (p) {\n    return p.score > 10;\n  }) // Only keep paragraphs with meaningful scores\n  .sort(function (a, b) {\n    return b.score - a.score;\n  });\n\n  // Score individual sentences for potential additional context\n  var scoredSentences = sentences.map(function (sentence) {\n    var normalizedSentence = sentence.toLowerCase();\n    var score = 0;\n    var termMatches = 0;\n    questionTerms.forEach(function (term) {\n      if (normalizedSentence.includes(term)) {\n        score += 3;\n        termMatches++;\n      }\n    });\n    answerTerms.forEach(function (term) {\n      if (normalizedSentence.includes(term)) {\n        score += 2;\n        termMatches++;\n      }\n    });\n\n    // Bonus for high term density in short sentences\n    var density = termMatches / sentence.split(' ').length;\n    score += density * 15;\n    return {\n      text: sentence,\n      score: score,\n      termMatches: termMatches\n    };\n  }).filter(function (s) {\n    return s.score > 5;\n  }).sort(function (a, b) {\n    return b.score - a.score;\n  });\n\n  // Construct the explanation\n  var explanation = '';\n  if (scoredParagraphs.length > 0) {\n    // Use the highest scoring paragraph, but trim it if it's too long\n    var mainExplanation = scoredParagraphs[0].text;\n    if (mainExplanation.length > 300) {\n      // Find the most relevant segment within the paragraph\n      var segments = mainExplanation.split(/(?<=[.!?])\\s+/);\n      var relevantSegments = segments.filter(function (segment) {\n        var normalizedSegment = segment.toLowerCase();\n        return [].concat(_toConsumableArray(questionTerms), _toConsumableArray(answerTerms)).some(function (term) {\n          return normalizedSegment.includes(term);\n        });\n      });\n      mainExplanation = relevantSegments.slice(0, 2).join(' ');\n    }\n    explanation = mainExplanation;\n\n    // Add a highly relevant sentence if it provides additional context\n    if (scoredSentences.length > 0 && scoredSentences[0].score > 10 && !explanation.toLowerCase().includes(scoredSentences[0].text.toLowerCase())) {\n      explanation += ' ' + scoredSentences[0].text;\n    }\n  } else if (scoredSentences.length > 0) {\n    // Use up to two most relevant sentences if no good paragraph was found\n    explanation = scoredSentences.slice(0, 2).map(function (s) {\n      return s.text;\n    }).join(' ');\n  }\n\n  // If no good explanation was found, use a fallback\n  if (!explanation || explanation.length < 20) {\n    if (question.type === 'multiple-choice') {\n      var correctOption = question.options[question.correctAnswer];\n      explanation = \"The correct answer is \\\"\".concat(correctOption, \"\\\". This can be determined from the context of the material.\");\n    } else {\n      explanation = \"This statement is \".concat(question.correctAnswer, \" based on the information provided in the material.\");\n    }\n  } else {\n    // Add a concluding sentence for multiple choice questions\n    if (question.type === 'multiple-choice') {\n      var _correctOption = question.options[question.correctAnswer];\n      if (!explanation.includes(_correctOption)) {\n        explanation += \" Therefore, \\\"\".concat(_correctOption, \"\\\" is the correct answer.\");\n      }\n    }\n  }\n  question.explanation = explanation;\n}","map":{"version":3,"names":["findExplanationFromContent","question","content","paragraphs","split","map","p","trim","filter","length","sentences","s","questionTerms","Set","text","toLowerCase","replace","word","includes","answerTerms","type","options","correctAnswer","forEach","term","add","Object","entries","_ref","_ref2","_slicedToArray","key","_ref3","_ref4","option","scoredParagraphs","paragraph","normalizedParagraph","score","termMatches","density","sort","a","b","scoredSentences","sentence","normalizedSentence","explanation","mainExplanation","segments","relevantSegments","segment","normalizedSegment","concat","_toConsumableArray","some","slice","join","correctOption"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/explanation-generation/index.js"],"sourcesContent":["/**\r\n * Explanation Generation Module\r\n */\r\n\r\n/**\r\n * Find and generate explanation for a question from content\r\n * @param {Object} question - Question object\r\n * @param {string} content - Source content\r\n */\r\nexport function findExplanationFromContent(question, content) {\r\n  // Split content into smaller chunks (paragraphs and sentences)\r\n  const paragraphs = content.split(/\\n\\s*\\n/)\r\n    .map(p => p.trim())\r\n    .filter(p => p.length > 0);\r\n  \r\n  const sentences = content.split(/(?<=[.!?])\\s+/)\r\n    .map(s => s.trim())\r\n    .filter(s => s.length > 0);\r\n\r\n  // Extract key terms from question and answer\r\n  const questionTerms = new Set(\r\n    question.text.toLowerCase()\r\n      .replace(/[.,?!]/g, '')\r\n      .split(' ')\r\n      .filter(word => word.length > 3 && !['what', 'when', 'where', 'why', 'how', 'which', 'who', 'does', 'can', 'will', 'should', 'would', 'could', 'the', 'and', 'that'].includes(word))\r\n  );\r\n\r\n  const answerTerms = new Set();\r\n  if (question.type === 'multiple-choice') {\r\n    // Add terms from correct answer\r\n    question.options[question.correctAnswer].toLowerCase()\r\n      .replace(/[.,?!]/g, '')\r\n      .split(' ')\r\n      .filter(word => word.length > 3)\r\n      .forEach(term => answerTerms.add(term));\r\n    \r\n    // Add key terms from incorrect options to help identify contrasting explanations\r\n    Object.entries(question.options)\r\n      .filter(([key]) => key !== question.correctAnswer)\r\n      .forEach(([, option]) => {\r\n        option.toLowerCase()\r\n          .replace(/[.,?!]/g, '')\r\n          .split(' ')\r\n          .filter(word => word.length > 3)\r\n          .forEach(term => answerTerms.add(term));\r\n      });\r\n  }\r\n\r\n  // Score each paragraph\r\n  const scoredParagraphs = paragraphs.map(paragraph => {\r\n    const normalizedParagraph = paragraph.toLowerCase();\r\n    let score = 0;\r\n    let termMatches = 0;\r\n\r\n    // Check for exact phrase matches\r\n    if (normalizedParagraph.includes(question.text.toLowerCase())) {\r\n      score += 25;\r\n    }\r\n\r\n    // Check for answer phrase matches\r\n    if (question.type === 'multiple-choice') {\r\n      if (normalizedParagraph.includes(question.options[question.correctAnswer].toLowerCase())) {\r\n        score += 20;\r\n      }\r\n    }\r\n\r\n    // Score based on term density and relevance\r\n    questionTerms.forEach(term => {\r\n      if (normalizedParagraph.includes(term)) {\r\n        score += 5;\r\n        termMatches++;\r\n      }\r\n    });\r\n\r\n    answerTerms.forEach(term => {\r\n      if (normalizedParagraph.includes(term)) {\r\n        score += 3;\r\n        termMatches++;\r\n      }\r\n    });\r\n\r\n    // Bonus for high term density\r\n    const density = termMatches / (paragraph.split(' ').length);\r\n    score += density * 20;\r\n\r\n    // Penalty for very long paragraphs\r\n    if (paragraph.length > 300) {\r\n      score *= 0.8;\r\n    }\r\n\r\n    return {\r\n      text: paragraph,\r\n      score,\r\n      termMatches\r\n    };\r\n  }).filter(p => p.score > 10) // Only keep paragraphs with meaningful scores\r\n    .sort((a, b) => b.score - a.score);\r\n\r\n  // Score individual sentences for potential additional context\r\n  const scoredSentences = sentences.map(sentence => {\r\n    const normalizedSentence = sentence.toLowerCase();\r\n    let score = 0;\r\n    let termMatches = 0;\r\n\r\n    questionTerms.forEach(term => {\r\n      if (normalizedSentence.includes(term)) {\r\n        score += 3;\r\n        termMatches++;\r\n      }\r\n    });\r\n\r\n    answerTerms.forEach(term => {\r\n      if (normalizedSentence.includes(term)) {\r\n        score += 2;\r\n        termMatches++;\r\n      }\r\n    });\r\n\r\n    // Bonus for high term density in short sentences\r\n    const density = termMatches / (sentence.split(' ').length);\r\n    score += density * 15;\r\n\r\n    return {\r\n      text: sentence,\r\n      score,\r\n      termMatches\r\n    };\r\n  }).filter(s => s.score > 5)\r\n    .sort((a, b) => b.score - a.score);\r\n\r\n  // Construct the explanation\r\n  let explanation = '';\r\n  \r\n  if (scoredParagraphs.length > 0) {\r\n    // Use the highest scoring paragraph, but trim it if it's too long\r\n    let mainExplanation = scoredParagraphs[0].text;\r\n    if (mainExplanation.length > 300) {\r\n      // Find the most relevant segment within the paragraph\r\n      const segments = mainExplanation.split(/(?<=[.!?])\\s+/);\r\n      const relevantSegments = segments.filter(segment => {\r\n        const normalizedSegment = segment.toLowerCase();\r\n        return [...questionTerms, ...answerTerms].some(term => normalizedSegment.includes(term));\r\n      });\r\n      mainExplanation = relevantSegments.slice(0, 2).join(' ');\r\n    }\r\n    explanation = mainExplanation;\r\n\r\n    // Add a highly relevant sentence if it provides additional context\r\n    if (scoredSentences.length > 0 && \r\n        scoredSentences[0].score > 10 && \r\n        !explanation.toLowerCase().includes(scoredSentences[0].text.toLowerCase())) {\r\n      explanation += ' ' + scoredSentences[0].text;\r\n    }\r\n  } else if (scoredSentences.length > 0) {\r\n    // Use up to two most relevant sentences if no good paragraph was found\r\n    explanation = scoredSentences.slice(0, 2)\r\n      .map(s => s.text)\r\n      .join(' ');\r\n  }\r\n\r\n  // If no good explanation was found, use a fallback\r\n  if (!explanation || explanation.length < 20) {\r\n    if (question.type === 'multiple-choice') {\r\n      const correctOption = question.options[question.correctAnswer];\r\n      explanation = `The correct answer is \"${correctOption}\". This can be determined from the context of the material.`;\r\n    } else {\r\n      explanation = `This statement is ${question.correctAnswer} based on the information provided in the material.`;\r\n    }\r\n  } else {\r\n    // Add a concluding sentence for multiple choice questions\r\n    if (question.type === 'multiple-choice') {\r\n      const correctOption = question.options[question.correctAnswer];\r\n      if (!explanation.includes(correctOption)) {\r\n        explanation += ` Therefore, \"${correctOption}\" is the correct answer.`;\r\n      }\r\n    }\r\n  }\r\n\r\n  question.explanation = explanation;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
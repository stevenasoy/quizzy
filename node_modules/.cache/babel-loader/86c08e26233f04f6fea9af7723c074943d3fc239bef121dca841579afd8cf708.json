{"ast":null,"code":"import _slicedToArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\r\n * Text Analysis Algorithms Module\r\n */\n\n/**\r\n * Analyzes text complexity using multiple metrics\r\n * @param {string} content - The content to analyze\r\n * @returns {Object} Detailed complexity analysis\r\n */\nexport function analyzeTextComplexity(content) {\n  // Break content into sentences and words\n  var sentences = content.split(/[.!?]+/).filter(function (s) {\n    return s.trim().length > 0;\n  });\n  var words = content.split(/\\s+/).filter(function (w) {\n    return w.trim().length > 0;\n  });\n\n  // Calculate basic metrics\n  var avgWordLength = words.reduce(function (sum, word) {\n    return sum + word.length;\n  }, 0) / words.length;\n  var avgSentenceLength = words.length / sentences.length;\n\n  // Calculate Flesch-Kincaid Grade Level\n  var syllables = countSyllables(words);\n  var fleschKincaid = 0.39 * (words.length / sentences.length) + 11.8 * (syllables / words.length) - 15.59;\n\n  // Analyze vocabulary complexity\n  var vocabularyScore = analyzeVocabularyComplexity(words);\n\n  // Analyze sentence structure complexity\n  var structureScore = analyzeSentenceStructure(sentences);\n\n  // Calculate academic term frequency\n  var academicScore = analyzeAcademicTerms(content);\n\n  // Combine scores with weighted importance\n  var complexityScore = calculateComplexityScore({\n    fleschKincaid: normalizeScore(fleschKincaid, 0, 12),\n    vocabulary: vocabularyScore,\n    structure: structureScore,\n    academic: academicScore,\n    avgWordLength: normalizeScore(avgWordLength, 1, 15),\n    avgSentenceLength: normalizeScore(avgSentenceLength, 5, 35)\n  });\n  return {\n    overall: Math.min(complexityScore, 100),\n    metrics: {\n      readability: normalizeScore(fleschKincaid, 0, 12),\n      vocabulary: vocabularyScore,\n      structure: structureScore,\n      academic: academicScore,\n      avgWordLength: avgWordLength,\n      avgSentenceLength: avgSentenceLength\n    }\n  };\n}\n\n/**\r\n * Counts syllables in words\r\n * @param {string[]} words - Array of words\r\n * @returns {number} Total syllable count\r\n */\nfunction countSyllables(words) {\n  return words.reduce(function (total, word) {\n    var _word$match;\n    word = word.toLowerCase();\n    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');\n    word = word.replace(/^y/, '');\n    var syllableCount = ((_word$match = word.match(/[aeiouy]{1,2}/g)) === null || _word$match === void 0 ? void 0 : _word$match.length) || 1;\n    return total + syllableCount;\n  }, 0);\n}\n\n/**\r\n * Analyzes vocabulary complexity\r\n * @param {string[]} words - Array of words\r\n * @returns {number} Vocabulary complexity score (0-100)\r\n */\nfunction analyzeVocabularyComplexity(words) {\n  var complexityIndicators = {\n    length: function length(word) {\n      return word.length > 8 ? 1 : 0;\n    },\n    specialChars: function specialChars(word) {\n      return /[-;:,]/.test(word) ? 1 : 0;\n    },\n    compoundWords: function compoundWords(word) {\n      return word.includes('-') ? 1 : 0;\n    },\n    technicalTerms: function technicalTerms(word) {\n      return technicalVocabulary.has(word.toLowerCase()) ? 2 : 0;\n    }\n  };\n  var totalScore = 0;\n  var uniqueWords = new Set(words.map(function (w) {\n    return w.toLowerCase();\n  }));\n  uniqueWords.forEach(function (word) {\n    Object.values(complexityIndicators).forEach(function (indicator) {\n      totalScore += indicator(word);\n    });\n  });\n  return normalizeScore(totalScore / words.length * 20, 0, 100);\n}\n\n/**\r\n * Analyzes sentence structure complexity\r\n * @param {string[]} sentences - Array of sentences\r\n * @returns {number} Structure complexity score (0-100)\r\n */\nfunction analyzeSentenceStructure(sentences) {\n  var structureIndicators = {\n    conjunctions: function conjunctions(sentence) {\n      return (sentence.match(/\\b(and|but|or|nor|for|yet|so)\\b/gi) || []).length;\n    },\n    subordinateClauses: function subordinateClauses(sentence) {\n      return (sentence.match(/\\b(because|although|if|unless|while|whereas)\\b/gi) || []).length;\n    },\n    complexPhrases: function complexPhrases(sentence) {\n      return (sentence.match(/\\b(in order to|as a result of|due to the fact that)\\b/gi) || []).length;\n    },\n    parentheticalExpressions: function parentheticalExpressions(sentence) {\n      return (sentence.match(/\\(.*?\\)|\\[.*?\\]|,.*?,/g) || []).length;\n    }\n  };\n  var totalScore = 0;\n  sentences.forEach(function (sentence) {\n    Object.values(structureIndicators).forEach(function (indicator) {\n      totalScore += indicator(sentence) * 5;\n    });\n  });\n  return normalizeScore(totalScore / sentences.length * 10, 0, 100);\n}\n\n/**\r\n * Analyzes academic term frequency\r\n * @param {string} content - Content to analyze\r\n * @returns {number} Academic complexity score (0-100)\r\n */\nfunction analyzeAcademicTerms(content) {\n  var academicTerms = new Set(['analyze', 'assess', 'compare', 'contrast', 'define', 'describe', 'discuss', 'evaluate', 'explain', 'identify', 'interpret', 'justify', 'synthesize', 'theoretical', 'hypothesis', 'methodology', 'framework', 'paradigm', 'perspective', 'context', 'furthermore', 'however', 'nevertheless', 'therefore', 'consequently', 'whereas', 'hence', 'thus', 'accordingly', 'subsequently']);\n  var normalizedContent = content.toLowerCase();\n  var termCount = 0;\n  academicTerms.forEach(function (term) {\n    var regex = new RegExp(\"\\\\b\".concat(term, \"\\\\b\"), 'g');\n    var matches = normalizedContent.match(regex);\n    if (matches) {\n      termCount += matches.length;\n    }\n  });\n  return normalizeScore(termCount * 5, 0, 100);\n}\n\n/**\r\n * Calculates overall complexity score\r\n * @param {Object} metrics - Various complexity metrics\r\n * @returns {number} Overall complexity score\r\n */\nfunction calculateComplexityScore(metrics) {\n  var weights = {\n    fleschKincaid: 0.25,\n    vocabulary: 0.25,\n    structure: 0.2,\n    academic: 0.15,\n    avgWordLength: 0.1,\n    avgSentenceLength: 0.05\n  };\n  return Object.entries(weights).reduce(function (score, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      weight = _ref2[1];\n    return score + metrics[key] * weight;\n  }, 0);\n}\n\n// Technical vocabulary set (can be expanded)\nvar technicalVocabulary = new Set(['algorithm', 'analysis', 'methodology', 'hypothesis', 'theoretical', 'framework', 'implementation', 'paradigm', 'systematic', 'correlation', 'derivative', 'synthesis', 'quantum', 'methodology', 'infrastructure', 'optimization'\n// Add more technical terms as needed\n]);\n\n/**\r\n * Normalizes a score to a specific range\r\n * @param {number} score - Raw score\r\n * @param {number} min - Minimum expected value\r\n * @param {number} max - Maximum expected value\r\n * @returns {number} Normalized score (0-100)\r\n */\nfunction normalizeScore(score, min, max) {\n  return Math.min(100, Math.max(0, (score - min) / (max - min) * 100));\n}\n\n/**\r\n * Analyzes keyword frequency in content\r\n * @param {string} content - The content to analyze\r\n * @param {string[]} keywords - Keywords to look for\r\n * @returns {Object} Frequency analysis results\r\n */\nexport function analyzeKeywordFrequency(content, keywords) {\n  var frequencies = {};\n  var normalizedContent = content.toLowerCase();\n  keywords.forEach(function (keyword) {\n    var regex = new RegExp(keyword, 'g');\n    var matches = normalizedContent.match(regex);\n    frequencies[keyword] = matches ? matches.length : 0;\n  });\n  return frequencies;\n}\n\n/**\r\n * Normalizes text for consistent comparison\r\n * @param {string} text - Text to normalize\r\n * @returns {string} Normalized text\r\n */\nexport function normalizeText(text) {\n  return text.toLowerCase().replace(/[.,?!]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\n/**\r\n * Finds pattern matches in content\r\n * @param {string} content - Content to search in\r\n * @param {string} pattern - Pattern to match\r\n * @returns {Array} Array of matches\r\n */\nexport function findPatternMatches(content, pattern) {\n  var regex = new RegExp(pattern, 'gi');\n  return content.match(regex) || [];\n}","map":{"version":3,"names":["analyzeTextComplexity","content","sentences","split","filter","s","trim","length","words","w","avgWordLength","reduce","sum","word","avgSentenceLength","syllables","countSyllables","fleschKincaid","vocabularyScore","analyzeVocabularyComplexity","structureScore","analyzeSentenceStructure","academicScore","analyzeAcademicTerms","complexityScore","calculateComplexityScore","normalizeScore","vocabulary","structure","academic","overall","Math","min","metrics","readability","total","_word$match","toLowerCase","replace","syllableCount","match","complexityIndicators","specialChars","test","compoundWords","includes","technicalTerms","technicalVocabulary","has","totalScore","uniqueWords","Set","map","forEach","Object","values","indicator","structureIndicators","conjunctions","sentence","subordinateClauses","complexPhrases","parentheticalExpressions","academicTerms","normalizedContent","termCount","term","regex","RegExp","concat","matches","weights","entries","score","_ref","_ref2","_slicedToArray","key","weight","max","analyzeKeywordFrequency","keywords","frequencies","keyword","normalizeText","text","findPatternMatches","pattern"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/text-analysis/index.js"],"sourcesContent":["/**\r\n * Text Analysis Algorithms Module\r\n */\r\n\r\n/**\r\n * Analyzes text complexity using multiple metrics\r\n * @param {string} content - The content to analyze\r\n * @returns {Object} Detailed complexity analysis\r\n */\r\nexport function analyzeTextComplexity(content) {\r\n  // Break content into sentences and words\r\n  const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);\r\n  const words = content.split(/\\s+/).filter(w => w.trim().length > 0);\r\n  \r\n  // Calculate basic metrics\r\n  const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;\r\n  const avgSentenceLength = words.length / sentences.length;\r\n  \r\n  // Calculate Flesch-Kincaid Grade Level\r\n  const syllables = countSyllables(words);\r\n  const fleschKincaid = 0.39 * (words.length / sentences.length) + 11.8 * (syllables / words.length) - 15.59;\r\n  \r\n  // Analyze vocabulary complexity\r\n  const vocabularyScore = analyzeVocabularyComplexity(words);\r\n  \r\n  // Analyze sentence structure complexity\r\n  const structureScore = analyzeSentenceStructure(sentences);\r\n  \r\n  // Calculate academic term frequency\r\n  const academicScore = analyzeAcademicTerms(content);\r\n  \r\n  // Combine scores with weighted importance\r\n  const complexityScore = calculateComplexityScore({\r\n    fleschKincaid: normalizeScore(fleschKincaid, 0, 12),\r\n    vocabulary: vocabularyScore,\r\n    structure: structureScore,\r\n    academic: academicScore,\r\n    avgWordLength: normalizeScore(avgWordLength, 1, 15),\r\n    avgSentenceLength: normalizeScore(avgSentenceLength, 5, 35)\r\n  });\r\n\r\n  return {\r\n    overall: Math.min(complexityScore, 100),\r\n    metrics: {\r\n      readability: normalizeScore(fleschKincaid, 0, 12),\r\n      vocabulary: vocabularyScore,\r\n      structure: structureScore,\r\n      academic: academicScore,\r\n      avgWordLength,\r\n      avgSentenceLength\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Counts syllables in words\r\n * @param {string[]} words - Array of words\r\n * @returns {number} Total syllable count\r\n */\r\nfunction countSyllables(words) {\r\n  return words.reduce((total, word) => {\r\n    word = word.toLowerCase();\r\n    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');\r\n    word = word.replace(/^y/, '');\r\n    const syllableCount = word.match(/[aeiouy]{1,2}/g)?.length || 1;\r\n    return total + syllableCount;\r\n  }, 0);\r\n}\r\n\r\n/**\r\n * Analyzes vocabulary complexity\r\n * @param {string[]} words - Array of words\r\n * @returns {number} Vocabulary complexity score (0-100)\r\n */\r\nfunction analyzeVocabularyComplexity(words) {\r\n  const complexityIndicators = {\r\n    length: word => word.length > 8 ? 1 : 0,\r\n    specialChars: word => /[-;:,]/.test(word) ? 1 : 0,\r\n    compoundWords: word => word.includes('-') ? 1 : 0,\r\n    technicalTerms: word => technicalVocabulary.has(word.toLowerCase()) ? 2 : 0\r\n  };\r\n\r\n  let totalScore = 0;\r\n  const uniqueWords = new Set(words.map(w => w.toLowerCase()));\r\n\r\n  uniqueWords.forEach(word => {\r\n    Object.values(complexityIndicators).forEach(indicator => {\r\n      totalScore += indicator(word);\r\n    });\r\n  });\r\n\r\n  return normalizeScore(totalScore / words.length * 20, 0, 100);\r\n}\r\n\r\n/**\r\n * Analyzes sentence structure complexity\r\n * @param {string[]} sentences - Array of sentences\r\n * @returns {number} Structure complexity score (0-100)\r\n */\r\nfunction analyzeSentenceStructure(sentences) {\r\n  const structureIndicators = {\r\n    conjunctions: sentence => (sentence.match(/\\b(and|but|or|nor|for|yet|so)\\b/gi) || []).length,\r\n    subordinateClauses: sentence => (sentence.match(/\\b(because|although|if|unless|while|whereas)\\b/gi) || []).length,\r\n    complexPhrases: sentence => (sentence.match(/\\b(in order to|as a result of|due to the fact that)\\b/gi) || []).length,\r\n    parentheticalExpressions: sentence => (sentence.match(/\\(.*?\\)|\\[.*?\\]|,.*?,/g) || []).length\r\n  };\r\n\r\n  let totalScore = 0;\r\n  sentences.forEach(sentence => {\r\n    Object.values(structureIndicators).forEach(indicator => {\r\n      totalScore += indicator(sentence) * 5;\r\n    });\r\n  });\r\n\r\n  return normalizeScore(totalScore / sentences.length * 10, 0, 100);\r\n}\r\n\r\n/**\r\n * Analyzes academic term frequency\r\n * @param {string} content - Content to analyze\r\n * @returns {number} Academic complexity score (0-100)\r\n */\r\nfunction analyzeAcademicTerms(content) {\r\n  const academicTerms = new Set([\r\n    'analyze', 'assess', 'compare', 'contrast', 'define',\r\n    'describe', 'discuss', 'evaluate', 'explain', 'identify',\r\n    'interpret', 'justify', 'synthesize', 'theoretical', 'hypothesis',\r\n    'methodology', 'framework', 'paradigm', 'perspective', 'context',\r\n    'furthermore', 'however', 'nevertheless', 'therefore', 'consequently',\r\n    'whereas', 'hence', 'thus', 'accordingly', 'subsequently'\r\n  ]);\r\n\r\n  const normalizedContent = content.toLowerCase();\r\n  let termCount = 0;\r\n\r\n  academicTerms.forEach(term => {\r\n    const regex = new RegExp(`\\\\b${term}\\\\b`, 'g');\r\n    const matches = normalizedContent.match(regex);\r\n    if (matches) {\r\n      termCount += matches.length;\r\n    }\r\n  });\r\n\r\n  return normalizeScore(termCount * 5, 0, 100);\r\n}\r\n\r\n/**\r\n * Calculates overall complexity score\r\n * @param {Object} metrics - Various complexity metrics\r\n * @returns {number} Overall complexity score\r\n */\r\nfunction calculateComplexityScore(metrics) {\r\n  const weights = {\r\n    fleschKincaid: 0.25,\r\n    vocabulary: 0.25,\r\n    structure: 0.2,\r\n    academic: 0.15,\r\n    avgWordLength: 0.1,\r\n    avgSentenceLength: 0.05\r\n  };\r\n\r\n  return Object.entries(weights).reduce((score, [key, weight]) => {\r\n    return score + (metrics[key] * weight);\r\n  }, 0);\r\n}\r\n\r\n// Technical vocabulary set (can be expanded)\r\nconst technicalVocabulary = new Set([\r\n  'algorithm', 'analysis', 'methodology', 'hypothesis',\r\n  'theoretical', 'framework', 'implementation', 'paradigm',\r\n  'systematic', 'correlation', 'derivative', 'synthesis',\r\n  'quantum', 'methodology', 'infrastructure', 'optimization'\r\n  // Add more technical terms as needed\r\n]);\r\n\r\n/**\r\n * Normalizes a score to a specific range\r\n * @param {number} score - Raw score\r\n * @param {number} min - Minimum expected value\r\n * @param {number} max - Maximum expected value\r\n * @returns {number} Normalized score (0-100)\r\n */\r\nfunction normalizeScore(score, min, max) {\r\n  return Math.min(100, Math.max(0, ((score - min) / (max - min)) * 100));\r\n}\r\n\r\n/**\r\n * Analyzes keyword frequency in content\r\n * @param {string} content - The content to analyze\r\n * @param {string[]} keywords - Keywords to look for\r\n * @returns {Object} Frequency analysis results\r\n */\r\nexport function analyzeKeywordFrequency(content, keywords) {\r\n  const frequencies = {};\r\n  const normalizedContent = content.toLowerCase();\r\n  \r\n  keywords.forEach(keyword => {\r\n    const regex = new RegExp(keyword, 'g');\r\n    const matches = normalizedContent.match(regex);\r\n    frequencies[keyword] = matches ? matches.length : 0;\r\n  });\r\n  \r\n  return frequencies;\r\n}\r\n\r\n/**\r\n * Normalizes text for consistent comparison\r\n * @param {string} text - Text to normalize\r\n * @returns {string} Normalized text\r\n */\r\nexport function normalizeText(text) {\r\n  return text\r\n    .toLowerCase()\r\n    .replace(/[.,?!]/g, '')\r\n    .replace(/\\s+/g, ' ')\r\n    .trim();\r\n}\r\n\r\n/**\r\n * Finds pattern matches in content\r\n * @param {string} content - Content to search in\r\n * @param {string} pattern - Pattern to match\r\n * @returns {Array} Array of matches\r\n */\r\nexport function findPatternMatches(content, pattern) {\r\n  const regex = new RegExp(pattern, 'gi');\r\n  return content.match(regex) || [];\r\n} "],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,qBAAqBA,CAACC,OAAO,EAAE;EAC7C;EACA,IAAMC,SAAS,GAAGD,OAAO,CAACE,KAAK,CAAC,QAAQ,CAAC,CAACC,MAAM,CAAC,UAAAC,CAAC;IAAA,OAAIA,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC;EAAA,EAAC;EAC1E,IAAMC,KAAK,GAAGP,OAAO,CAACE,KAAK,CAAC,KAAK,CAAC,CAACC,MAAM,CAAC,UAAAK,CAAC;IAAA,OAAIA,CAAC,CAACH,IAAI,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC;EAAA,EAAC;;EAEnE;EACA,IAAMG,aAAa,GAAGF,KAAK,CAACG,MAAM,CAAC,UAACC,GAAG,EAAEC,IAAI;IAAA,OAAKD,GAAG,GAAGC,IAAI,CAACN,MAAM;EAAA,GAAE,CAAC,CAAC,GAAGC,KAAK,CAACD,MAAM;EACtF,IAAMO,iBAAiB,GAAGN,KAAK,CAACD,MAAM,GAAGL,SAAS,CAACK,MAAM;;EAEzD;EACA,IAAMQ,SAAS,GAAGC,cAAc,CAACR,KAAK,CAAC;EACvC,IAAMS,aAAa,GAAG,IAAI,IAAIT,KAAK,CAACD,MAAM,GAAGL,SAAS,CAACK,MAAM,CAAC,GAAG,IAAI,IAAIQ,SAAS,GAAGP,KAAK,CAACD,MAAM,CAAC,GAAG,KAAK;;EAE1G;EACA,IAAMW,eAAe,GAAGC,2BAA2B,CAACX,KAAK,CAAC;;EAE1D;EACA,IAAMY,cAAc,GAAGC,wBAAwB,CAACnB,SAAS,CAAC;;EAE1D;EACA,IAAMoB,aAAa,GAAGC,oBAAoB,CAACtB,OAAO,CAAC;;EAEnD;EACA,IAAMuB,eAAe,GAAGC,wBAAwB,CAAC;IAC/CR,aAAa,EAAES,cAAc,CAACT,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;IACnDU,UAAU,EAAET,eAAe;IAC3BU,SAAS,EAAER,cAAc;IACzBS,QAAQ,EAAEP,aAAa;IACvBZ,aAAa,EAAEgB,cAAc,CAAChB,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;IACnDI,iBAAiB,EAAEY,cAAc,CAACZ,iBAAiB,EAAE,CAAC,EAAE,EAAE;EAC5D,CAAC,CAAC;EAEF,OAAO;IACLgB,OAAO,EAAEC,IAAI,CAACC,GAAG,CAACR,eAAe,EAAE,GAAG,CAAC;IACvCS,OAAO,EAAE;MACPC,WAAW,EAAER,cAAc,CAACT,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;MACjDU,UAAU,EAAET,eAAe;MAC3BU,SAAS,EAAER,cAAc;MACzBS,QAAQ,EAAEP,aAAa;MACvBZ,aAAa,EAAbA,aAAa;MACbI,iBAAiB,EAAjBA;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,cAAcA,CAACR,KAAK,EAAE;EAC7B,OAAOA,KAAK,CAACG,MAAM,CAAC,UAACwB,KAAK,EAAEtB,IAAI,EAAK;IAAA,IAAAuB,WAAA;IACnCvB,IAAI,GAAGA,IAAI,CAACwB,WAAW,CAAC,CAAC;IACzBxB,IAAI,GAAGA,IAAI,CAACyB,OAAO,CAAC,kCAAkC,EAAE,EAAE,CAAC;IAC3DzB,IAAI,GAAGA,IAAI,CAACyB,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IAC7B,IAAMC,aAAa,GAAG,EAAAH,WAAA,GAAAvB,IAAI,CAAC2B,KAAK,CAAC,gBAAgB,CAAC,cAAAJ,WAAA,uBAA5BA,WAAA,CAA8B7B,MAAM,KAAI,CAAC;IAC/D,OAAO4B,KAAK,GAAGI,aAAa;EAC9B,CAAC,EAAE,CAAC,CAAC;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASpB,2BAA2BA,CAACX,KAAK,EAAE;EAC1C,IAAMiC,oBAAoB,GAAG;IAC3BlC,MAAM,EAAE,SAARA,MAAMA,CAAEM,IAAI;MAAA,OAAIA,IAAI,CAACN,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;IAAA;IACvCmC,YAAY,EAAE,SAAdA,YAAYA,CAAE7B,IAAI;MAAA,OAAI,QAAQ,CAAC8B,IAAI,CAAC9B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IAAA;IACjD+B,aAAa,EAAE,SAAfA,aAAaA,CAAE/B,IAAI;MAAA,OAAIA,IAAI,CAACgC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;IAAA;IACjDC,cAAc,EAAE,SAAhBA,cAAcA,CAAEjC,IAAI;MAAA,OAAIkC,mBAAmB,CAACC,GAAG,CAACnC,IAAI,CAACwB,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;IAAA;EAC7E,CAAC;EAED,IAAIY,UAAU,GAAG,CAAC;EAClB,IAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC3C,KAAK,CAAC4C,GAAG,CAAC,UAAA3C,CAAC;IAAA,OAAIA,CAAC,CAAC4B,WAAW,CAAC,CAAC;EAAA,EAAC,CAAC;EAE5Da,WAAW,CAACG,OAAO,CAAC,UAAAxC,IAAI,EAAI;IAC1ByC,MAAM,CAACC,MAAM,CAACd,oBAAoB,CAAC,CAACY,OAAO,CAAC,UAAAG,SAAS,EAAI;MACvDP,UAAU,IAAIO,SAAS,CAAC3C,IAAI,CAAC;IAC/B,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOa,cAAc,CAACuB,UAAU,GAAGzC,KAAK,CAACD,MAAM,GAAG,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASc,wBAAwBA,CAACnB,SAAS,EAAE;EAC3C,IAAMuD,mBAAmB,GAAG;IAC1BC,YAAY,EAAE,SAAdA,YAAYA,CAAEC,QAAQ;MAAA,OAAI,CAACA,QAAQ,CAACnB,KAAK,CAAC,mCAAmC,CAAC,IAAI,EAAE,EAAEjC,MAAM;IAAA;IAC5FqD,kBAAkB,EAAE,SAApBA,kBAAkBA,CAAED,QAAQ;MAAA,OAAI,CAACA,QAAQ,CAACnB,KAAK,CAAC,kDAAkD,CAAC,IAAI,EAAE,EAAEjC,MAAM;IAAA;IACjHsD,cAAc,EAAE,SAAhBA,cAAcA,CAAEF,QAAQ;MAAA,OAAI,CAACA,QAAQ,CAACnB,KAAK,CAAC,yDAAyD,CAAC,IAAI,EAAE,EAAEjC,MAAM;IAAA;IACpHuD,wBAAwB,EAAE,SAA1BA,wBAAwBA,CAAEH,QAAQ;MAAA,OAAI,CAACA,QAAQ,CAACnB,KAAK,CAAC,wBAAwB,CAAC,IAAI,EAAE,EAAEjC,MAAM;IAAA;EAC/F,CAAC;EAED,IAAI0C,UAAU,GAAG,CAAC;EAClB/C,SAAS,CAACmD,OAAO,CAAC,UAAAM,QAAQ,EAAI;IAC5BL,MAAM,CAACC,MAAM,CAACE,mBAAmB,CAAC,CAACJ,OAAO,CAAC,UAAAG,SAAS,EAAI;MACtDP,UAAU,IAAIO,SAAS,CAACG,QAAQ,CAAC,GAAG,CAAC;IACvC,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,OAAOjC,cAAc,CAACuB,UAAU,GAAG/C,SAAS,CAACK,MAAM,GAAG,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASgB,oBAAoBA,CAACtB,OAAO,EAAE;EACrC,IAAM8D,aAAa,GAAG,IAAIZ,GAAG,CAAC,CAC5B,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,UAAU,EAAE,QAAQ,EACpD,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,EACxD,WAAW,EAAE,SAAS,EAAE,YAAY,EAAE,aAAa,EAAE,YAAY,EACjE,aAAa,EAAE,WAAW,EAAE,UAAU,EAAE,aAAa,EAAE,SAAS,EAChE,aAAa,EAAE,SAAS,EAAE,cAAc,EAAE,WAAW,EAAE,cAAc,EACrE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,aAAa,EAAE,cAAc,CAC1D,CAAC;EAEF,IAAMa,iBAAiB,GAAG/D,OAAO,CAACoC,WAAW,CAAC,CAAC;EAC/C,IAAI4B,SAAS,GAAG,CAAC;EAEjBF,aAAa,CAACV,OAAO,CAAC,UAAAa,IAAI,EAAI;IAC5B,IAAMC,KAAK,GAAG,IAAIC,MAAM,OAAAC,MAAA,CAAOH,IAAI,UAAO,GAAG,CAAC;IAC9C,IAAMI,OAAO,GAAGN,iBAAiB,CAACxB,KAAK,CAAC2B,KAAK,CAAC;IAC9C,IAAIG,OAAO,EAAE;MACXL,SAAS,IAAIK,OAAO,CAAC/D,MAAM;IAC7B;EACF,CAAC,CAAC;EAEF,OAAOmB,cAAc,CAACuC,SAAS,GAAG,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASxC,wBAAwBA,CAACQ,OAAO,EAAE;EACzC,IAAMsC,OAAO,GAAG;IACdtD,aAAa,EAAE,IAAI;IACnBU,UAAU,EAAE,IAAI;IAChBC,SAAS,EAAE,GAAG;IACdC,QAAQ,EAAE,IAAI;IACdnB,aAAa,EAAE,GAAG;IAClBI,iBAAiB,EAAE;EACrB,CAAC;EAED,OAAOwC,MAAM,CAACkB,OAAO,CAACD,OAAO,CAAC,CAAC5D,MAAM,CAAC,UAAC8D,KAAK,EAAAC,IAAA,EAAoB;IAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAF,IAAA;MAAjBG,GAAG,GAAAF,KAAA;MAAEG,MAAM,GAAAH,KAAA;IACxD,OAAOF,KAAK,GAAIxC,OAAO,CAAC4C,GAAG,CAAC,GAAGC,MAAO;EACxC,CAAC,EAAE,CAAC,CAAC;AACP;;AAEA;AACA,IAAM/B,mBAAmB,GAAG,IAAII,GAAG,CAAC,CAClC,WAAW,EAAE,UAAU,EAAE,aAAa,EAAE,YAAY,EACpD,aAAa,EAAE,WAAW,EAAE,gBAAgB,EAAE,UAAU,EACxD,YAAY,EAAE,aAAa,EAAE,YAAY,EAAE,WAAW,EACtD,SAAS,EAAE,aAAa,EAAE,gBAAgB,EAAE;AAC5C;AAAA,CACD,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzB,cAAcA,CAAC+C,KAAK,EAAEzC,GAAG,EAAE+C,GAAG,EAAE;EACvC,OAAOhD,IAAI,CAACC,GAAG,CAAC,GAAG,EAAED,IAAI,CAACgD,GAAG,CAAC,CAAC,EAAG,CAACN,KAAK,GAAGzC,GAAG,KAAK+C,GAAG,GAAG/C,GAAG,CAAC,GAAI,GAAG,CAAC,CAAC;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgD,uBAAuBA,CAAC/E,OAAO,EAAEgF,QAAQ,EAAE;EACzD,IAAMC,WAAW,GAAG,CAAC,CAAC;EACtB,IAAMlB,iBAAiB,GAAG/D,OAAO,CAACoC,WAAW,CAAC,CAAC;EAE/C4C,QAAQ,CAAC5B,OAAO,CAAC,UAAA8B,OAAO,EAAI;IAC1B,IAAMhB,KAAK,GAAG,IAAIC,MAAM,CAACe,OAAO,EAAE,GAAG,CAAC;IACtC,IAAMb,OAAO,GAAGN,iBAAiB,CAACxB,KAAK,CAAC2B,KAAK,CAAC;IAC9Ce,WAAW,CAACC,OAAO,CAAC,GAAGb,OAAO,GAAGA,OAAO,CAAC/D,MAAM,GAAG,CAAC;EACrD,CAAC,CAAC;EAEF,OAAO2E,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,aAAaA,CAACC,IAAI,EAAE;EAClC,OAAOA,IAAI,CACRhD,WAAW,CAAC,CAAC,CACbC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CACtBA,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CACpBhC,IAAI,CAAC,CAAC;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgF,kBAAkBA,CAACrF,OAAO,EAAEsF,OAAO,EAAE;EACnD,IAAMpB,KAAK,GAAG,IAAIC,MAAM,CAACmB,OAAO,EAAE,IAAI,CAAC;EACvC,OAAOtF,OAAO,CAACuC,KAAK,CAAC2B,KAAK,CAAC,IAAI,EAAE;AACnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
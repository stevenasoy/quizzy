{"ast":null,"code":"import _objectSpread from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"C:/Users/StevenJakeASOY/Documents/cursor-projects/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/**\r\n * Difficulty Adaptation Algorithm Module\r\n */\n\n/**\r\n * Calculate the next question's difficulty based on user performance\r\n * @param {Array} previousResponses - Array of previous question responses\r\n * @param {number} consecutiveCorrect - Number of consecutive correct answers\r\n * @param {number} consecutiveIncorrect - Number of consecutive incorrect answers\r\n * @returns {string} Next question difficulty level\r\n */\nexport function calculateNextDifficulty(previousResponses, consecutiveCorrect, consecutiveIncorrect) {\n  // If no previous responses, start with medium\n  if (!previousResponses || previousResponses.length === 0) {\n    return 'medium';\n  }\n\n  // Get current difficulty from last question\n  var currentDifficulty = previousResponses[previousResponses.length - 1].difficulty || 'medium';\n\n  // New difficulty progression logic\n  if (currentDifficulty === 'easy') {\n    // If correct in easy, move to medium\n    if (consecutiveCorrect >= 1) {\n      return 'medium';\n    }\n    // If wrong in easy, stay in easy\n    return 'easy';\n  } else if (currentDifficulty === 'medium') {\n    // If correct in medium, move to hard\n    if (consecutiveCorrect >= 1) {\n      return 'hard';\n    }\n    // If wrong in medium, move to easy\n    if (consecutiveIncorrect >= 1) {\n      return 'easy';\n    }\n    // Otherwise stay in medium\n    return 'medium';\n  } else if (currentDifficulty === 'hard') {\n    // If wrong in hard, move back to medium\n    if (consecutiveIncorrect >= 1) {\n      return 'medium';\n    }\n    // If correct in hard, stay in hard\n    return 'hard';\n  }\n\n  // Default to medium if something unexpected happens\n  return 'medium';\n}\n\n/**\r\n * Select the next question from available questions based on calculated difficulty\r\n * @param {Array} availableQuestions - Array of unused questions\r\n * @param {string} targetDifficulty - Target difficulty level\r\n * @returns {Object} Selected question and remaining questions\r\n */\nexport function selectNextQuestion(availableQuestions, targetDifficulty) {\n  if (!availableQuestions || availableQuestions.length === 0) {\n    return {\n      question: null,\n      remainingQuestions: []\n    };\n  }\n\n  // First try to find a question of target difficulty\n  var question = availableQuestions.find(function (q) {\n    return q.difficulty === targetDifficulty;\n  });\n\n  // If no question of target difficulty, find closest difficulty\n  if (!question) {\n    if (targetDifficulty === 'hard') {\n      question = availableQuestions.find(function (q) {\n        return q.difficulty === 'medium';\n      });\n    } else if (targetDifficulty === 'easy') {\n      question = availableQuestions.find(function (q) {\n        return q.difficulty === 'medium';\n      });\n    } else {\n      // If medium not found, take any question\n      question = availableQuestions[0];\n    }\n  }\n\n  // If still no question found, take the first available\n  if (!question) {\n    question = availableQuestions[0];\n  }\n\n  // Remove selected question from available questions\n  var remainingQuestions = availableQuestions.filter(function (q) {\n    return q !== question;\n  });\n  return {\n    question: question,\n    remainingQuestions: remainingQuestions\n  };\n}\n\n/**\r\n * Initialize adaptive quiz state\r\n * @param {Array} questions - Array of all questions\r\n * @returns {Object} Initial quiz state\r\n */\nexport function initializeAdaptiveQuiz(questions) {\n  return {\n    availableQuestions: _toConsumableArray(questions),\n    usedQuestions: [],\n    consecutiveCorrect: 0,\n    consecutiveIncorrect: 0,\n    currentDifficulty: 'medium'\n  };\n}\n\n/**\r\n * Update quiz state based on user's answer\r\n * @param {Object} quizState - Current quiz state\r\n * @param {Object} response - User's response to current question\r\n * @returns {Object} Updated quiz state\r\n */\nexport function updateQuizState(quizState, response) {\n  var newState = _objectSpread({}, quizState);\n\n  // Update consecutive counters\n  if (response.correct) {\n    newState.consecutiveCorrect += 1;\n    newState.consecutiveIncorrect = 0;\n  } else {\n    newState.consecutiveIncorrect += 1;\n    newState.consecutiveCorrect = 0;\n  }\n\n  // Add response to used questions\n  newState.usedQuestions.push(response);\n\n  // Calculate next difficulty\n  newState.currentDifficulty = calculateNextDifficulty(newState.usedQuestions, newState.consecutiveCorrect, newState.consecutiveIncorrect);\n  return newState;\n}","map":{"version":3,"names":["calculateNextDifficulty","previousResponses","consecutiveCorrect","consecutiveIncorrect","length","currentDifficulty","difficulty","selectNextQuestion","availableQuestions","targetDifficulty","question","remainingQuestions","find","q","filter","initializeAdaptiveQuiz","questions","_toConsumableArray","usedQuestions","updateQuizState","quizState","response","newState","_objectSpread","correct","push"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/difficulty-adaptation/index.js"],"sourcesContent":["/**\r\n * Difficulty Adaptation Algorithm Module\r\n */\r\n\r\n/**\r\n * Calculate the next question's difficulty based on user performance\r\n * @param {Array} previousResponses - Array of previous question responses\r\n * @param {number} consecutiveCorrect - Number of consecutive correct answers\r\n * @param {number} consecutiveIncorrect - Number of consecutive incorrect answers\r\n * @returns {string} Next question difficulty level\r\n */\r\nexport function calculateNextDifficulty(previousResponses, consecutiveCorrect, consecutiveIncorrect) {\r\n  // If no previous responses, start with medium\r\n  if (!previousResponses || previousResponses.length === 0) {\r\n    return 'medium';\r\n  }\r\n\r\n  // Get current difficulty from last question\r\n  const currentDifficulty = previousResponses[previousResponses.length - 1].difficulty || 'medium';\r\n  \r\n  // New difficulty progression logic\r\n  if (currentDifficulty === 'easy') {\r\n    // If correct in easy, move to medium\r\n    if (consecutiveCorrect >= 1) {\r\n      return 'medium';\r\n    }\r\n    // If wrong in easy, stay in easy\r\n    return 'easy';\r\n  } \r\n  else if (currentDifficulty === 'medium') {\r\n    // If correct in medium, move to hard\r\n    if (consecutiveCorrect >= 1) {\r\n      return 'hard';\r\n    }\r\n    // If wrong in medium, move to easy\r\n    if (consecutiveIncorrect >= 1) {\r\n      return 'easy';\r\n    }\r\n    // Otherwise stay in medium\r\n    return 'medium';\r\n  } \r\n  else if (currentDifficulty === 'hard') {\r\n    // If wrong in hard, move back to medium\r\n    if (consecutiveIncorrect >= 1) {\r\n      return 'medium';\r\n    }\r\n    // If correct in hard, stay in hard\r\n    return 'hard';\r\n  }\r\n\r\n  // Default to medium if something unexpected happens\r\n  return 'medium';\r\n}\r\n\r\n/**\r\n * Select the next question from available questions based on calculated difficulty\r\n * @param {Array} availableQuestions - Array of unused questions\r\n * @param {string} targetDifficulty - Target difficulty level\r\n * @returns {Object} Selected question and remaining questions\r\n */\r\nexport function selectNextQuestion(availableQuestions, targetDifficulty) {\r\n  if (!availableQuestions || availableQuestions.length === 0) {\r\n    return { question: null, remainingQuestions: [] };\r\n  }\r\n\r\n  // First try to find a question of target difficulty\r\n  let question = availableQuestions.find(q => q.difficulty === targetDifficulty);\r\n\r\n  // If no question of target difficulty, find closest difficulty\r\n  if (!question) {\r\n    if (targetDifficulty === 'hard') {\r\n      question = availableQuestions.find(q => q.difficulty === 'medium');\r\n    } else if (targetDifficulty === 'easy') {\r\n      question = availableQuestions.find(q => q.difficulty === 'medium');\r\n    } else {\r\n      // If medium not found, take any question\r\n      question = availableQuestions[0];\r\n    }\r\n  }\r\n\r\n  // If still no question found, take the first available\r\n  if (!question) {\r\n    question = availableQuestions[0];\r\n  }\r\n\r\n  // Remove selected question from available questions\r\n  const remainingQuestions = availableQuestions.filter(q => q !== question);\r\n\r\n  return { question, remainingQuestions };\r\n}\r\n\r\n/**\r\n * Initialize adaptive quiz state\r\n * @param {Array} questions - Array of all questions\r\n * @returns {Object} Initial quiz state\r\n */\r\nexport function initializeAdaptiveQuiz(questions) {\r\n  return {\r\n    availableQuestions: [...questions],\r\n    usedQuestions: [],\r\n    consecutiveCorrect: 0,\r\n    consecutiveIncorrect: 0,\r\n    currentDifficulty: 'medium'\r\n  };\r\n}\r\n\r\n/**\r\n * Update quiz state based on user's answer\r\n * @param {Object} quizState - Current quiz state\r\n * @param {Object} response - User's response to current question\r\n * @returns {Object} Updated quiz state\r\n */\r\nexport function updateQuizState(quizState, response) {\r\n  const newState = { ...quizState };\r\n\r\n  // Update consecutive counters\r\n  if (response.correct) {\r\n    newState.consecutiveCorrect += 1;\r\n    newState.consecutiveIncorrect = 0;\r\n  } else {\r\n    newState.consecutiveIncorrect += 1;\r\n    newState.consecutiveCorrect = 0;\r\n  }\r\n\r\n  // Add response to used questions\r\n  newState.usedQuestions.push(response);\r\n\r\n  // Calculate next difficulty\r\n  newState.currentDifficulty = calculateNextDifficulty(\r\n    newState.usedQuestions,\r\n    newState.consecutiveCorrect,\r\n    newState.consecutiveIncorrect\r\n  );\r\n\r\n  return newState;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { ref, computed } from 'vue';\nimport axios from 'axios';\nimport FileErrorDisplay from './components/FileErrorDisplay.vue';\nimport QuizResults from './components/QuizResults.vue';\nimport FlashcardQuiz from './components/FlashcardQuiz.vue';\n\n// File handling state\n\nexport default {\n  __name: 'App',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const selectedFiles = ref([]);\n    const fileInput = ref(null);\n    const unsupportedFiles = ref([]);\n    const extractionErrors = ref([]);\n\n    // Quiz state\n    const questionCount = ref('');\n    const isLoading = ref(false);\n    const error = ref('');\n    const predictedScore = ref(null);\n    const quizStarted = ref(false);\n    const quizFinished = ref(false);\n    const adaptiveQuestions = ref([]);\n    const userResponses = ref([]);\n    const extractedContent = ref('');\n\n    // Computed properties\n    const isFormValid = computed(() => {\n      return selectedFiles.value.length > 0 && questionCount.value > 0;\n    });\n    const hasFileErrors = computed(() => {\n      return extractionErrors.value.length > 0 || unsupportedFiles.value.length > 0;\n    });\n    const getPredictedScoreClass = computed(() => {\n      if (predictedScore.value >= 80) return 'high';\n      if (predictedScore.value >= 60) return 'medium';\n      return 'low';\n    });\n\n    // File handling methods\n    const triggerFileInput = () => {\n      fileInput.value.click();\n    };\n    const handleFileSelect = event => {\n      const files = Array.from(event.target.files);\n      addFiles(files);\n    };\n    const handleDrop = event => {\n      const files = Array.from(event.dataTransfer.files);\n      addFiles(files);\n    };\n    const addFiles = files => {\n      const validTypes = ['application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'text/plain', 'application/pdf', 'image/png', 'image/jpeg', 'image/jpg', 'image/tiff', 'image/bmp'];\n      const validFiles = [];\n      const invalidFiles = [];\n      files.forEach(file => {\n        if (validTypes.includes(file.type)) {\n          validFiles.push(file);\n        } else {\n          invalidFiles.push(file);\n        }\n      });\n      selectedFiles.value = [...selectedFiles.value, ...validFiles];\n      unsupportedFiles.value = [...unsupportedFiles.value, ...invalidFiles];\n    };\n    const removeFile = index => {\n      selectedFiles.value.splice(index, 1);\n    };\n\n    // Quiz handling methods\n    const handleSubmit = async () => {\n      if (!isFormValid.value) return;\n      isLoading.value = true;\n      error.value = '';\n      adaptiveQuestions.value = [];\n      predictedScore.value = null;\n      quizStarted.value = false;\n      userResponses.value = [];\n      extractedContent.value = '';\n      try {\n        const fileContents = await Promise.all(selectedFiles.value.map(file => readFileContent(file)));\n        extractedContent.value = fileContents.join('\\n\\n');\n        const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n        const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n        const processedQuiz = processQuizResponse(response, extractedContent.value);\n        adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n        predictedScore.value = calculatePredictedScore();\n      } catch (err) {\n        error.value = `Error generating questions: ${err.response?.data?.error?.message || err.message}`;\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    const startQuiz = () => {\n      quizStarted.value = true;\n      quizFinished.value = false;\n    };\n    const handleQuizComplete = responses => {\n      userResponses.value = responses;\n      quizStarted.value = false;\n      quizFinished.value = true;\n    };\n    const restartQuiz = () => {\n      quizStarted.value = true;\n      quizFinished.value = false;\n      userResponses.value = [];\n    };\n    const resetToMainScreen = () => {\n      selectedFiles.value = [];\n      unsupportedFiles.value = [];\n      extractionErrors.value = [];\n      questionCount.value = '';\n      error.value = '';\n      isLoading.value = false;\n      predictedScore.value = null;\n      quizStarted.value = false;\n      quizFinished.value = false;\n      adaptiveQuestions.value = [];\n      userResponses.value = [];\n      if (fileInput.value) {\n        fileInput.value.value = '';\n      }\n    };\n\n    // Helper functions\n    async function readFileContent(file) {\n      return new Promise(resolve => {\n        if (file.type === \"application/pdf\" || file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" || file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" || file.type.startsWith('image/')) {\n          const formData = new FormData();\n          formData.append('file', file);\n          const backendUrl = process.env.VUE_APP_BACKEND_URL || 'http://localhost:5001';\n          fetch(`${backendUrl}/extract-file`, {\n            method: 'POST',\n            body: formData\n          }).then(res => res.json()).then(data => {\n            if (data.text) {\n              resolve(data.text);\n            } else {\n              extractionErrors.value.push({\n                fileName: file.name,\n                message: data.error || 'Failed to extract text from file'\n              });\n              resolve(\"[Could not extract file text]\");\n            }\n          }).catch(() => {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: 'Server error while extracting text'\n            });\n            resolve(\"[Could not extract file text]\");\n          });\n        } else if (file.type === \"text/plain\") {\n          const reader = new FileReader();\n          reader.onload = e => resolve(e.target.result);\n          reader.onerror = () => {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: 'Error reading text file'\n            });\n            resolve(\"[Could not read file]\");\n          };\n          reader.readAsText(file);\n        } else {\n          resolve(`[${file.name} is not a supported file type.]`);\n        }\n      });\n    }\n    async function generateQuestions(content, count) {\n      const prompt = `Create a quiz with ${count} COMPLETELY UNIQUE and DIVERSE questions based on this text. Each question MUST cover a different concept or aspect. NO REPETITIVE or SIMILAR questions allowed.\n\nCRITICAL REQUIREMENTS:\n1. Each explanation MUST be a direct quote or paraphrased content from the original text\n2. Explanations should reference specific parts of the text that justify the correct answer\n3. Do NOT make up explanations - they must be based on the actual content provided\n4. If a concept isn't clearly explained in the text, don't create a question about it\n5. Automatically determine appropriate difficulty (easy/medium/hard) based on:\n   - Easy: Basic facts, definitions, or simple concepts\n   - Medium: Understanding relationships between concepts\n   - Hard: Analysis, evaluation, or complex relationships\n\nFormat requirements for each question:\n\nFor multiple choice questions:\n1. Question: [unique question text]\n2. Options (mark correct with *):\n   A) [option]\n   B) [option]\n   C) [option]\n   D) [option]\n3. Explanation: [quote or paraphrase relevant text that explains the correct answer]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nFor true/false questions:\n1. True/False: [unique question text]\n2. Options (mark correct with *):\n   True\n   False\n3. Explanation: [quote or paraphrase relevant text that explains why the statement is true or false]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nIMPORTANT:\n- Each question MUST cover a different topic/concept\n- NO similar or overlapping questions\n- Make questions engaging and thought-provoking\n- Ensure clear, unambiguous wording\n- ALL explanations must come from the provided text\n- Distribute difficulties naturally based on content complexity\n\nText to base questions on:\n${content}`;\n      const response = await axios.post(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.VUE_APP_GEMINI_API_KEY}`, {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 2048\n        }\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      return response.data.candidates[0].content.parts[0].text;\n    }\n    function processQuizResponse(response, content) {\n      const questions = [];\n      const lines = response.split('\\n');\n      let currentQuestion = null;\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i.test(line)) {\n          if (currentQuestion) {\n            if (!currentQuestion.explanation) {\n              const searchText = currentQuestion.text.toLowerCase();\n              const contentParagraphs = content.split('\\n\\n');\n              for (const paragraph of contentParagraphs) {\n                if (paragraph.toLowerCase().includes(searchText)) {\n                  currentQuestion.explanation = paragraph.trim();\n                  break;\n                }\n              }\n            }\n            questions.push(currentQuestion);\n          }\n          currentQuestion = {\n            text: line.replace(/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i, '').trim(),\n            type: 'multiple-choice',\n            options: {},\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n        } else if (/^\\d*\\.?\\s*(True\\/False:|True or False:)/i.test(line)) {\n          if (currentQuestion) {\n            if (!currentQuestion.explanation) {\n              const searchText = currentQuestion.text.toLowerCase();\n              const contentParagraphs = content.split('\\n\\n');\n              for (const paragraph of contentParagraphs) {\n                if (paragraph.toLowerCase().includes(searchText)) {\n                  currentQuestion.explanation = paragraph.trim();\n                  break;\n                }\n              }\n            }\n            questions.push(currentQuestion);\n          }\n          currentQuestion = {\n            text: line.replace(/^\\d*\\.?\\s*(True\\/False:|True or False:)/i, '').trim(),\n            type: 'true-false',\n            options: {\n              'true': 'True',\n              'false': 'False'\n            },\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n        } else if (currentQuestion) {\n          const optionMatch = line.match(/^([A-Da-d])[).]\\s*(.*)/);\n          if (optionMatch && currentQuestion.type === 'multiple-choice') {\n            const letter = optionMatch[1].toUpperCase();\n            let option = optionMatch[2].replace(/\\*$/, '').trim();\n            if (option.includes('*')) {\n              currentQuestion.correctAnswer = letter;\n              option = option.replace('*', '').trim();\n            }\n            currentQuestion.options[letter] = option;\n          } else if (currentQuestion.type === 'true-false' && (line.toLowerCase().startsWith('true') || line.toLowerCase().startsWith('false'))) {\n            const answer = line.toLowerCase().trim();\n            if (answer.includes('*')) {\n              currentQuestion.correctAnswer = answer.replace('*', '').trim();\n            }\n          } else if (line.startsWith('Explanation:')) {\n            const searchText = currentQuestion.text.toLowerCase();\n            const contentParagraphs = content.split('\\n\\n');\n            for (const paragraph of contentParagraphs) {\n              if (paragraph.toLowerCase().includes(searchText)) {\n                currentQuestion.explanation = paragraph.trim();\n                break;\n              }\n            }\n            if (!currentQuestion.explanation) {\n              currentQuestion.explanation = line.replace('Explanation:', '').trim();\n            }\n          } else if (line.startsWith('Difficulty:')) {\n            const diff = line.replace('Difficulty:', '').trim().toLowerCase();\n            if (['easy', 'medium', 'hard'].includes(diff)) {\n              currentQuestion.difficulty = diff;\n            }\n          }\n        }\n      }\n      if (currentQuestion) {\n        if (!currentQuestion.explanation) {\n          const searchText = currentQuestion.text.toLowerCase();\n          const contentParagraphs = content.split('\\n\\n');\n          for (const paragraph of contentParagraphs) {\n            if (paragraph.toLowerCase().includes(searchText)) {\n              currentQuestion.explanation = paragraph.trim();\n              break;\n            }\n          }\n        }\n        questions.push(currentQuestion);\n      }\n      return {\n        questions\n      };\n    }\n    function selectQuestions(questions) {\n      const shuffledQuestions = [...questions].sort(() => Math.random() - 0.5).filter((question, index, self) => index === self.findIndex(q => q.text.toLowerCase().replace(/[^\\w\\s]/g, '') === question.text.toLowerCase().replace(/[^\\w\\s]/g, '')));\n      const selectedQuestions = [];\n      const targetPerDifficulty = Math.ceil(Number(questionCount.value) / 3);\n      const difficultyCount = {\n        easy: 0,\n        medium: 0,\n        hard: 0\n      };\n      for (const difficulty of ['easy', 'medium', 'hard']) {\n        const questionsOfDifficulty = shuffledQuestions.filter(q => q.difficulty === difficulty && !selectedQuestions.includes(q));\n        for (const question of questionsOfDifficulty) {\n          if (difficultyCount[difficulty] < targetPerDifficulty && selectedQuestions.length < Number(questionCount.value)) {\n            selectedQuestions.push(question);\n            difficultyCount[difficulty]++;\n          }\n        }\n      }\n      while (selectedQuestions.length < Number(questionCount.value)) {\n        const remainingQuestion = shuffledQuestions.find(q => !selectedQuestions.includes(q));\n        if (remainingQuestion) {\n          selectedQuestions.push(remainingQuestion);\n        } else {\n          break;\n        }\n      }\n      return selectedQuestions;\n    }\n    function calculatePredictedScore() {\n      const contentCoverage = analyzeContentForCoverage();\n      return Math.max(0, Math.min(100, Math.round(contentCoverage * 0.8)));\n    }\n    function analyzeContentForCoverage() {\n      return 100;\n    }\n    function predictScore(contentCoverage) {\n      return Math.max(0, Math.min(100, Math.round(contentCoverage * 0.8)));\n    }\n\n    // Results formatting\n    const formatQuestionsForResults = computed(() => {\n      return adaptiveQuestions.value.map((q, index) => ({\n        text: q.text,\n        type: q.type,\n        options: q.options,\n        userAnswer: userResponses.value[index]?.userAnswer,\n        correctAnswer: q.correctAnswer,\n        explanation: q.explanation,\n        isCorrect: userResponses.value[index]?.correct\n      }));\n    });\n    const formatUserAnswersForResults = computed(() => {\n      return userResponses.value.map(r => r.userAnswer);\n    });\n    const correctAnswersCount = computed(() => {\n      return userResponses.value.filter(r => r.correct).length;\n    });\n    const __returned__ = {\n      selectedFiles,\n      fileInput,\n      unsupportedFiles,\n      extractionErrors,\n      questionCount,\n      isLoading,\n      error,\n      predictedScore,\n      quizStarted,\n      quizFinished,\n      adaptiveQuestions,\n      userResponses,\n      extractedContent,\n      isFormValid,\n      hasFileErrors,\n      getPredictedScoreClass,\n      triggerFileInput,\n      handleFileSelect,\n      handleDrop,\n      addFiles,\n      removeFile,\n      handleSubmit,\n      startQuiz,\n      handleQuizComplete,\n      restartQuiz,\n      resetToMainScreen,\n      readFileContent,\n      generateQuestions,\n      processQuizResponse,\n      selectQuestions,\n      calculatePredictedScore,\n      analyzeContentForCoverage,\n      predictScore,\n      formatQuestionsForResults,\n      formatUserAnswersForResults,\n      correctAnswersCount,\n      ref,\n      computed,\n      get axios() {\n        return axios;\n      },\n      FileErrorDisplay,\n      QuizResults,\n      FlashcardQuiz\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","computed","axios","FileErrorDisplay","QuizResults","FlashcardQuiz","selectedFiles","fileInput","unsupportedFiles","extractionErrors","questionCount","isLoading","error","predictedScore","quizStarted","quizFinished","adaptiveQuestions","userResponses","extractedContent","isFormValid","value","length","hasFileErrors","getPredictedScoreClass","triggerFileInput","click","handleFileSelect","event","files","Array","from","target","addFiles","handleDrop","dataTransfer","validTypes","validFiles","invalidFiles","forEach","file","includes","type","push","removeFile","index","splice","handleSubmit","fileContents","Promise","all","map","readFileContent","join","requestedQuestionCount","Math","min","Number","response","generateQuestions","processedQuiz","processQuizResponse","selectQuestions","questions","calculatePredictedScore","err","data","message","startQuiz","handleQuizComplete","responses","restartQuiz","resetToMainScreen","resolve","startsWith","formData","FormData","append","backendUrl","process","env","VUE_APP_BACKEND_URL","fetch","method","body","then","res","json","text","fileName","name","catch","reader","FileReader","onload","e","result","onerror","readAsText","content","count","prompt","post","VUE_APP_GEMINI_API_KEY","contents","parts","generationConfig","temperature","topK","topP","maxOutputTokens","headers","candidates","lines","split","currentQuestion","i","line","trim","test","explanation","searchText","toLowerCase","contentParagraphs","paragraph","replace","options","correctAnswer","difficulty","optionMatch","match","letter","toUpperCase","option","answer","diff","shuffledQuestions","sort","random","filter","question","self","findIndex","q","selectedQuestions","targetPerDifficulty","ceil","difficultyCount","easy","medium","hard","questionsOfDifficulty","remainingQuestion","find","contentCoverage","analyzeContentForCoverage","max","round","predictScore","formatQuestionsForResults","userAnswer","isCorrect","correct","formatUserAnswersForResults","r","correctAnswersCount"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/App.vue"],"sourcesContent":["<template>\n  <div class=\"app-container\">\n    <div class=\"upload-container\">\n      <h1>QUIZZy</h1>\n      \n      <div v-if=\"!showQuestions && !quizStarted && !quizFinished && predictedScore === null\" class=\"file-upload-section\">\n        <h2>Upload Files</h2>\n        <div class=\"upload-area\" \n          @dragover.prevent \n          @drop.prevent=\"handleDrop\"\n          @click=\"triggerFileInput\"\n          role=\"button\"\n          tabindex=\"0\"\n          @keydown.enter=\"triggerFileInput\"\n        >\n          <input \n            type=\"file\" \n            @change=\"handleFileSelect\" \n            accept=\".pdf,.docx,.pptx,.txt,.png,.jpg,.jpeg,.tiff,.bmp\"\n            ref=\"fileInput\"\n            class=\"file-input\"\n          >\n          <div class=\"upload-prompt\">\n            <p>Drag and drop files here or click to select</p>\n            <div class=\"supported-formats\">\n              <p>Supported formats:</p>\n              <ul>\n                <li><span class=\"format-icon\">📄</span> Documents (PDF, DOCX)</li>\n                <li><span class=\"format-icon\">📊</span> Presentations (PPTX)</li>\n                <li><span class=\"format-icon\">📝</span> Text files (TXT)</li>\n              </ul>\n            </div>\n          </div>\n        </div>\n        \n        <div v-if=\"hasFileErrors\" class=\"error-section\">\n          <FileErrorDisplay\n            :extraction-errors=\"extractionErrors\"\n            :unsupported-files=\"unsupportedFiles\"\n          />\n        </div>\n\n        <div v-if=\"selectedFiles.length > 0\" class=\"selected-files\">\n          <h3>Selected Files:</h3>\n          <ul>\n            <li v-for=\"(file, index) in selectedFiles\" :key=\"index\" class=\"file-item\">\n              <span class=\"file-name\">{{ file.name }}</span>\n              <button @click=\"removeFile(index)\" class=\"remove-btn\" title=\"Remove file\">×</button>\n            </li>\n          </ul>\n        </div>\n\n        <div class=\"questions-section\">\n          <h2>Number of Questions</h2>\n          <div class=\"question-input\">\n            <input\n              type=\"number\"\n              v-model=\"questionCount\"\n              min=\"1\"\n              max=\"20\"\n              placeholder=\"Enter number of questions\"\n            />\n          </div>\n        </div>\n\n        <button \n          class=\"submit-btn\" \n          :disabled=\"!isFormValid || isLoading\"\n          @click=\"handleSubmit\"\n        >\n          {{ isLoading ? 'Generating Questions...' : 'Submit' }}\n        </button>\n      </div>\n\n      <div v-if=\"predictedScore !== null && !quizStarted && !quizFinished\">\n        <div class=\"predicted-score-container\">\n          <h2>Ready to Start!</h2>\n          <div class=\"score-prediction\">\n            <div class=\"score-circle\" :class=\"getPredictedScoreClass\">\n              <span class=\"predicted-value\">{{ predictedScore }}%</span>\n              <span class=\"prediction-label\">Predicted Score</span>\n            </div>\n          </div>\n          <p class=\"prediction-explanation\">\n            Based on your study material, we predict you'll score around {{ predictedScore }}%.\n          </p>\n          <button class=\"start-quiz-btn\" @click=\"startQuiz\">Start Quiz</button>\n        </div>\n      </div>\n\n      <FlashcardQuiz\n        v-if=\"quizStarted && !quizFinished\"\n        :questions=\"adaptiveQuestions\"\n        :total-questions=\"Number(questionCount)\"\n        @quiz-completed=\"handleQuizComplete\"\n      />\n\n      <QuizResults\n        v-if=\"quizFinished\"\n        :questions=\"formatQuestionsForResults\"\n        :user-answers=\"formatUserAnswersForResults\"\n        :score=\"correctAnswersCount\"\n        :predicted-score=\"predictedScore\"\n        @restart=\"restartQuiz\"\n        @go-back=\"resetToMainScreen\"\n      />\n\n      <div v-if=\"error\" class=\"error-message\">\n        {{ error }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue';\nimport axios from 'axios';\nimport FileErrorDisplay from './components/FileErrorDisplay.vue';\nimport QuizResults from './components/QuizResults.vue';\nimport FlashcardQuiz from './components/FlashcardQuiz.vue';\n\n// File handling state\nconst selectedFiles = ref([]);\nconst fileInput = ref(null);\nconst unsupportedFiles = ref([]);\nconst extractionErrors = ref([]);\n\n// Quiz state\nconst questionCount = ref('');\nconst isLoading = ref(false);\nconst error = ref('');\nconst predictedScore = ref(null);\nconst quizStarted = ref(false);\nconst quizFinished = ref(false);\nconst adaptiveQuestions = ref([]);\nconst userResponses = ref([]);\nconst extractedContent = ref('');\n\n// Computed properties\nconst isFormValid = computed(() => {\n  return selectedFiles.value.length > 0 && questionCount.value > 0;\n});\n\nconst hasFileErrors = computed(() => {\n  return extractionErrors.value.length > 0 || unsupportedFiles.value.length > 0;\n});\n\nconst getPredictedScoreClass = computed(() => {\n  if (predictedScore.value >= 80) return 'high';\n  if (predictedScore.value >= 60) return 'medium';\n  return 'low';\n});\n\n// File handling methods\nconst triggerFileInput = () => {\n  fileInput.value.click();\n};\n\nconst handleFileSelect = (event) => {\n  const files = Array.from(event.target.files);\n  addFiles(files);\n};\n\nconst handleDrop = (event) => {\n  const files = Array.from(event.dataTransfer.files);\n  addFiles(files);\n};\n\nconst addFiles = (files) => {\n  const validTypes = [\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/vnd.ms-powerpoint',\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n    'text/plain',\n    'application/pdf',\n    'image/png',\n    'image/jpeg',\n    'image/jpg',\n    'image/tiff',\n    'image/bmp'\n  ];\n  \n  const validFiles = [];\n  const invalidFiles = [];\n  \n  files.forEach(file => {\n    if (validTypes.includes(file.type)) {\n      validFiles.push(file);\n    } else {\n      invalidFiles.push(file);\n    }\n  });\n  \n  selectedFiles.value = [...selectedFiles.value, ...validFiles];\n  unsupportedFiles.value = [...unsupportedFiles.value, ...invalidFiles];\n};\n\nconst removeFile = (index) => {\n  selectedFiles.value.splice(index, 1);\n};\n\n// Quiz handling methods\nconst handleSubmit = async () => {\n  if (!isFormValid.value) return;\n\n  isLoading.value = true;\n  error.value = '';\n  adaptiveQuestions.value = [];\n  predictedScore.value = null;\n  quizStarted.value = false;\n  userResponses.value = [];\n  extractedContent.value = '';\n\n  try {\n    const fileContents = await Promise.all(\n      selectedFiles.value.map(file => readFileContent(file))\n    );\n\n    extractedContent.value = fileContents.join('\\n\\n');\n    const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n    \n    const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n    const processedQuiz = processQuizResponse(response, extractedContent.value);\n    \n    adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n    predictedScore.value = calculatePredictedScore();\n\n  } catch (err) {\n    error.value = `Error generating questions: ${err.response?.data?.error?.message || err.message}`;\n  } finally {\n    isLoading.value = false;\n  }\n};\n\nconst startQuiz = () => {\n  quizStarted.value = true;\n  quizFinished.value = false;\n};\n\nconst handleQuizComplete = (responses) => {\n  userResponses.value = responses;\n  quizStarted.value = false;\n  quizFinished.value = true;\n};\n\nconst restartQuiz = () => {\n  quizStarted.value = true;\n  quizFinished.value = false;\n  userResponses.value = [];\n};\n\nconst resetToMainScreen = () => {\n  selectedFiles.value = [];\n  unsupportedFiles.value = [];\n  extractionErrors.value = [];\n  questionCount.value = '';\n  error.value = '';\n  isLoading.value = false;\n  predictedScore.value = null;\n  quizStarted.value = false;\n  quizFinished.value = false;\n  adaptiveQuestions.value = [];\n  userResponses.value = [];\n  if (fileInput.value) {\n    fileInput.value.value = '';\n  }\n};\n\n// Helper functions\nasync function readFileContent(file) {\n  return new Promise((resolve) => {\n    if (\n      file.type === \"application/pdf\" ||\n      file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" ||\n      file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" ||\n      file.type.startsWith('image/')\n    ) {\n      const formData = new FormData();\n      formData.append('file', file);\n      \n      const backendUrl = process.env.VUE_APP_BACKEND_URL || 'http://localhost:5001';\n      fetch(`${backendUrl}/extract-file`, {\n        method: 'POST',\n        body: formData\n      })\n        .then(res => res.json())\n        .then(data => {\n          if (data.text) {\n            resolve(data.text);\n          } else {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: data.error || 'Failed to extract text from file'\n            });\n            resolve(\"[Could not extract file text]\");\n          }\n        })\n        .catch(() => {\n          extractionErrors.value.push({\n            fileName: file.name,\n            message: 'Server error while extracting text'\n          });\n          resolve(\"[Could not extract file text]\");\n        });\n    } else if (file.type === \"text/plain\") {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target.result);\n      reader.onerror = () => {\n        extractionErrors.value.push({\n          fileName: file.name,\n          message: 'Error reading text file'\n        });\n        resolve(\"[Could not read file]\");\n      };\n      reader.readAsText(file);\n    } else {\n      resolve(`[${file.name} is not a supported file type.]`);\n    }\n  });\n}\n\nasync function generateQuestions(content, count) {\n  const prompt = `Create a quiz with ${count} COMPLETELY UNIQUE and DIVERSE questions based on this text. Each question MUST cover a different concept or aspect. NO REPETITIVE or SIMILAR questions allowed.\n\nCRITICAL REQUIREMENTS:\n1. Each explanation MUST be a direct quote or paraphrased content from the original text\n2. Explanations should reference specific parts of the text that justify the correct answer\n3. Do NOT make up explanations - they must be based on the actual content provided\n4. If a concept isn't clearly explained in the text, don't create a question about it\n5. Automatically determine appropriate difficulty (easy/medium/hard) based on:\n   - Easy: Basic facts, definitions, or simple concepts\n   - Medium: Understanding relationships between concepts\n   - Hard: Analysis, evaluation, or complex relationships\n\nFormat requirements for each question:\n\nFor multiple choice questions:\n1. Question: [unique question text]\n2. Options (mark correct with *):\n   A) [option]\n   B) [option]\n   C) [option]\n   D) [option]\n3. Explanation: [quote or paraphrase relevant text that explains the correct answer]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nFor true/false questions:\n1. True/False: [unique question text]\n2. Options (mark correct with *):\n   True\n   False\n3. Explanation: [quote or paraphrase relevant text that explains why the statement is true or false]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nIMPORTANT:\n- Each question MUST cover a different topic/concept\n- NO similar or overlapping questions\n- Make questions engaging and thought-provoking\n- Ensure clear, unambiguous wording\n- ALL explanations must come from the provided text\n- Distribute difficulties naturally based on content complexity\n\nText to base questions on:\n${content}`;\n\n  const response = await axios.post(\n    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.VUE_APP_GEMINI_API_KEY}`,\n    {\n      contents: [{\n        parts: [{\n          text: prompt\n        }]\n      }],\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 2048,\n      }\n    },\n    {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }\n  );\n\n  return response.data.candidates[0].content.parts[0].text;\n}\n\nfunction processQuizResponse(response, content) {\n  const questions = [];\n  const lines = response.split('\\n');\n  let currentQuestion = null;\n  \n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    \n    if (/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i.test(line)) {\n      if (currentQuestion) {\n        if (!currentQuestion.explanation) {\n          const searchText = currentQuestion.text.toLowerCase();\n          const contentParagraphs = content.split('\\n\\n');\n          for (const paragraph of contentParagraphs) {\n            if (paragraph.toLowerCase().includes(searchText)) {\n              currentQuestion.explanation = paragraph.trim();\n              break;\n            }\n          }\n        }\n        questions.push(currentQuestion);\n      }\n      currentQuestion = {\n        text: line.replace(/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i, '').trim(),\n        type: 'multiple-choice',\n        options: {},\n        correctAnswer: '',\n        explanation: '',\n        difficulty: 'medium'\n      };\n    } else if (/^\\d*\\.?\\s*(True\\/False:|True or False:)/i.test(line)) {\n      if (currentQuestion) {\n        if (!currentQuestion.explanation) {\n          const searchText = currentQuestion.text.toLowerCase();\n          const contentParagraphs = content.split('\\n\\n');\n          for (const paragraph of contentParagraphs) {\n            if (paragraph.toLowerCase().includes(searchText)) {\n              currentQuestion.explanation = paragraph.trim();\n              break;\n            }\n          }\n        }\n        questions.push(currentQuestion);\n      }\n      currentQuestion = {\n        text: line.replace(/^\\d*\\.?\\s*(True\\/False:|True or False:)/i, '').trim(),\n        type: 'true-false',\n        options: { \n          'true': 'True',\n          'false': 'False'\n        },\n        correctAnswer: '',\n        explanation: '',\n        difficulty: 'medium'\n      };\n    } else if (currentQuestion) {\n      const optionMatch = line.match(/^([A-Da-d])[).]\\s*(.*)/);\n      if (optionMatch && currentQuestion.type === 'multiple-choice') {\n        const letter = optionMatch[1].toUpperCase();\n        let option = optionMatch[2].replace(/\\*$/, '').trim();\n        if (option.includes('*')) {\n          currentQuestion.correctAnswer = letter;\n          option = option.replace('*', '').trim();\n        }\n        currentQuestion.options[letter] = option;\n      } else if (currentQuestion.type === 'true-false' && (line.toLowerCase().startsWith('true') || line.toLowerCase().startsWith('false'))) {\n        const answer = line.toLowerCase().trim();\n        if (answer.includes('*')) {\n          currentQuestion.correctAnswer = answer.replace('*', '').trim();\n        }\n      } else if (line.startsWith('Explanation:')) {\n        const searchText = currentQuestion.text.toLowerCase();\n        const contentParagraphs = content.split('\\n\\n');\n        for (const paragraph of contentParagraphs) {\n          if (paragraph.toLowerCase().includes(searchText)) {\n            currentQuestion.explanation = paragraph.trim();\n            break;\n          }\n        }\n        if (!currentQuestion.explanation) {\n          currentQuestion.explanation = line.replace('Explanation:', '').trim();\n        }\n      } else if (line.startsWith('Difficulty:')) {\n        const diff = line.replace('Difficulty:', '').trim().toLowerCase();\n        if (['easy', 'medium', 'hard'].includes(diff)) {\n          currentQuestion.difficulty = diff;\n        }\n      }\n    }\n  }\n  \n  if (currentQuestion) {\n    if (!currentQuestion.explanation) {\n      const searchText = currentQuestion.text.toLowerCase();\n      const contentParagraphs = content.split('\\n\\n');\n      for (const paragraph of contentParagraphs) {\n        if (paragraph.toLowerCase().includes(searchText)) {\n          currentQuestion.explanation = paragraph.trim();\n          break;\n        }\n      }\n    }\n    questions.push(currentQuestion);\n  }\n  \n  return { questions };\n}\n\nfunction selectQuestions(questions) {\n  const shuffledQuestions = [...questions]\n    .sort(() => Math.random() - 0.5)\n    .filter((question, index, self) => \n      index === self.findIndex((q) => \n        q.text.toLowerCase().replace(/[^\\w\\s]/g, '') === \n        question.text.toLowerCase().replace(/[^\\w\\s]/g, '')\n      )\n    );\n\n  const selectedQuestions = [];\n  const targetPerDifficulty = Math.ceil(Number(questionCount.value) / 3);\n  const difficultyCount = { easy: 0, medium: 0, hard: 0 };\n\n  for (const difficulty of ['easy', 'medium', 'hard']) {\n    const questionsOfDifficulty = shuffledQuestions.filter(q => \n      q.difficulty === difficulty && !selectedQuestions.includes(q)\n    );\n    \n    for (const question of questionsOfDifficulty) {\n      if (difficultyCount[difficulty] < targetPerDifficulty && \n          selectedQuestions.length < Number(questionCount.value)) {\n        selectedQuestions.push(question);\n        difficultyCount[difficulty]++;\n      }\n    }\n  }\n\n  while (selectedQuestions.length < Number(questionCount.value)) {\n    const remainingQuestion = shuffledQuestions.find(q => !selectedQuestions.includes(q));\n    if (remainingQuestion) {\n      selectedQuestions.push(remainingQuestion);\n    } else {\n      break;\n    }\n  }\n\n  return selectedQuestions;\n}\n\nfunction calculatePredictedScore() {\n  const contentCoverage = analyzeContentForCoverage();\n  return Math.max(0, Math.min(100, Math.round(contentCoverage * 0.8)));\n}\n\nfunction analyzeContentForCoverage() {\n  return 100;\n}\n\nfunction predictScore(contentCoverage) {\n  return Math.max(0, Math.min(100, Math.round(contentCoverage * 0.8)));\n}\n\n// Results formatting\nconst formatQuestionsForResults = computed(() => {\n  return adaptiveQuestions.value.map((q, index) => ({\n    text: q.text,\n    type: q.type,\n    options: q.options,\n    userAnswer: userResponses.value[index]?.userAnswer,\n    correctAnswer: q.correctAnswer,\n    explanation: q.explanation,\n    isCorrect: userResponses.value[index]?.correct\n  }));\n});\n\nconst formatUserAnswersForResults = computed(() => {\n  return userResponses.value.map(r => r.userAnswer);\n});\n\nconst correctAnswersCount = computed(() => {\n  return userResponses.value.filter(r => r.correct).length;\n});\n</script>\n\n<style scoped>\n.app-container {\n  min-height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: #f5f5f5;\n  font-family: \"Helvetica\", \"Arial\", sans-serif;\n}\n\n.upload-container {\n  background-color: white;\n  padding: 2rem;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 90%;\n  max-width: 600px;\n}\n\nh1 {\n  text-align: center;\n  color: #333;\n  margin-bottom: 2rem;\n}\n\nh2 {\n  color: #444;\n  margin-bottom: 1rem;\n}\n\n.file-upload-section {\n  margin-bottom: 2rem;\n}\n\n.upload-area {\n  border: 2px dashed #ccc;\n  border-radius: 8px;\n  padding: 2rem;\n  text-align: center;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  margin-bottom: 1rem;\n  outline: none;\n}\n\n.upload-area:hover {\n  border-color: #666;\n  background-color: #f8f8f8;\n}\n\n.upload-area:focus {\n  border-color: #4CAF50;\n  box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\n}\n\n.file-input {\n  display: none;\n}\n\n.upload-prompt {\n  color: #666;\n}\n\n.upload-prompt p {\n  margin: 0.5rem 0;\n}\n\n.selected-files {\n  margin-top: 1rem;\n}\n\n.selected-files ul {\n  list-style: none;\n  padding: 0;\n}\n\n.selected-files li {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.5rem;\n  background-color: #f8f8f8;\n  margin-bottom: 0.5rem;\n  border-radius: 4px;\n}\n\n.remove-btn {\n  background: none;\n  border: none;\n  color: #ff4444;\n  cursor: pointer;\n  font-size: 1.2rem;\n  padding: 0 0.5rem;\n}\n\n.questions-section {\n  margin-top: 2rem;\n}\n\n.question-input input {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-size: 1rem;\n}\n\n.submit-btn {\n  width: 100%;\n  padding: 1rem;\n  background-color: #4CAF50;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  font-size: 1rem;\n  cursor: pointer;\n  margin-top: 2rem;\n  transition: background-color 0.3s;\n}\n\n.submit-btn:disabled {\n  background-color: #cccccc;\n  cursor: not-allowed;\n}\n\n.submit-btn:not(:disabled):hover {\n  background-color: #45a049;\n}\n\n.questions-list {\n  margin-top: 2rem;\n  padding: 1rem;\n  background-color: #f8f8f8;\n  border-radius: 4px;\n}\n\n.question-item {\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: white;\n  border-radius: 4px;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n.error-message {\n  color: #ff4444;\n  margin-top: 1rem;\n  text-align: center;\n}\n\n.quiz-container {\n  margin-top: 2rem;\n  padding: 2rem;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.question {\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: #f8f8f8;\n  border-radius: 4px;\n}\n\n.options {\n  display: flex;\n  flex-direction: column;\n  gap: 0.8rem;\n  margin: 1.5rem 0;\n}\n\n.options.true-false {\n  flex-direction: row;\n  justify-content: center;\n  gap: 1.5rem;\n}\n\n.option-btn {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  padding: 1rem;\n  border: 2px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: white;\n  color: #333;\n  cursor: pointer;\n  font-size: 1rem;\n  text-align: left;\n  transition: all 0.2s ease;\n}\n\n.options.true-false .option-btn {\n  width: auto;\n  min-width: 120px;\n  justify-content: center;\n  font-size: 1.1rem;\n  font-weight: 500;\n}\n\n.option-letter {\n  background-color: #f5f5f5;\n  color: #666;\n  width: 30px;\n  height: 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 50%;\n  margin-right: 1rem;\n  font-weight: 600;\n}\n\n.option-text {\n  flex: 1;\n}\n\n.option-btn:hover:not(:disabled) {\n  border-color: #2196F3;\n  background-color: #f8f9fa;\n}\n\n.option-btn.selected {\n  border-color: #2196F3;\n  background-color: #e3f2fd;\n}\n\n.option-btn.correct {\n  border-color: #4CAF50;\n  background-color: #E8F5E9;\n  color: #2E7D32;\n}\n\n.option-btn.incorrect {\n  border-color: #f44336;\n  background-color: #FFEBEE;\n  color: #c62828;\n}\n\n.feedback {\n  margin-top: 1.5rem;\n  text-align: center;\n}\n\n.correct-text {\n  color: #4CAF50;\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0.5rem 0;\n}\n\n.incorrect-text {\n  color: #f44336;\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0.5rem 0;\n}\n\n.next-btn {\n  background-color: #2196F3;\n  color: white;\n  border: none;\n  padding: 0.8rem 2rem;\n  border-radius: 25px;\n  cursor: pointer;\n  font-size: 1rem;\n  margin-top: 1rem;\n  transition: all 0.2s ease;\n}\n\n.next-btn:hover {\n  background-color: #1976D2;\n  transform: translateY(-1px);\n}\n\n.quiz-progress {\n  margin-bottom: 2rem;\n}\n\n.progress-bar {\n  width: 100%;\n  height: 8px;\n  background-color: #e0e0e0;\n  border-radius: 4px;\n  overflow: hidden;\n  margin-bottom: 0.5rem;\n}\n\n.progress-fill {\n  height: 100%;\n  background-color: #4CAF50;\n  transition: width 0.3s ease;\n}\n\n.progress-text {\n  display: block;\n  text-align: center;\n  color: #666;\n  font-size: 0.9rem;\n}\n\n.next-btn {\n  width: auto;\n  min-width: 150px;\n  margin-top: 1rem;\n}\n\n.quiz-results {\n  padding: 2rem;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.score-summary {\n  text-align: center;\n  margin-bottom: 2rem;\n  padding: 1rem;\n  background-color: #f5f5f5;\n  border-radius: 8px;\n}\n\n.questions-review {\n  margin-top: 2rem;\n}\n\n.question-review {\n  margin-bottom: 2rem;\n  padding: 1rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: #fff;\n}\n\n.question-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid #e0e0e0;\n}\n\n.question-number {\n  font-weight: bold;\n  color: #666;\n}\n\n.answer-status {\n  padding: 0.25rem 0.75rem;\n  border-radius: 4px;\n  font-weight: bold;\n}\n\n.answer-status.correct {\n  background-color: #E8F5E9;\n  color: #2E7D32;\n}\n\n.answer-status.incorrect {\n  background-color: #FFEBEE;\n  color: #C62828;\n}\n\n.question-text {\n  font-size: 1.1rem;\n  margin-bottom: 1rem;\n  color: #333;\n}\n\n.answer-details {\n  background-color: #f8f9fa;\n  padding: 1rem;\n  border-radius: 4px;\n}\n\n.your-answer, .correct-answer {\n  margin-bottom: 0.5rem;\n}\n\n.question-explanation {\n  margin-top: 1rem;\n  padding-top: 1rem;\n  border-top: 1px solid #e0e0e0;\n}\n\n.explanation-text {\n  margin-top: 1rem;\n  padding: 1rem;\n  background-color: #f8f9fa;\n  border-left: 3px solid #2196F3;\n  border-radius: 4px;\n  color: #333;\n  font-size: 0.95rem;\n  line-height: 1.5;\n}\n\n.explanation-text p {\n  margin: 0.5rem 0;\n}\n\n.explanation-text strong {\n  color: #2196F3;\n}\n\n.supported-formats {\n  margin-top: 1rem;\n  text-align: left;\n  display: inline-block;\n}\n\n.supported-formats ul {\n  list-style: none;\n  padding: 0;\n  margin: 0.5rem 0;\n}\n\n.supported-formats li {\n  margin: 0.3rem 0;\n  color: #555;\n}\n\n.format-icon {\n  margin-right: 0.5rem;\n}\n\n.predicted-score-container {\n  text-align: center;\n  padding: 2rem;\n  background-color: #fff;\n  border-radius: 12px;\n  box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n}\n\n.score-prediction {\n  margin: 2rem 0;\n}\n\n.score-circle {\n  width: 180px;\n  height: 180px;\n  border-radius: 50%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin: 0 auto;\n  transition: all 0.3s ease;\n}\n\n.score-circle.high {\n  background-color: #e8f5e9;\n  border: 4px solid #4CAF50;\n}\n\n.score-circle.medium {\n  background-color: #fff3e0;\n  border: 4px solid #ff9800;\n}\n\n.score-circle.low {\n  background-color: #ffebee;\n  border: 4px solid #f44336;\n}\n\n.predicted-value {\n  font-size: 3rem;\n  font-weight: bold;\n  line-height: 1;\n  margin-bottom: 0.5rem;\n}\n\n.prediction-label {\n  font-size: 1rem;\n  opacity: 0.8;\n}\n\n.prediction-explanation {\n  color: #666;\n  margin: 1.5rem 0;\n  font-size: 1.1rem;\n  line-height: 1.5;\n}\n\n.start-quiz-btn {\n  background-color: #2196F3;\n  color: white;\n  padding: 1rem 2.5rem;\n  border: none;\n  border-radius: 25px;\n  font-size: 1.2rem;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);\n}\n\n.start-quiz-btn:hover {\n  background-color: #1976D2;\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(33, 150, 243, 0.4);\n}\n</style> "],"mappings":"AAmHA,SAASA,GAAG,EAAEC,QAAQ,QAAQ,KAAK;AACnC,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,gBAAgB,MAAM,mCAAmC;AAChE,OAAOC,WAAW,MAAM,8BAA8B;AACtD,OAAOC,aAAa,MAAM,gCAAgC;;AAE1D;;;;;;;;IACA,MAAMC,aAAa,GAAGN,GAAG,CAAC,EAAE,CAAC;IAC7B,MAAMO,SAAS,GAAGP,GAAG,CAAC,IAAI,CAAC;IAC3B,MAAMQ,gBAAgB,GAAGR,GAAG,CAAC,EAAE,CAAC;IAChC,MAAMS,gBAAgB,GAAGT,GAAG,CAAC,EAAE,CAAC;;IAEhC;IACA,MAAMU,aAAa,GAAGV,GAAG,CAAC,EAAE,CAAC;IAC7B,MAAMW,SAAS,GAAGX,GAAG,CAAC,KAAK,CAAC;IAC5B,MAAMY,KAAK,GAAGZ,GAAG,CAAC,EAAE,CAAC;IACrB,MAAMa,cAAc,GAAGb,GAAG,CAAC,IAAI,CAAC;IAChC,MAAMc,WAAW,GAAGd,GAAG,CAAC,KAAK,CAAC;IAC9B,MAAMe,YAAY,GAAGf,GAAG,CAAC,KAAK,CAAC;IAC/B,MAAMgB,iBAAiB,GAAGhB,GAAG,CAAC,EAAE,CAAC;IACjC,MAAMiB,aAAa,GAAGjB,GAAG,CAAC,EAAE,CAAC;IAC7B,MAAMkB,gBAAgB,GAAGlB,GAAG,CAAC,EAAE,CAAC;;IAEhC;IACA,MAAMmB,WAAW,GAAGlB,QAAQ,CAAC,MAAM;MACjC,OAAOK,aAAa,CAACc,KAAK,CAACC,MAAM,GAAG,CAAC,IAAIX,aAAa,CAACU,KAAK,GAAG,CAAC;IAClE,CAAC,CAAC;IAEF,MAAME,aAAa,GAAGrB,QAAQ,CAAC,MAAM;MACnC,OAAOQ,gBAAgB,CAACW,KAAK,CAACC,MAAM,GAAG,CAAC,IAAIb,gBAAgB,CAACY,KAAK,CAACC,MAAM,GAAG,CAAC;IAC/E,CAAC,CAAC;IAEF,MAAME,sBAAsB,GAAGtB,QAAQ,CAAC,MAAM;MAC5C,IAAIY,cAAc,CAACO,KAAK,IAAI,EAAE,EAAE,OAAO,MAAM;MAC7C,IAAIP,cAAc,CAACO,KAAK,IAAI,EAAE,EAAE,OAAO,QAAQ;MAC/C,OAAO,KAAK;IACd,CAAC,CAAC;;IAEF;IACA,MAAMI,gBAAgB,GAAGA,CAAA,KAAM;MAC7BjB,SAAS,CAACa,KAAK,CAACK,KAAK,CAAC,CAAC;IACzB,CAAC;IAED,MAAMC,gBAAgB,GAAIC,KAAK,IAAK;MAClC,MAAMC,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACH,KAAK,CAACI,MAAM,CAACH,KAAK,CAAC;MAC5CI,QAAQ,CAACJ,KAAK,CAAC;IACjB,CAAC;IAED,MAAMK,UAAU,GAAIN,KAAK,IAAK;MAC5B,MAAMC,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACH,KAAK,CAACO,YAAY,CAACN,KAAK,CAAC;MAClDI,QAAQ,CAACJ,KAAK,CAAC;IACjB,CAAC;IAED,MAAMI,QAAQ,GAAIJ,KAAK,IAAK;MAC1B,MAAMO,UAAU,GAAG,CACjB,oBAAoB,EACpB,yEAAyE,EACzE,+BAA+B,EAC/B,2EAA2E,EAC3E,YAAY,EACZ,iBAAiB,EACjB,WAAW,EACX,YAAY,EACZ,WAAW,EACX,YAAY,EACZ,WAAU,CACX;MAED,MAAMC,UAAU,GAAG,EAAE;MACrB,MAAMC,YAAY,GAAG,EAAE;MAEvBT,KAAK,CAACU,OAAO,CAACC,IAAI,IAAI;QACpB,IAAIJ,UAAU,CAACK,QAAQ,CAACD,IAAI,CAACE,IAAI,CAAC,EAAE;UAClCL,UAAU,CAACM,IAAI,CAACH,IAAI,CAAC;QACvB,CAAC,MAAM;UACLF,YAAY,CAACK,IAAI,CAACH,IAAI,CAAC;QACzB;MACF,CAAC,CAAC;MAEFjC,aAAa,CAACc,KAAK,GAAG,CAAC,GAAGd,aAAa,CAACc,KAAK,EAAE,GAAGgB,UAAU,CAAC;MAC7D5B,gBAAgB,CAACY,KAAK,GAAG,CAAC,GAAGZ,gBAAgB,CAACY,KAAK,EAAE,GAAGiB,YAAY,CAAC;IACvE,CAAC;IAED,MAAMM,UAAU,GAAIC,KAAK,IAAK;MAC5BtC,aAAa,CAACc,KAAK,CAACyB,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IACtC,CAAC;;IAED;IACA,MAAME,YAAY,GAAG,MAAAA,CAAA,KAAY;MAC/B,IAAI,CAAC3B,WAAW,CAACC,KAAK,EAAE;MAExBT,SAAS,CAACS,KAAK,GAAG,IAAI;MACtBR,KAAK,CAACQ,KAAK,GAAG,EAAE;MAChBJ,iBAAiB,CAACI,KAAK,GAAG,EAAE;MAC5BP,cAAc,CAACO,KAAK,GAAG,IAAI;MAC3BN,WAAW,CAACM,KAAK,GAAG,KAAK;MACzBH,aAAa,CAACG,KAAK,GAAG,EAAE;MACxBF,gBAAgB,CAACE,KAAK,GAAG,EAAE;MAE3B,IAAI;QACF,MAAM2B,YAAY,GAAG,MAAMC,OAAO,CAACC,GAAG,CACpC3C,aAAa,CAACc,KAAK,CAAC8B,GAAG,CAACX,IAAI,IAAIY,eAAe,CAACZ,IAAI,CAAC,CACvD,CAAC;QAEDrB,gBAAgB,CAACE,KAAK,GAAG2B,YAAY,CAACK,IAAI,CAAC,MAAM,CAAC;QAClD,MAAMC,sBAAsB,GAAGC,IAAI,CAACC,GAAG,CAACC,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;QAE5E,MAAMqC,QAAQ,GAAG,MAAMC,iBAAiB,CAACxC,gBAAgB,CAACE,KAAK,EAAEiC,sBAAsB,CAAC;QACxF,MAAMM,aAAa,GAAGC,mBAAmB,CAACH,QAAQ,EAAEvC,gBAAgB,CAACE,KAAK,CAAC;QAE3EJ,iBAAiB,CAACI,KAAK,GAAGyC,eAAe,CAACF,aAAa,CAACG,SAAS,CAAC;QAClEjD,cAAc,CAACO,KAAK,GAAG2C,uBAAuB,CAAC,CAAC;MAElD,CAAC,CAAC,OAAOC,GAAG,EAAE;QACZpD,KAAK,CAACQ,KAAK,GAAG,+BAA+B4C,GAAG,CAACP,QAAQ,EAAEQ,IAAI,EAAErD,KAAK,EAAEsD,OAAO,IAAIF,GAAG,CAACE,OAAO,EAAE;MAClG,CAAC,SAAS;QACRvD,SAAS,CAACS,KAAK,GAAG,KAAK;MACzB;IACF,CAAC;IAED,MAAM+C,SAAS,GAAGA,CAAA,KAAM;MACtBrD,WAAW,CAACM,KAAK,GAAG,IAAI;MACxBL,YAAY,CAACK,KAAK,GAAG,KAAK;IAC5B,CAAC;IAED,MAAMgD,kBAAkB,GAAIC,SAAS,IAAK;MACxCpD,aAAa,CAACG,KAAK,GAAGiD,SAAS;MAC/BvD,WAAW,CAACM,KAAK,GAAG,KAAK;MACzBL,YAAY,CAACK,KAAK,GAAG,IAAI;IAC3B,CAAC;IAED,MAAMkD,WAAW,GAAGA,CAAA,KAAM;MACxBxD,WAAW,CAACM,KAAK,GAAG,IAAI;MACxBL,YAAY,CAACK,KAAK,GAAG,KAAK;MAC1BH,aAAa,CAACG,KAAK,GAAG,EAAE;IAC1B,CAAC;IAED,MAAMmD,iBAAiB,GAAGA,CAAA,KAAM;MAC9BjE,aAAa,CAACc,KAAK,GAAG,EAAE;MACxBZ,gBAAgB,CAACY,KAAK,GAAG,EAAE;MAC3BX,gBAAgB,CAACW,KAAK,GAAG,EAAE;MAC3BV,aAAa,CAACU,KAAK,GAAG,EAAE;MACxBR,KAAK,CAACQ,KAAK,GAAG,EAAE;MAChBT,SAAS,CAACS,KAAK,GAAG,KAAK;MACvBP,cAAc,CAACO,KAAK,GAAG,IAAI;MAC3BN,WAAW,CAACM,KAAK,GAAG,KAAK;MACzBL,YAAY,CAACK,KAAK,GAAG,KAAK;MAC1BJ,iBAAiB,CAACI,KAAK,GAAG,EAAE;MAC5BH,aAAa,CAACG,KAAK,GAAG,EAAE;MACxB,IAAIb,SAAS,CAACa,KAAK,EAAE;QACnBb,SAAS,CAACa,KAAK,CAACA,KAAK,GAAG,EAAE;MAC5B;IACF,CAAC;;IAED;IACA,eAAe+B,eAAeA,CAACZ,IAAI,EAAE;MACnC,OAAO,IAAIS,OAAO,CAAEwB,OAAO,IAAK;QAC9B,IACEjC,IAAI,CAACE,IAAI,KAAK,iBAAiB,IAC/BF,IAAI,CAACE,IAAI,KAAK,2EAA2E,IACzFF,IAAI,CAACE,IAAI,KAAK,yEAAyE,IACvFF,IAAI,CAACE,IAAI,CAACgC,UAAU,CAAC,QAAQ,GAC7B;UACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;UAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAErC,IAAI,CAAC;UAE7B,MAAMsC,UAAU,GAAGC,OAAO,CAACC,GAAG,CAACC,mBAAmB,IAAI,uBAAuB;UAC7EC,KAAK,CAAC,GAAGJ,UAAU,eAAe,EAAE;YAClCK,MAAM,EAAE,MAAM;YACdC,IAAI,EAAET;UACR,CAAC,EACEU,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,IAAI,CAAC,CAAC,EACtBF,IAAI,CAACnB,IAAI,IAAI;YACZ,IAAIA,IAAI,CAACsB,IAAI,EAAE;cACbf,OAAO,CAACP,IAAI,CAACsB,IAAI,CAAC;YACpB,CAAC,MAAM;cACL9E,gBAAgB,CAACW,KAAK,CAACsB,IAAI,CAAC;gBAC1B8C,QAAQ,EAAEjD,IAAI,CAACkD,IAAI;gBACnBvB,OAAO,EAAED,IAAI,CAACrD,KAAK,IAAI;cACzB,CAAC,CAAC;cACF4D,OAAO,CAAC,+BAA+B,CAAC;YAC1C;UACF,CAAC,EACAkB,KAAK,CAAC,MAAM;YACXjF,gBAAgB,CAACW,KAAK,CAACsB,IAAI,CAAC;cAC1B8C,QAAQ,EAAEjD,IAAI,CAACkD,IAAI;cACnBvB,OAAO,EAAE;YACX,CAAC,CAAC;YACFM,OAAO,CAAC,+BAA+B,CAAC;UAC1C,CAAC,CAAC;QACN,CAAC,MAAM,IAAIjC,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE;UACrC,MAAMkD,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;UAC/BD,MAAM,CAACE,MAAM,GAAIC,CAAC,IAAKtB,OAAO,CAACsB,CAAC,CAAC/D,MAAM,CAACgE,MAAM,CAAC;UAC/CJ,MAAM,CAACK,OAAO,GAAG,MAAM;YACrBvF,gBAAgB,CAACW,KAAK,CAACsB,IAAI,CAAC;cAC1B8C,QAAQ,EAAEjD,IAAI,CAACkD,IAAI;cACnBvB,OAAO,EAAE;YACX,CAAC,CAAC;YACFM,OAAO,CAAC,uBAAuB,CAAC;UAClC,CAAC;UACDmB,MAAM,CAACM,UAAU,CAAC1D,IAAI,CAAC;QACzB,CAAC,MAAM;UACLiC,OAAO,CAAC,IAAIjC,IAAI,CAACkD,IAAI,iCAAiC,CAAC;QACzD;MACF,CAAC,CAAC;IACJ;IAEA,eAAe/B,iBAAiBA,CAACwC,OAAO,EAAEC,KAAK,EAAE;MAC/C,MAAMC,MAAM,GAAG,sBAAsBD,KAAK;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAED,OAAO,EAAE;MAET,MAAMzC,QAAQ,GAAG,MAAMvD,KAAK,CAACmG,IAAI,CAC/B,gGAAgGvB,OAAO,CAACC,GAAG,CAACuB,sBAAsB,EAAE,EACpI;QACEC,QAAQ,EAAE,CAAC;UACTC,KAAK,EAAE,CAAC;YACNjB,IAAI,EAAEa;UACR,CAAC;QACH,CAAC,CAAC;QACFK,gBAAgB,EAAE;UAChBC,WAAW,EAAE,GAAG;UAChBC,IAAI,EAAE,EAAE;UACRC,IAAI,EAAE,IAAI;UACVC,eAAe,EAAE;QACnB;MACF,CAAC,EACD;QACEC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB;MACF,CACF,CAAC;MAED,OAAOrD,QAAQ,CAACQ,IAAI,CAAC8C,UAAU,CAAC,CAAC,CAAC,CAACb,OAAO,CAACM,KAAK,CAAC,CAAC,CAAC,CAACjB,IAAI;IAC1D;IAEA,SAAS3B,mBAAmBA,CAACH,QAAQ,EAAEyC,OAAO,EAAE;MAC9C,MAAMpC,SAAS,GAAG,EAAE;MACpB,MAAMkD,KAAK,GAAGvD,QAAQ,CAACwD,KAAK,CAAC,IAAI,CAAC;MAClC,IAAIC,eAAe,GAAG,IAAI;MAE1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAAC3F,MAAM,EAAE8F,CAAC,EAAE,EAAE;QACrC,MAAMC,IAAI,GAAGJ,KAAK,CAACG,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;QAC5B,IAAI,CAACD,IAAI,EAAE;QAEX,IAAI,0EAA0E,CAACE,IAAI,CAACF,IAAI,CAAC,EAAE;UACzF,IAAIF,eAAe,EAAE;YACnB,IAAI,CAACA,eAAe,CAACK,WAAW,EAAE;cAChC,MAAMC,UAAU,GAAGN,eAAe,CAAC3B,IAAI,CAACkC,WAAW,CAAC,CAAC;cACrD,MAAMC,iBAAiB,GAAGxB,OAAO,CAACe,KAAK,CAAC,MAAM,CAAC;cAC/C,KAAK,MAAMU,SAAS,IAAID,iBAAiB,EAAE;gBACzC,IAAIC,SAAS,CAACF,WAAW,CAAC,CAAC,CAACjF,QAAQ,CAACgF,UAAU,CAAC,EAAE;kBAChDN,eAAe,CAACK,WAAW,GAAGI,SAAS,CAACN,IAAI,CAAC,CAAC;kBAC9C;gBACF;cACF;YACF;YACAvD,SAAS,CAACpB,IAAI,CAACwE,eAAe,CAAC;UACjC;UACAA,eAAe,GAAG;YAChB3B,IAAI,EAAE6B,IAAI,CAACQ,OAAO,CAAC,0EAA0E,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC;YACzG5E,IAAI,EAAE,iBAAiB;YACvBoF,OAAO,EAAE,CAAC,CAAC;YACXC,aAAa,EAAE,EAAE;YACjBP,WAAW,EAAE,EAAE;YACfQ,UAAU,EAAE;UACd,CAAC;QACH,CAAC,MAAM,IAAI,0CAA0C,CAACT,IAAI,CAACF,IAAI,CAAC,EAAE;UAChE,IAAIF,eAAe,EAAE;YACnB,IAAI,CAACA,eAAe,CAACK,WAAW,EAAE;cAChC,MAAMC,UAAU,GAAGN,eAAe,CAAC3B,IAAI,CAACkC,WAAW,CAAC,CAAC;cACrD,MAAMC,iBAAiB,GAAGxB,OAAO,CAACe,KAAK,CAAC,MAAM,CAAC;cAC/C,KAAK,MAAMU,SAAS,IAAID,iBAAiB,EAAE;gBACzC,IAAIC,SAAS,CAACF,WAAW,CAAC,CAAC,CAACjF,QAAQ,CAACgF,UAAU,CAAC,EAAE;kBAChDN,eAAe,CAACK,WAAW,GAAGI,SAAS,CAACN,IAAI,CAAC,CAAC;kBAC9C;gBACF;cACF;YACF;YACAvD,SAAS,CAACpB,IAAI,CAACwE,eAAe,CAAC;UACjC;UACAA,eAAe,GAAG;YAChB3B,IAAI,EAAE6B,IAAI,CAACQ,OAAO,CAAC,0CAA0C,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC;YACzE5E,IAAI,EAAE,YAAY;YAClBoF,OAAO,EAAE;cACP,MAAM,EAAE,MAAM;cACd,OAAO,EAAE;YACX,CAAC;YACDC,aAAa,EAAE,EAAE;YACjBP,WAAW,EAAE,EAAE;YACfQ,UAAU,EAAE;UACd,CAAC;QACH,CAAC,MAAM,IAAIb,eAAe,EAAE;UAC1B,MAAMc,WAAW,GAAGZ,IAAI,CAACa,KAAK,CAAC,wBAAwB,CAAC;UACxD,IAAID,WAAW,IAAId,eAAe,CAACzE,IAAI,KAAK,iBAAiB,EAAE;YAC7D,MAAMyF,MAAM,GAAGF,WAAW,CAAC,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC;YAC3C,IAAIC,MAAM,GAAGJ,WAAW,CAAC,CAAC,CAAC,CAACJ,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC;YACrD,IAAIe,MAAM,CAAC5F,QAAQ,CAAC,GAAG,CAAC,EAAE;cACxB0E,eAAe,CAACY,aAAa,GAAGI,MAAM;cACtCE,MAAM,GAAGA,MAAM,CAACR,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC;YACzC;YACAH,eAAe,CAACW,OAAO,CAACK,MAAM,CAAC,GAAGE,MAAM;UAC1C,CAAC,MAAM,IAAIlB,eAAe,CAACzE,IAAI,KAAK,YAAY,KAAK2E,IAAI,CAACK,WAAW,CAAC,CAAC,CAAChD,UAAU,CAAC,MAAM,CAAC,IAAI2C,IAAI,CAACK,WAAW,CAAC,CAAC,CAAChD,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE;YACrI,MAAM4D,MAAM,GAAGjB,IAAI,CAACK,WAAW,CAAC,CAAC,CAACJ,IAAI,CAAC,CAAC;YACxC,IAAIgB,MAAM,CAAC7F,QAAQ,CAAC,GAAG,CAAC,EAAE;cACxB0E,eAAe,CAACY,aAAa,GAAGO,MAAM,CAACT,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC;YAChE;UACF,CAAC,MAAM,IAAID,IAAI,CAAC3C,UAAU,CAAC,cAAc,CAAC,EAAE;YAC1C,MAAM+C,UAAU,GAAGN,eAAe,CAAC3B,IAAI,CAACkC,WAAW,CAAC,CAAC;YACrD,MAAMC,iBAAiB,GAAGxB,OAAO,CAACe,KAAK,CAAC,MAAM,CAAC;YAC/C,KAAK,MAAMU,SAAS,IAAID,iBAAiB,EAAE;cACzC,IAAIC,SAAS,CAACF,WAAW,CAAC,CAAC,CAACjF,QAAQ,CAACgF,UAAU,CAAC,EAAE;gBAChDN,eAAe,CAACK,WAAW,GAAGI,SAAS,CAACN,IAAI,CAAC,CAAC;gBAC9C;cACF;YACF;YACA,IAAI,CAACH,eAAe,CAACK,WAAW,EAAE;cAChCL,eAAe,CAACK,WAAW,GAAGH,IAAI,CAACQ,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC;YACvE;UACF,CAAC,MAAM,IAAID,IAAI,CAAC3C,UAAU,CAAC,aAAa,CAAC,EAAE;YACzC,MAAM6D,IAAI,GAAGlB,IAAI,CAACQ,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAACP,IAAI,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC;YACjE,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC,CAACjF,QAAQ,CAAC8F,IAAI,CAAC,EAAE;cAC7CpB,eAAe,CAACa,UAAU,GAAGO,IAAI;YACnC;UACF;QACF;MACF;MAEA,IAAIpB,eAAe,EAAE;QACnB,IAAI,CAACA,eAAe,CAACK,WAAW,EAAE;UAChC,MAAMC,UAAU,GAAGN,eAAe,CAAC3B,IAAI,CAACkC,WAAW,CAAC,CAAC;UACrD,MAAMC,iBAAiB,GAAGxB,OAAO,CAACe,KAAK,CAAC,MAAM,CAAC;UAC/C,KAAK,MAAMU,SAAS,IAAID,iBAAiB,EAAE;YACzC,IAAIC,SAAS,CAACF,WAAW,CAAC,CAAC,CAACjF,QAAQ,CAACgF,UAAU,CAAC,EAAE;cAChDN,eAAe,CAACK,WAAW,GAAGI,SAAS,CAACN,IAAI,CAAC,CAAC;cAC9C;YACF;UACF;QACF;QACAvD,SAAS,CAACpB,IAAI,CAACwE,eAAe,CAAC;MACjC;MAEA,OAAO;QAAEpD;MAAU,CAAC;IACtB;IAEA,SAASD,eAAeA,CAACC,SAAS,EAAE;MAClC,MAAMyE,iBAAiB,GAAG,CAAC,GAAGzE,SAAS,EACpC0E,IAAI,CAAC,MAAMlF,IAAI,CAACmF,MAAM,CAAC,CAAC,GAAG,GAAG,EAC9BC,MAAM,CAAC,CAACC,QAAQ,EAAE/F,KAAK,EAAEgG,IAAI,KAC5BhG,KAAK,KAAKgG,IAAI,CAACC,SAAS,CAAEC,CAAC,IACzBA,CAAC,CAACvD,IAAI,CAACkC,WAAW,CAAC,CAAC,CAACG,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,KAC5Ce,QAAQ,CAACpD,IAAI,CAACkC,WAAW,CAAC,CAAC,CAACG,OAAO,CAAC,UAAU,EAAE,EAAE,CACpD,CACF,CAAC;MAEH,MAAMmB,iBAAiB,GAAG,EAAE;MAC5B,MAAMC,mBAAmB,GAAG1F,IAAI,CAAC2F,IAAI,CAACzF,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,GAAG,CAAC,CAAC;MACtE,MAAM8H,eAAe,GAAG;QAAEC,IAAI,EAAE,CAAC;QAAEC,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAE,CAAC;MAEvD,KAAK,MAAMtB,UAAU,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC,EAAE;QACnD,MAAMuB,qBAAqB,GAAGf,iBAAiB,CAACG,MAAM,CAACI,CAAC,IACtDA,CAAC,CAACf,UAAU,KAAKA,UAAU,IAAI,CAACgB,iBAAiB,CAACvG,QAAQ,CAACsG,CAAC,CAC9D,CAAC;QAED,KAAK,MAAMH,QAAQ,IAAIW,qBAAqB,EAAE;UAC5C,IAAIJ,eAAe,CAACnB,UAAU,CAAC,GAAGiB,mBAAmB,IACjDD,iBAAiB,CAAC1H,MAAM,GAAGmC,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,EAAE;YAC1D2H,iBAAiB,CAACrG,IAAI,CAACiG,QAAQ,CAAC;YAChCO,eAAe,CAACnB,UAAU,CAAC,EAAE;UAC/B;QACF;MACF;MAEA,OAAOgB,iBAAiB,CAAC1H,MAAM,GAAGmC,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,EAAE;QAC7D,MAAMmI,iBAAiB,GAAGhB,iBAAiB,CAACiB,IAAI,CAACV,CAAC,IAAI,CAACC,iBAAiB,CAACvG,QAAQ,CAACsG,CAAC,CAAC,CAAC;QACrF,IAAIS,iBAAiB,EAAE;UACrBR,iBAAiB,CAACrG,IAAI,CAAC6G,iBAAiB,CAAC;QAC3C,CAAC,MAAM;UACL;QACF;MACF;MAEA,OAAOR,iBAAiB;IAC1B;IAEA,SAAShF,uBAAuBA,CAAA,EAAG;MACjC,MAAM0F,eAAe,GAAGC,yBAAyB,CAAC,CAAC;MACnD,OAAOpG,IAAI,CAACqG,GAAG,CAAC,CAAC,EAAErG,IAAI,CAACC,GAAG,CAAC,GAAG,EAAED,IAAI,CAACsG,KAAK,CAACH,eAAe,GAAG,GAAG,CAAC,CAAC,CAAC;IACtE;IAEA,SAASC,yBAAyBA,CAAA,EAAG;MACnC,OAAO,GAAG;IACZ;IAEA,SAASG,YAAYA,CAACJ,eAAe,EAAE;MACrC,OAAOnG,IAAI,CAACqG,GAAG,CAAC,CAAC,EAAErG,IAAI,CAACC,GAAG,CAAC,GAAG,EAAED,IAAI,CAACsG,KAAK,CAACH,eAAe,GAAG,GAAG,CAAC,CAAC,CAAC;IACtE;;IAEA;IACA,MAAMK,yBAAyB,GAAG7J,QAAQ,CAAC,MAAM;MAC/C,OAAOe,iBAAiB,CAACI,KAAK,CAAC8B,GAAG,CAAC,CAAC4F,CAAC,EAAElG,KAAK,MAAM;QAChD2C,IAAI,EAAEuD,CAAC,CAACvD,IAAI;QACZ9C,IAAI,EAAEqG,CAAC,CAACrG,IAAI;QACZoF,OAAO,EAAEiB,CAAC,CAACjB,OAAO;QAClBkC,UAAU,EAAE9I,aAAa,CAACG,KAAK,CAACwB,KAAK,CAAC,EAAEmH,UAAU;QAClDjC,aAAa,EAAEgB,CAAC,CAAChB,aAAa;QAC9BP,WAAW,EAAEuB,CAAC,CAACvB,WAAW;QAC1ByC,SAAS,EAAE/I,aAAa,CAACG,KAAK,CAACwB,KAAK,CAAC,EAAEqH;MACzC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,MAAMC,2BAA2B,GAAGjK,QAAQ,CAAC,MAAM;MACjD,OAAOgB,aAAa,CAACG,KAAK,CAAC8B,GAAG,CAACiH,CAAC,IAAIA,CAAC,CAACJ,UAAU,CAAC;IACnD,CAAC,CAAC;IAEF,MAAMK,mBAAmB,GAAGnK,QAAQ,CAAC,MAAM;MACzC,OAAOgB,aAAa,CAACG,KAAK,CAACsH,MAAM,CAACyB,CAAC,IAAIA,CAAC,CAACF,OAAO,CAAC,CAAC5I,MAAM;IAC1D,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
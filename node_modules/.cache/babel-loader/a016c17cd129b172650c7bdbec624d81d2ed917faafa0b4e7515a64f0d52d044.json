{"ast":null,"code":"import { ref, computed } from 'vue';\nimport axios from 'axios';\nimport FileErrorDisplay from './components/FileErrorDisplay.vue';\nimport QuizResults from './components/QuizResults.vue';\nimport FlashcardQuiz from './components/FlashcardQuiz.vue';\n\n// File handling state\n\nexport default {\n  __name: 'App',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const selectedFiles = ref([]);\n    const fileInput = ref(null);\n    const unsupportedFiles = ref([]);\n    const extractionErrors = ref([]);\n\n    // Quiz state\n    const questionCount = ref('');\n    const isLoading = ref(false);\n    const error = ref('');\n    const predictedScore = ref(null);\n    const quizStarted = ref(false);\n    const quizFinished = ref(false);\n    const adaptiveQuestions = ref([]);\n    const userResponses = ref([]);\n    const extractedContent = ref('');\n\n    // Computed properties\n    const isFormValid = computed(() => {\n      return selectedFiles.value.length > 0 && questionCount.value > 0;\n    });\n    const hasFileErrors = computed(() => {\n      return extractionErrors.value.length > 0 || unsupportedFiles.value.length > 0;\n    });\n    const getPredictedScoreClass = computed(() => {\n      if (predictedScore.value >= 80) return 'high';\n      if (predictedScore.value >= 60) return 'medium';\n      return 'low';\n    });\n\n    // File handling methods\n    const triggerFileInput = () => {\n      fileInput.value.click();\n    };\n    const handleFileSelect = event => {\n      const files = Array.from(event.target.files);\n      addFiles(files);\n    };\n    const handleDrop = event => {\n      const files = Array.from(event.dataTransfer.files);\n      addFiles(files);\n    };\n    const addFiles = files => {\n      const validTypes = ['application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'text/plain', 'application/pdf', 'image/png', 'image/jpeg', 'image/jpg', 'image/tiff', 'image/bmp'];\n      const validFiles = [];\n      const invalidFiles = [];\n      files.forEach(file => {\n        if (validTypes.includes(file.type)) {\n          validFiles.push(file);\n        } else {\n          invalidFiles.push(file);\n        }\n      });\n      selectedFiles.value = [...selectedFiles.value, ...validFiles];\n      unsupportedFiles.value = [...unsupportedFiles.value, ...invalidFiles];\n    };\n    const removeFile = index => {\n      selectedFiles.value.splice(index, 1);\n    };\n\n    // Quiz handling methods\n    const handleSubmit = async () => {\n      if (!isFormValid.value) return;\n      isLoading.value = true;\n      error.value = '';\n      adaptiveQuestions.value = [];\n      predictedScore.value = null;\n      quizStarted.value = false;\n      userResponses.value = [];\n      extractedContent.value = '';\n      try {\n        const fileContents = await Promise.all(selectedFiles.value.map(file => readFileContent(file)));\n        extractedContent.value = fileContents.join('\\n\\n');\n        const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n        const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n        const processedQuiz = processQuizResponse(response, extractedContent.value);\n        adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n        predictedScore.value = calculatePredictedScore();\n      } catch (err) {\n        error.value = `Error generating questions: ${err.response?.data?.error?.message || err.message}`;\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    const startQuiz = () => {\n      quizStarted.value = true;\n      quizFinished.value = false;\n    };\n    const handleQuizComplete = responses => {\n      userResponses.value = responses;\n      quizStarted.value = false;\n      quizFinished.value = true;\n    };\n    const restartQuiz = () => {\n      quizStarted.value = true;\n      quizFinished.value = false;\n      userResponses.value = [];\n    };\n    const resetToMainScreen = () => {\n      selectedFiles.value = [];\n      unsupportedFiles.value = [];\n      extractionErrors.value = [];\n      questionCount.value = '';\n      error.value = '';\n      isLoading.value = false;\n      predictedScore.value = null;\n      quizStarted.value = false;\n      quizFinished.value = false;\n      adaptiveQuestions.value = [];\n      userResponses.value = [];\n      if (fileInput.value) {\n        fileInput.value.value = '';\n      }\n    };\n\n    // Helper functions\n    async function readFileContent(file) {\n      return new Promise(resolve => {\n        if (file.type === \"application/pdf\" || file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" || file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" || file.type.startsWith('image/')) {\n          const formData = new FormData();\n          formData.append('file', file);\n          const backendUrl = process.env.VUE_APP_BACKEND_URL || 'http://localhost:5001';\n          fetch(`${backendUrl}/extract-file`, {\n            method: 'POST',\n            body: formData\n          }).then(res => res.json()).then(data => {\n            if (data.text) {\n              resolve(data.text);\n            } else {\n              extractionErrors.value.push({\n                fileName: file.name,\n                message: data.error || 'Failed to extract text from file'\n              });\n              resolve(\"[Could not extract file text]\");\n            }\n          }).catch(() => {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: 'Server error while extracting text'\n            });\n            resolve(\"[Could not extract file text]\");\n          });\n        } else if (file.type === \"text/plain\") {\n          const reader = new FileReader();\n          reader.onload = e => resolve(e.target.result);\n          reader.onerror = () => {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: 'Error reading text file'\n            });\n            resolve(\"[Could not read file]\");\n          };\n          reader.readAsText(file);\n        } else {\n          resolve(`[${file.name} is not a supported file type.]`);\n        }\n      });\n    }\n    async function generateQuestions(content, count) {\n      const prompt = `Create a quiz with ${count} COMPLETELY UNIQUE and DIVERSE questions based on this text. Each question MUST cover a different concept or aspect. NO REPETITIVE or SIMILAR questions allowed.\n\nCRITICAL REQUIREMENTS:\n1. Each explanation MUST be a direct quote or paraphrased content from the original text\n2. Explanations should reference specific parts of the text that justify the correct answer\n3. Do NOT make up explanations - they must be based on the actual content provided\n4. If a concept isn't clearly explained in the text, don't create a question about it\n5. Automatically determine appropriate difficulty (easy/medium/hard) based on:\n   - Easy: Basic facts, definitions, or simple concepts\n   - Medium: Understanding relationships between concepts\n   - Hard: Analysis, evaluation, or complex relationships\n\nFormat requirements for each question:\n\nFor multiple choice questions:\n1. Question: [unique question text]\n2. Options (mark correct with *):\n   A) [option]\n   B) [option]\n   C) [option]\n   D) [option]\n3. Explanation: [quote or paraphrase relevant text that explains the correct answer]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nFor true/false questions:\n1. True/False: [unique question text]\n2. Answer: [Write ONLY \"True*\" if true is correct, or \"False*\" if false is correct]\n3. Explanation: [quote or paraphrase relevant text that explains why the statement is true or false]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nIMPORTANT:\n- Each question MUST cover a different topic/concept\n- NO similar or overlapping questions\n- Make questions engaging and thought-provoking\n- Ensure clear, unambiguous wording\n- ALL explanations must come from the provided text\n- For true/false questions, ALWAYS mark the correct answer with an asterisk (*)\n- Distribute difficulties naturally based on content complexity\n\nText to base questions on:\n${content}`;\n      const response = await axios.post(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.VUE_APP_GEMINI_API_KEY}`, {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 2048\n        }\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      return response.data.candidates[0].content.parts[0].text;\n    }\n    function processQuizResponse(response, content) {\n      const questions = [];\n      const lines = response.split('\\n');\n      let currentQuestion = null;\n      let collectingOptions = false;\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i.test(line)) {\n          if (currentQuestion) {\n            findExplanationFromContent(currentQuestion, content);\n            questions.push(currentQuestion);\n          }\n          currentQuestion = {\n            text: line.replace(/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i, '').trim(),\n            type: 'multiple-choice',\n            options: {},\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n          collectingOptions = true;\n        } else if (/^\\d*\\.?\\s*(True\\/False:|True or False:)/i.test(line)) {\n          if (currentQuestion) {\n            findExplanationFromContent(currentQuestion, content);\n            questions.push(currentQuestion);\n          }\n          currentQuestion = {\n            text: line.replace(/^\\d*\\.?\\s*(True\\/False:|True or False:)/i, '').trim(),\n            type: 'true-false',\n            options: {\n              'true': 'True',\n              'false': 'False'\n            },\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n          collectingOptions = true;\n        } else if (currentQuestion && collectingOptions) {\n          if (currentQuestion.type === 'multiple-choice') {\n            const optionMatch = line.match(/^([A-Da-d])[).]\\s*(.*)/);\n            if (optionMatch) {\n              const letter = optionMatch[1].toUpperCase();\n              let option = optionMatch[2].trim();\n\n              // Check for asterisk at start or end of option\n              if (option.startsWith('*') || option.endsWith('*')) {\n                currentQuestion.correctAnswer = letter;\n                option = option.replace(/^\\*|\\*$/g, '').trim();\n              }\n              currentQuestion.options[letter] = option;\n            } else if (line.toLowerCase().startsWith('explanation:')) {\n              collectingOptions = false;\n            }\n          } else if (currentQuestion.type === 'true-false') {\n            // Look for the Answer: line specifically\n            if (line.toLowerCase().startsWith('answer:')) {\n              const answer = line.substring(7).trim().toLowerCase();\n              if (answer.includes('true*') || answer.includes('*true')) {\n                currentQuestion.correctAnswer = 'true';\n              } else if (answer.includes('false*') || answer.includes('*false')) {\n                currentQuestion.correctAnswer = 'false';\n              }\n            } else if (line.toLowerCase().startsWith('explanation:')) {\n              collectingOptions = false;\n            }\n          }\n        }\n      }\n      if (currentQuestion) {\n        findExplanationFromContent(currentQuestion, content);\n        questions.push(currentQuestion);\n      }\n\n      // Validate and fix questions\n      const validQuestions = questions.filter(q => {\n        if (q.type === 'multiple-choice') {\n          // Must have at least 2 options and a correct answer\n          const hasEnoughOptions = Object.keys(q.options).length >= 2;\n          if (!hasEnoughOptions || !q.correctAnswer) {\n            console.warn('Invalid multiple choice question:', q);\n            return false;\n          }\n          return true;\n        } else if (q.type === 'true-false') {\n          // For true/false questions, try to infer the answer from the explanation if not explicitly set\n          if (!q.correctAnswer && q.explanation) {\n            const lowerExplanation = q.explanation.toLowerCase();\n            if (lowerExplanation.includes('this statement is true')) {\n              q.correctAnswer = 'true';\n            } else if (lowerExplanation.includes('this statement is false')) {\n              q.correctAnswer = 'false';\n            }\n          }\n\n          // If still no answer, warn and default to false (since defaulting to true might be misleading)\n          if (!q.correctAnswer) {\n            console.warn('True/False question missing correct answer, inferring from context:', q);\n            // Look for negative indicators in the question\n            const questionLower = q.text.toLowerCase();\n            const hasNegativeIndicators = ['only', 'solely', 'never', 'always', 'all', 'none'].some(word => questionLower.includes(word));\n            q.correctAnswer = hasNegativeIndicators ? 'false' : 'true';\n          }\n          return true;\n        }\n        return false;\n      });\n      if (validQuestions.length === 0) {\n        throw new Error('No valid questions could be generated from the content.');\n      }\n      return {\n        questions: validQuestions\n      };\n    }\n    function findExplanationFromContent(question, content) {\n      // Split content into paragraphs\n      const paragraphs = content.split(/\\n\\s*\\n/);\n\n      // Create search terms from the question and answer\n      const searchTerms = [...question.text.toLowerCase().replace(/[.,?!]/g, '').split(' '), ...(question.type === 'multiple-choice' && question.options[question.correctAnswer] ? question.options[question.correctAnswer].toLowerCase().split(' ') : [])].filter(word => word.length > 3);\n\n      // Find relevant paragraphs with scoring\n      const relevantParagraphs = paragraphs.map(paragraph => {\n        const normalizedParagraph = paragraph.toLowerCase();\n        let score = 0;\n        let keywordMatches = new Set();\n\n        // Score exact phrase matches higher\n        if (normalizedParagraph.includes(question.text.toLowerCase())) {\n          score += 15;\n        }\n\n        // Score keyword matches\n        searchTerms.forEach(term => {\n          if (normalizedParagraph.includes(term)) {\n            score += 2;\n            keywordMatches.add(term);\n\n            // Bonus for keywords near each other\n            searchTerms.forEach(otherTerm => {\n              if (term !== otherTerm) {\n                const termIndex = normalizedParagraph.indexOf(term);\n                const otherIndex = normalizedParagraph.indexOf(otherTerm);\n                if (otherIndex !== -1 && Math.abs(termIndex - otherIndex) < 50) {\n                  score += 1;\n                }\n              }\n            });\n          }\n        });\n        return {\n          text: paragraph.trim(),\n          score,\n          keywordMatches: Array.from(keywordMatches)\n        };\n      }).filter(p => p.score > 0).sort((a, b) => b.score - a.score).slice(0, 2); // Get top 2 most relevant paragraphs\n\n      if (relevantParagraphs.length > 0) {\n        // Generate a more natural explanation\n        let explanation = '';\n        if (question.type === 'true-false') {\n          const isTrue = question.correctAnswer === 'true';\n          explanation = generateTrueFalseExplanation(question.text, isTrue, relevantParagraphs);\n        } else {\n          explanation = generateMultipleChoiceExplanation(question, relevantParagraphs);\n        }\n        question.explanation = explanation;\n      } else {\n        // Improved fallback explanations\n        if (question.type === 'true-false') {\n          const isTrue = question.correctAnswer === 'true';\n          question.explanation = `This statement is ${isTrue ? 'true' : 'false'}. While reviewing the content, consider how this relates to the main concepts presented.`;\n        } else {\n          const correctOption = question.options[question.correctAnswer];\n          question.explanation = `The correct answer is \"${correctOption}\". Consider reviewing the material again, focusing on this concept and related topics.`;\n        }\n      }\n    }\n    function rephraseContent(text, isSupporting) {\n      // Clean and normalize the text\n      let cleaned = text.trim().replace(/^(however|moreover|furthermore|therefore|thus|hence|consequently),?\\s*/i, '').replace(/[\"\"\"]/g, '\"').trim();\n\n      // Capitalize first letter if needed\n      cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);\n\n      // Enhanced contextual phrases for better explanations\n      const contextPhrases = isSupporting ? [\"According to the material, \", \"The key point here is that \", \"To understand this better, note that \", \"What's important to recognize is that \", \"The text specifically mentions that \", \"A crucial detail from the content is that \", \"To explain this concept, we can see that \", \"The correct answer is supported by the fact that \"] : [\"This answer is incorrect because \", \"The text actually indicates that \", \"This choice contradicts the material, which states that \", \"This is not accurate because the content shows that \", \"We can see this is wrong because \", \"The material provides evidence against this by stating that \", \"This option is misleading because \", \"This doesn't align with the text, which explains that \"];\n\n      // Select a phrase that best matches the content length and complexity\n      let selectedPhrase;\n      if (cleaned.length > 100) {\n        // For longer explanations, use phrases that introduce complex ideas\n        selectedPhrase = contextPhrases.find(phrase => phrase.includes(\"understand\") || phrase.includes(\"concept\") || phrase.includes(\"recognize\")) || contextPhrases[0];\n      } else {\n        // For shorter explanations, use more direct phrases\n        selectedPhrase = contextPhrases.find(phrase => !phrase.includes(\"understand\") && !phrase.includes(\"concept\")) || contextPhrases[0];\n      }\n\n      // Add educational connectors for better flow\n      const connectors = [\". This helps us understand that \", \". This demonstrates that \", \". This indicates that \", \". This shows us that \", \". This means that \"];\n\n      // Split the cleaned text into sentences\n      const sentences = cleaned.split(/(?<=[.!?])\\s+/);\n      if (sentences.length > 1) {\n        // If we have multiple sentences, connect them meaningfully\n        const mainPoint = sentences[0];\n        const supportingPoint = sentences[1];\n        const connector = connectors[Math.floor(Math.random() * connectors.length)];\n        return `${selectedPhrase}${mainPoint}${connector}${supportingPoint.toLowerCase()}`;\n      }\n      return `${selectedPhrase}${cleaned}`;\n    }\n    function generateMultipleChoiceExplanation(question, relevantParagraphs) {\n      const correctOption = question.options[question.correctAnswer];\n      let explanation = `Let's understand why \"${correctOption}\" is the correct answer.\\n\\n`;\n\n      // Add context about why this option is correct\n      relevantParagraphs.forEach((para, index) => {\n        const transition = index === 0 ? \"\" : \"\\nFurthermore, \";\n\n        // Extract and rephrase relevant content\n        const sentences = para.text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n        const relevantSentences = sentences.filter(s => para.keywordMatches.some(keyword => s.toLowerCase().includes(keyword)));\n\n        // Use the most relevant sentence or fall back to the first one\n        const bestSentence = relevantSentences[0] || sentences[0];\n        explanation += transition + rephraseContent(bestSentence, true);\n      });\n\n      // Explain why other options are incorrect using specific content\n      const incorrectOptions = Object.entries(question.options).filter(([key]) => key !== question.correctAnswer).map(([, text]) => text);\n      if (incorrectOptions.length > 0) {\n        explanation += \"\\n\\nLet's examine why the other options are incorrect:\";\n        incorrectOptions.forEach(option => {\n          explanation += `\\n• The option \"${option}\" is not correct because it misinterprets the key concepts presented in the material. ${rephraseContent(relevantParagraphs[0].text, false)}`;\n        });\n      }\n\n      // Add a learning tip that connects to the specific topic\n      const topicKeywords = question.text.toLowerCase().split(' ').filter(word => word.length > 4);\n      explanation += `\\n\\nKey Learning Point: When studying ${topicKeywords[0] || 'this topic'}, focus on understanding how it connects to ${topicKeywords[1] || 'related concepts'} in the material.`;\n      return explanation;\n    }\n    function generateTrueFalseExplanation(statement, isTrue, relevantParagraphs) {\n      const introPhrase = isTrue ? \"This statement is correct, and here's why:\" : \"This statement is incorrect. Let's understand the reason:\";\n      let explanation = `${introPhrase}\\n\\n`;\n      relevantParagraphs.forEach((para, index) => {\n        // Extract the most relevant sentences\n        const sentences = para.text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n        const relevantSentences = sentences.filter(s => para.keywordMatches.some(keyword => s.toLowerCase().includes(keyword)));\n\n        // Use the best matching sentence or fall back to the first one\n        const bestSentence = relevantSentences[0] || sentences[0];\n        const transition = index === 0 ? \"\" : \"\\nAdditionally, \";\n        explanation += transition + rephraseContent(bestSentence, isTrue);\n      });\n\n      // Add a specific learning tip based on the statement content\n      const topicWords = statement.toLowerCase().split(' ').filter(word => word.length > 4);\n      const topic = topicWords[0] || 'this concept';\n      explanation += `\\n\\nTo deepen your understanding: Consider how ${topic} relates to the broader context and try to identify similar examples in the material.`;\n      return explanation;\n    }\n    function selectQuestions(questions) {\n      const shuffledQuestions = [...questions].sort(() => Math.random() - 0.5).filter((question, index, self) => index === self.findIndex(q => q.text.toLowerCase().replace(/[^\\w\\s]/g, '') === question.text.toLowerCase().replace(/[^\\w\\s]/g, '')));\n      const selectedQuestions = [];\n      const targetPerDifficulty = Math.ceil(Number(questionCount.value) / 3);\n      const difficultyCount = {\n        easy: 0,\n        medium: 0,\n        hard: 0\n      };\n      for (const difficulty of ['easy', 'medium', 'hard']) {\n        const questionsOfDifficulty = shuffledQuestions.filter(q => q.difficulty === difficulty && !selectedQuestions.includes(q));\n        for (const question of questionsOfDifficulty) {\n          if (difficultyCount[difficulty] < targetPerDifficulty && selectedQuestions.length < Number(questionCount.value)) {\n            selectedQuestions.push(question);\n            difficultyCount[difficulty]++;\n          }\n        }\n      }\n      while (selectedQuestions.length < Number(questionCount.value)) {\n        const remainingQuestion = shuffledQuestions.find(q => !selectedQuestions.includes(q));\n        if (remainingQuestion) {\n          selectedQuestions.push(remainingQuestion);\n        } else {\n          break;\n        }\n      }\n      return selectedQuestions;\n    }\n    function calculatePredictedScore() {\n      const contentCoverage = analyzeContentForCoverage();\n      const contentComplexity = analyzeContentComplexity();\n      const questionDiversity = analyzeQuestionDiversity();\n\n      // Weight factors\n      const coverageWeight = 0.4;\n      const complexityWeight = 0.3;\n      const diversityWeight = 0.3;\n\n      // Calculate weighted score\n      const predictedScore = contentCoverage * coverageWeight + contentComplexity * complexityWeight + questionDiversity * diversityWeight;\n      return Math.max(0, Math.min(100, Math.round(predictedScore)));\n    }\n    function analyzeContentForCoverage() {\n      // Analyze how well the content matches with generated questions\n      const totalContent = extractedContent.value.length;\n      if (totalContent === 0) return 0;\n\n      // Calculate coverage based on content length and number of questions\n      const averageContentPerQuestion = 500; // baseline characters per question\n      const expectedQuestions = Math.ceil(totalContent / averageContentPerQuestion);\n      const actualQuestions = Number(questionCount.value);\n      const coverage = Math.min(actualQuestions / expectedQuestions, 1) * 100;\n      return coverage;\n    }\n    function analyzeContentComplexity() {\n      const content = extractedContent.value.toLowerCase();\n\n      // Define complexity indicators\n      const complexityIndicators = ['analyze', 'compare', 'contrast', 'evaluate', 'explain', 'describe', 'discuss', 'examine', 'interpret', 'justify', 'therefore', 'however', 'although', 'furthermore', 'consequently'];\n\n      // Count complexity indicators\n      let complexityScore = 0;\n      complexityIndicators.forEach(indicator => {\n        const regex = new RegExp(indicator, 'g');\n        const matches = content.match(regex);\n        if (matches) {\n          complexityScore += matches.length;\n        }\n      });\n\n      // Normalize score to 0-100 range\n      const normalizedScore = Math.min(complexityScore * 5, 100);\n      return normalizedScore;\n    }\n    function analyzeQuestionDiversity() {\n      if (!adaptiveQuestions.value.length) return 0;\n\n      // Count different types of questions\n      const types = new Set(adaptiveQuestions.value.map(q => q.type));\n      const typesDiversity = types.size / 2 * 50; // 2 is max types (multiple-choice and true-false)\n\n      // Analyze question text similarity to ensure diverse topics\n      const questionTexts = adaptiveQuestions.value.map(q => q.text.toLowerCase());\n      let uniqueTopics = 0;\n      const processedKeywords = new Set();\n      questionTexts.forEach(text => {\n        const keywords = text.split(' ').filter(word => word.length > 4) // Consider only significant words\n        .map(word => word.replace(/[^a-z]/g, '')); // Clean up words\n\n        keywords.forEach(keyword => {\n          if (!processedKeywords.has(keyword)) {\n            uniqueTopics++;\n            processedKeywords.add(keyword);\n          }\n        });\n      });\n      const topicsDiversity = Math.min(uniqueTopics / questionTexts.length * 50, 50);\n      return typesDiversity + topicsDiversity;\n    }\n\n    // Results formatting\n    const formatQuestionsForResults = computed(() => {\n      return adaptiveQuestions.value.map((q, index) => ({\n        text: q.text,\n        type: q.type,\n        options: q.options,\n        userAnswer: userResponses.value[index]?.userAnswer,\n        correctAnswer: q.correctAnswer,\n        explanation: q.explanation,\n        isCorrect: userResponses.value[index]?.correct\n      }));\n    });\n    const formatUserAnswersForResults = computed(() => {\n      return userResponses.value.map(r => r.userAnswer);\n    });\n    const correctAnswersCount = computed(() => {\n      return userResponses.value.filter(r => r.correct).length;\n    });\n    const __returned__ = {\n      selectedFiles,\n      fileInput,\n      unsupportedFiles,\n      extractionErrors,\n      questionCount,\n      isLoading,\n      error,\n      predictedScore,\n      quizStarted,\n      quizFinished,\n      adaptiveQuestions,\n      userResponses,\n      extractedContent,\n      isFormValid,\n      hasFileErrors,\n      getPredictedScoreClass,\n      triggerFileInput,\n      handleFileSelect,\n      handleDrop,\n      addFiles,\n      removeFile,\n      handleSubmit,\n      startQuiz,\n      handleQuizComplete,\n      restartQuiz,\n      resetToMainScreen,\n      readFileContent,\n      generateQuestions,\n      processQuizResponse,\n      findExplanationFromContent,\n      rephraseContent,\n      generateMultipleChoiceExplanation,\n      generateTrueFalseExplanation,\n      selectQuestions,\n      calculatePredictedScore,\n      analyzeContentForCoverage,\n      analyzeContentComplexity,\n      analyzeQuestionDiversity,\n      formatQuestionsForResults,\n      formatUserAnswersForResults,\n      correctAnswersCount,\n      ref,\n      computed,\n      get axios() {\n        return axios;\n      },\n      FileErrorDisplay,\n      QuizResults,\n      FlashcardQuiz\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","computed","axios","FileErrorDisplay","QuizResults","FlashcardQuiz","selectedFiles","fileInput","unsupportedFiles","extractionErrors","questionCount","isLoading","error","predictedScore","quizStarted","quizFinished","adaptiveQuestions","userResponses","extractedContent","isFormValid","value","length","hasFileErrors","getPredictedScoreClass","triggerFileInput","click","handleFileSelect","event","files","Array","from","target","addFiles","handleDrop","dataTransfer","validTypes","validFiles","invalidFiles","forEach","file","includes","type","push","removeFile","index","splice","handleSubmit","fileContents","Promise","all","map","readFileContent","join","requestedQuestionCount","Math","min","Number","response","generateQuestions","processedQuiz","processQuizResponse","selectQuestions","questions","calculatePredictedScore","err","data","message","startQuiz","handleQuizComplete","responses","restartQuiz","resetToMainScreen","resolve","startsWith","formData","FormData","append","backendUrl","process","env","VUE_APP_BACKEND_URL","fetch","method","body","then","res","json","text","fileName","name","catch","reader","FileReader","onload","e","result","onerror","readAsText","content","count","prompt","post","VUE_APP_GEMINI_API_KEY","contents","parts","generationConfig","temperature","topK","topP","maxOutputTokens","headers","candidates","lines","split","currentQuestion","collectingOptions","i","line","trim","test","findExplanationFromContent","replace","options","correctAnswer","explanation","difficulty","optionMatch","match","letter","toUpperCase","option","endsWith","toLowerCase","answer","substring","validQuestions","filter","q","hasEnoughOptions","Object","keys","console","warn","lowerExplanation","questionLower","hasNegativeIndicators","some","word","Error","question","paragraphs","searchTerms","relevantParagraphs","paragraph","normalizedParagraph","score","keywordMatches","Set","term","add","otherTerm","termIndex","indexOf","otherIndex","abs","p","sort","a","b","slice","isTrue","generateTrueFalseExplanation","generateMultipleChoiceExplanation","correctOption","rephraseContent","isSupporting","cleaned","charAt","contextPhrases","selectedPhrase","find","phrase","connectors","sentences","mainPoint","supportingPoint","connector","floor","random","para","transition","s","relevantSentences","keyword","bestSentence","incorrectOptions","entries","key","topicKeywords","statement","introPhrase","topicWords","topic","shuffledQuestions","self","findIndex","selectedQuestions","targetPerDifficulty","ceil","difficultyCount","easy","medium","hard","questionsOfDifficulty","remainingQuestion","contentCoverage","analyzeContentForCoverage","contentComplexity","analyzeContentComplexity","questionDiversity","analyzeQuestionDiversity","coverageWeight","complexityWeight","diversityWeight","max","round","totalContent","averageContentPerQuestion","expectedQuestions","actualQuestions","coverage","complexityIndicators","complexityScore","indicator","regex","RegExp","matches","normalizedScore","types","typesDiversity","size","questionTexts","uniqueTopics","processedKeywords","keywords","has","topicsDiversity","formatQuestionsForResults","userAnswer","isCorrect","correct","formatUserAnswersForResults","r","correctAnswersCount"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/App.vue"],"sourcesContent":["<template>\n  <div class=\"app-container\">\n    <div class=\"upload-container\">\n      <h1>QUIZZy</h1>\n      \n      <div v-if=\"!quizStarted && !quizFinished && predictedScore === null\" class=\"file-upload-section\">\n        <h2>Upload Files</h2>\n        <div class=\"upload-area\" \n          @dragover.prevent \n          @drop.prevent=\"handleDrop\"\n          @click=\"triggerFileInput\"\n          role=\"button\"\n          tabindex=\"0\"\n          @keydown.enter=\"triggerFileInput\"\n        >\n          <input \n            type=\"file\" \n            @change=\"handleFileSelect\" \n            accept=\".pdf,.docx,.pptx,.txt,.png,.jpg,.jpeg,.tiff,.bmp\"\n            ref=\"fileInput\"\n            class=\"file-input\"\n          >\n          <div class=\"upload-prompt\">\n            <p>Drag and drop files here or click to select</p>\n            <div class=\"supported-formats\">\n              <p>Supported formats:</p>\n              <ul>\n                <li><span class=\"format-icon\">📄</span> Documents (PDF, DOCX)</li>\n                <li><span class=\"format-icon\">📊</span> Presentations (PPTX)</li>\n                <li><span class=\"format-icon\">📝</span> Text files (TXT)</li>\n              </ul>\n            </div>\n          </div>\n        </div>\n        \n        <div v-if=\"hasFileErrors\" class=\"error-section\">\n          <FileErrorDisplay\n            :extraction-errors=\"extractionErrors\"\n            :unsupported-files=\"unsupportedFiles\"\n          />\n        </div>\n\n        <div v-if=\"selectedFiles.length > 0\" class=\"selected-files\">\n          <h3>Selected Files:</h3>\n          <ul>\n            <li v-for=\"(file, index) in selectedFiles\" :key=\"index\" class=\"file-item\">\n              <span class=\"file-name\">{{ file.name }}</span>\n              <button @click=\"removeFile(index)\" class=\"remove-btn\" title=\"Remove file\">×</button>\n            </li>\n          </ul>\n        </div>\n\n        <div class=\"questions-section\">\n          <h2>Number of Questions</h2>\n          <div class=\"question-input\">\n            <input\n              type=\"number\"\n              v-model=\"questionCount\"\n              min=\"1\"\n              max=\"20\"\n              placeholder=\"Enter number of questions\"\n            />\n          </div>\n        </div>\n\n        <button \n          class=\"submit-btn\" \n          :disabled=\"!isFormValid || isLoading\"\n          @click=\"handleSubmit\"\n        >\n          {{ isLoading ? 'Generating Questions...' : 'Submit' }}\n        </button>\n      </div>\n\n      <div v-if=\"predictedScore !== null && !quizStarted && !quizFinished\">\n        <div class=\"predicted-score-container\">\n          <h2>Ready to Start!</h2>\n          <div class=\"score-prediction\">\n            <div class=\"score-circle\" :class=\"getPredictedScoreClass\">\n              <span class=\"predicted-value\">{{ predictedScore }}%</span>\n              <span class=\"prediction-label\">Predicted Score</span>\n            </div>\n          </div>\n          <p class=\"prediction-explanation\">\n            Based on your study material, we predict you'll score around {{ predictedScore }}%.\n          </p>\n          <button class=\"start-quiz-btn\" @click=\"startQuiz\">Start Quiz</button>\n        </div>\n      </div>\n\n      <FlashcardQuiz\n        v-if=\"quizStarted && !quizFinished\"\n        :questions=\"adaptiveQuestions\"\n        :total-questions=\"Number(questionCount)\"\n        @quiz-completed=\"handleQuizComplete\"\n      />\n\n      <QuizResults\n        v-if=\"quizFinished\"\n        :questions=\"formatQuestionsForResults\"\n        :user-answers=\"formatUserAnswersForResults\"\n        :score=\"correctAnswersCount\"\n        :predicted-score=\"predictedScore\"\n        @restart=\"restartQuiz\"\n        @go-back=\"resetToMainScreen\"\n      />\n\n      <div v-if=\"error\" class=\"error-message\">\n        {{ error }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue';\nimport axios from 'axios';\nimport FileErrorDisplay from './components/FileErrorDisplay.vue';\nimport QuizResults from './components/QuizResults.vue';\nimport FlashcardQuiz from './components/FlashcardQuiz.vue';\n\n// File handling state\nconst selectedFiles = ref([]);\nconst fileInput = ref(null);\nconst unsupportedFiles = ref([]);\nconst extractionErrors = ref([]);\n\n// Quiz state\nconst questionCount = ref('');\nconst isLoading = ref(false);\nconst error = ref('');\nconst predictedScore = ref(null);\nconst quizStarted = ref(false);\nconst quizFinished = ref(false);\nconst adaptiveQuestions = ref([]);\nconst userResponses = ref([]);\nconst extractedContent = ref('');\n\n// Computed properties\nconst isFormValid = computed(() => {\n  return selectedFiles.value.length > 0 && questionCount.value > 0;\n});\n\nconst hasFileErrors = computed(() => {\n  return extractionErrors.value.length > 0 || unsupportedFiles.value.length > 0;\n});\n\nconst getPredictedScoreClass = computed(() => {\n  if (predictedScore.value >= 80) return 'high';\n  if (predictedScore.value >= 60) return 'medium';\n  return 'low';\n});\n\n// File handling methods\nconst triggerFileInput = () => {\n  fileInput.value.click();\n};\n\nconst handleFileSelect = (event) => {\n  const files = Array.from(event.target.files);\n  addFiles(files);\n};\n\nconst handleDrop = (event) => {\n  const files = Array.from(event.dataTransfer.files);\n  addFiles(files);\n};\n\nconst addFiles = (files) => {\n  const validTypes = [\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/vnd.ms-powerpoint',\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n    'text/plain',\n    'application/pdf',\n    'image/png',\n    'image/jpeg',\n    'image/jpg',\n    'image/tiff',\n    'image/bmp'\n  ];\n  \n  const validFiles = [];\n  const invalidFiles = [];\n  \n  files.forEach(file => {\n    if (validTypes.includes(file.type)) {\n      validFiles.push(file);\n    } else {\n      invalidFiles.push(file);\n    }\n  });\n  \n  selectedFiles.value = [...selectedFiles.value, ...validFiles];\n  unsupportedFiles.value = [...unsupportedFiles.value, ...invalidFiles];\n};\n\nconst removeFile = (index) => {\n  selectedFiles.value.splice(index, 1);\n};\n\n// Quiz handling methods\nconst handleSubmit = async () => {\n  if (!isFormValid.value) return;\n\n  isLoading.value = true;\n  error.value = '';\n  adaptiveQuestions.value = [];\n  predictedScore.value = null;\n  quizStarted.value = false;\n  userResponses.value = [];\n  extractedContent.value = '';\n\n  try {\n    const fileContents = await Promise.all(\n      selectedFiles.value.map(file => readFileContent(file))\n    );\n\n    extractedContent.value = fileContents.join('\\n\\n');\n    const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n    \n    const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n    const processedQuiz = processQuizResponse(response, extractedContent.value);\n    \n    adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n    predictedScore.value = calculatePredictedScore();\n\n  } catch (err) {\n    error.value = `Error generating questions: ${err.response?.data?.error?.message || err.message}`;\n  } finally {\n    isLoading.value = false;\n  }\n};\n\nconst startQuiz = () => {\n  quizStarted.value = true;\n  quizFinished.value = false;\n};\n\nconst handleQuizComplete = (responses) => {\n  userResponses.value = responses;\n  quizStarted.value = false;\n  quizFinished.value = true;\n};\n\nconst restartQuiz = () => {\n  quizStarted.value = true;\n  quizFinished.value = false;\n  userResponses.value = [];\n};\n\nconst resetToMainScreen = () => {\n  selectedFiles.value = [];\n  unsupportedFiles.value = [];\n  extractionErrors.value = [];\n  questionCount.value = '';\n  error.value = '';\n  isLoading.value = false;\n  predictedScore.value = null;\n  quizStarted.value = false;\n  quizFinished.value = false;\n  adaptiveQuestions.value = [];\n  userResponses.value = [];\n  if (fileInput.value) {\n    fileInput.value.value = '';\n  }\n};\n\n// Helper functions\nasync function readFileContent(file) {\n  return new Promise((resolve) => {\n    if (\n      file.type === \"application/pdf\" ||\n      file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" ||\n      file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" ||\n      file.type.startsWith('image/')\n    ) {\n      const formData = new FormData();\n      formData.append('file', file);\n      \n      const backendUrl = process.env.VUE_APP_BACKEND_URL || 'http://localhost:5001';\n      fetch(`${backendUrl}/extract-file`, {\n        method: 'POST',\n        body: formData\n      })\n        .then(res => res.json())\n        .then(data => {\n          if (data.text) {\n            resolve(data.text);\n          } else {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: data.error || 'Failed to extract text from file'\n            });\n            resolve(\"[Could not extract file text]\");\n          }\n        })\n        .catch(() => {\n          extractionErrors.value.push({\n            fileName: file.name,\n            message: 'Server error while extracting text'\n          });\n          resolve(\"[Could not extract file text]\");\n        });\n    } else if (file.type === \"text/plain\") {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target.result);\n      reader.onerror = () => {\n        extractionErrors.value.push({\n          fileName: file.name,\n          message: 'Error reading text file'\n        });\n        resolve(\"[Could not read file]\");\n      };\n      reader.readAsText(file);\n    } else {\n      resolve(`[${file.name} is not a supported file type.]`);\n    }\n  });\n}\n\nasync function generateQuestions(content, count) {\n  const prompt = `Create a quiz with ${count} COMPLETELY UNIQUE and DIVERSE questions based on this text. Each question MUST cover a different concept or aspect. NO REPETITIVE or SIMILAR questions allowed.\n\nCRITICAL REQUIREMENTS:\n1. Each explanation MUST be a direct quote or paraphrased content from the original text\n2. Explanations should reference specific parts of the text that justify the correct answer\n3. Do NOT make up explanations - they must be based on the actual content provided\n4. If a concept isn't clearly explained in the text, don't create a question about it\n5. Automatically determine appropriate difficulty (easy/medium/hard) based on:\n   - Easy: Basic facts, definitions, or simple concepts\n   - Medium: Understanding relationships between concepts\n   - Hard: Analysis, evaluation, or complex relationships\n\nFormat requirements for each question:\n\nFor multiple choice questions:\n1. Question: [unique question text]\n2. Options (mark correct with *):\n   A) [option]\n   B) [option]\n   C) [option]\n   D) [option]\n3. Explanation: [quote or paraphrase relevant text that explains the correct answer]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nFor true/false questions:\n1. True/False: [unique question text]\n2. Answer: [Write ONLY \"True*\" if true is correct, or \"False*\" if false is correct]\n3. Explanation: [quote or paraphrase relevant text that explains why the statement is true or false]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nIMPORTANT:\n- Each question MUST cover a different topic/concept\n- NO similar or overlapping questions\n- Make questions engaging and thought-provoking\n- Ensure clear, unambiguous wording\n- ALL explanations must come from the provided text\n- For true/false questions, ALWAYS mark the correct answer with an asterisk (*)\n- Distribute difficulties naturally based on content complexity\n\nText to base questions on:\n${content}`;\n\n  const response = await axios.post(\n    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.VUE_APP_GEMINI_API_KEY}`,\n    {\n      contents: [{\n        parts: [{\n          text: prompt\n        }]\n      }],\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 2048,\n      }\n    },\n    {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }\n  );\n\n  return response.data.candidates[0].content.parts[0].text;\n}\n\nfunction processQuizResponse(response, content) {\n  const questions = [];\n  const lines = response.split('\\n');\n  let currentQuestion = null;\n  let collectingOptions = false;\n  \n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    \n    if (/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i.test(line)) {\n      if (currentQuestion) {\n        findExplanationFromContent(currentQuestion, content);\n        questions.push(currentQuestion);\n      }\n      currentQuestion = {\n        text: line.replace(/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i, '').trim(),\n        type: 'multiple-choice',\n        options: {},\n        correctAnswer: '',\n        explanation: '',\n        difficulty: 'medium'\n      };\n      collectingOptions = true;\n    } else if (/^\\d*\\.?\\s*(True\\/False:|True or False:)/i.test(line)) {\n      if (currentQuestion) {\n        findExplanationFromContent(currentQuestion, content);\n        questions.push(currentQuestion);\n      }\n      currentQuestion = {\n        text: line.replace(/^\\d*\\.?\\s*(True\\/False:|True or False:)/i, '').trim(),\n        type: 'true-false',\n        options: { \n          'true': 'True',\n          'false': 'False'\n        },\n        correctAnswer: '',\n        explanation: '',\n        difficulty: 'medium'\n      };\n      collectingOptions = true;\n    } else if (currentQuestion && collectingOptions) {\n      if (currentQuestion.type === 'multiple-choice') {\n        const optionMatch = line.match(/^([A-Da-d])[).]\\s*(.*)/);\n        if (optionMatch) {\n          const letter = optionMatch[1].toUpperCase();\n          let option = optionMatch[2].trim();\n          \n          // Check for asterisk at start or end of option\n          if (option.startsWith('*') || option.endsWith('*')) {\n            currentQuestion.correctAnswer = letter;\n            option = option.replace(/^\\*|\\*$/g, '').trim();\n          }\n          currentQuestion.options[letter] = option;\n        } else if (line.toLowerCase().startsWith('explanation:')) {\n          collectingOptions = false;\n        }\n      } else if (currentQuestion.type === 'true-false') {\n        // Look for the Answer: line specifically\n        if (line.toLowerCase().startsWith('answer:')) {\n          const answer = line.substring(7).trim().toLowerCase();\n          if (answer.includes('true*') || answer.includes('*true')) {\n            currentQuestion.correctAnswer = 'true';\n          } else if (answer.includes('false*') || answer.includes('*false')) {\n            currentQuestion.correctAnswer = 'false';\n          }\n        } else if (line.toLowerCase().startsWith('explanation:')) {\n          collectingOptions = false;\n        }\n      }\n    }\n  }\n  \n  if (currentQuestion) {\n    findExplanationFromContent(currentQuestion, content);\n    questions.push(currentQuestion);\n  }\n\n  // Validate and fix questions\n  const validQuestions = questions.filter(q => {\n    if (q.type === 'multiple-choice') {\n      // Must have at least 2 options and a correct answer\n      const hasEnoughOptions = Object.keys(q.options).length >= 2;\n      if (!hasEnoughOptions || !q.correctAnswer) {\n        console.warn('Invalid multiple choice question:', q);\n        return false;\n      }\n      return true;\n    } else if (q.type === 'true-false') {\n      // For true/false questions, try to infer the answer from the explanation if not explicitly set\n      if (!q.correctAnswer && q.explanation) {\n        const lowerExplanation = q.explanation.toLowerCase();\n        if (lowerExplanation.includes('this statement is true')) {\n          q.correctAnswer = 'true';\n        } else if (lowerExplanation.includes('this statement is false')) {\n          q.correctAnswer = 'false';\n        }\n      }\n      \n      // If still no answer, warn and default to false (since defaulting to true might be misleading)\n      if (!q.correctAnswer) {\n        console.warn('True/False question missing correct answer, inferring from context:', q);\n        // Look for negative indicators in the question\n        const questionLower = q.text.toLowerCase();\n        const hasNegativeIndicators = ['only', 'solely', 'never', 'always', 'all', 'none'].some(word => \n          questionLower.includes(word)\n        );\n        q.correctAnswer = hasNegativeIndicators ? 'false' : 'true';\n      }\n      return true;\n    }\n    return false;\n  });\n\n  if (validQuestions.length === 0) {\n    throw new Error('No valid questions could be generated from the content.');\n  }\n  \n  return { questions: validQuestions };\n}\n\nfunction findExplanationFromContent(question, content) {\n  // Split content into paragraphs\n  const paragraphs = content.split(/\\n\\s*\\n/);\n  \n  // Create search terms from the question and answer\n  const searchTerms = [\n    ...question.text.toLowerCase().replace(/[.,?!]/g, '').split(' '),\n    ...(question.type === 'multiple-choice' && question.options[question.correctAnswer] \n      ? question.options[question.correctAnswer].toLowerCase().split(' ') \n      : [])\n  ].filter(word => word.length > 3);\n  \n  // Find relevant paragraphs with scoring\n  const relevantParagraphs = paragraphs.map(paragraph => {\n    const normalizedParagraph = paragraph.toLowerCase();\n    let score = 0;\n    let keywordMatches = new Set();\n    \n    // Score exact phrase matches higher\n    if (normalizedParagraph.includes(question.text.toLowerCase())) {\n      score += 15;\n    }\n    \n    // Score keyword matches\n    searchTerms.forEach(term => {\n      if (normalizedParagraph.includes(term)) {\n        score += 2;\n        keywordMatches.add(term);\n        \n        // Bonus for keywords near each other\n        searchTerms.forEach(otherTerm => {\n          if (term !== otherTerm) {\n            const termIndex = normalizedParagraph.indexOf(term);\n            const otherIndex = normalizedParagraph.indexOf(otherTerm);\n            if (otherIndex !== -1 && Math.abs(termIndex - otherIndex) < 50) {\n              score += 1;\n            }\n          }\n        });\n      }\n    });\n\n    return {\n      text: paragraph.trim(),\n      score,\n      keywordMatches: Array.from(keywordMatches)\n    };\n  }).filter(p => p.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 2); // Get top 2 most relevant paragraphs\n\n  if (relevantParagraphs.length > 0) {\n    // Generate a more natural explanation\n    let explanation = '';\n    \n    if (question.type === 'true-false') {\n      const isTrue = question.correctAnswer === 'true';\n      explanation = generateTrueFalseExplanation(\n        question.text,\n        isTrue,\n        relevantParagraphs\n      );\n    } else {\n      explanation = generateMultipleChoiceExplanation(\n        question,\n        relevantParagraphs\n      );\n    }\n    \n    question.explanation = explanation;\n  } else {\n    // Improved fallback explanations\n    if (question.type === 'true-false') {\n      const isTrue = question.correctAnswer === 'true';\n      question.explanation = `This statement is ${isTrue ? 'true' : 'false'}. While reviewing the content, consider how this relates to the main concepts presented.`;\n    } else {\n      const correctOption = question.options[question.correctAnswer];\n      question.explanation = `The correct answer is \"${correctOption}\". Consider reviewing the material again, focusing on this concept and related topics.`;\n    }\n  }\n}\n\nfunction rephraseContent(text, isSupporting) {\n  // Clean and normalize the text\n  let cleaned = text.trim()\n    .replace(/^(however|moreover|furthermore|therefore|thus|hence|consequently),?\\s*/i, '')\n    .replace(/[\"\"\"]/g, '\"')\n    .trim();\n\n  // Capitalize first letter if needed\n  cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);\n\n  // Enhanced contextual phrases for better explanations\n  const contextPhrases = isSupporting ? [\n    \"According to the material, \",\n    \"The key point here is that \",\n    \"To understand this better, note that \",\n    \"What's important to recognize is that \",\n    \"The text specifically mentions that \",\n    \"A crucial detail from the content is that \",\n    \"To explain this concept, we can see that \",\n    \"The correct answer is supported by the fact that \"\n  ] : [\n    \"This answer is incorrect because \",\n    \"The text actually indicates that \",\n    \"This choice contradicts the material, which states that \",\n    \"This is not accurate because the content shows that \",\n    \"We can see this is wrong because \",\n    \"The material provides evidence against this by stating that \",\n    \"This option is misleading because \",\n    \"This doesn't align with the text, which explains that \"\n  ];\n\n  // Select a phrase that best matches the content length and complexity\n  let selectedPhrase;\n  if (cleaned.length > 100) {\n    // For longer explanations, use phrases that introduce complex ideas\n    selectedPhrase = contextPhrases.find(phrase => \n      phrase.includes(\"understand\") || phrase.includes(\"concept\") || phrase.includes(\"recognize\")\n    ) || contextPhrases[0];\n  } else {\n    // For shorter explanations, use more direct phrases\n    selectedPhrase = contextPhrases.find(phrase => \n      !phrase.includes(\"understand\") && !phrase.includes(\"concept\")\n    ) || contextPhrases[0];\n  }\n\n  // Add educational connectors for better flow\n  const connectors = [\n    \". This helps us understand that \",\n    \". This demonstrates that \",\n    \". This indicates that \",\n    \". This shows us that \",\n    \". This means that \"\n  ];\n\n  // Split the cleaned text into sentences\n  const sentences = cleaned.split(/(?<=[.!?])\\s+/);\n  \n  if (sentences.length > 1) {\n    // If we have multiple sentences, connect them meaningfully\n    const mainPoint = sentences[0];\n    const supportingPoint = sentences[1];\n    const connector = connectors[Math.floor(Math.random() * connectors.length)];\n    \n    return `${selectedPhrase}${mainPoint}${connector}${supportingPoint.toLowerCase()}`;\n  }\n\n  return `${selectedPhrase}${cleaned}`;\n}\n\nfunction generateMultipleChoiceExplanation(question, relevantParagraphs) {\n  const correctOption = question.options[question.correctAnswer];\n  \n  let explanation = `Let's understand why \"${correctOption}\" is the correct answer.\\n\\n`;\n  \n  // Add context about why this option is correct\n  relevantParagraphs.forEach((para, index) => {\n    const transition = index === 0 \n      ? \"\" \n      : \"\\nFurthermore, \";\n    \n    // Extract and rephrase relevant content\n    const sentences = para.text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    const relevantSentences = sentences.filter(s => \n      para.keywordMatches.some(keyword => \n        s.toLowerCase().includes(keyword)\n      )\n    );\n\n    // Use the most relevant sentence or fall back to the first one\n    const bestSentence = relevantSentences[0] || sentences[0];\n    explanation += transition + rephraseContent(bestSentence, true);\n  });\n\n  // Explain why other options are incorrect using specific content\n  const incorrectOptions = Object.entries(question.options)\n    .filter(([key]) => key !== question.correctAnswer)\n    .map(([, text]) => text);\n\n  if (incorrectOptions.length > 0) {\n    explanation += \"\\n\\nLet's examine why the other options are incorrect:\";\n    incorrectOptions.forEach(option => {\n      explanation += `\\n• The option \"${option}\" is not correct because it misinterprets the key concepts presented in the material. ${rephraseContent(relevantParagraphs[0].text, false)}`;\n    });\n  }\n\n  // Add a learning tip that connects to the specific topic\n  const topicKeywords = question.text.toLowerCase().split(' ').filter(word => word.length > 4);\n  explanation += `\\n\\nKey Learning Point: When studying ${topicKeywords[0] || 'this topic'}, focus on understanding how it connects to ${topicKeywords[1] || 'related concepts'} in the material.`;\n  \n  return explanation;\n}\n\nfunction generateTrueFalseExplanation(statement, isTrue, relevantParagraphs) {\n  const introPhrase = isTrue \n    ? \"This statement is correct, and here's why:\" \n    : \"This statement is incorrect. Let's understand the reason:\";\n\n  let explanation = `${introPhrase}\\n\\n`;\n  \n  relevantParagraphs.forEach((para, index) => {\n    // Extract the most relevant sentences\n    const sentences = para.text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n    const relevantSentences = sentences.filter(s => \n      para.keywordMatches.some(keyword => \n        s.toLowerCase().includes(keyword)\n      )\n    );\n\n    // Use the best matching sentence or fall back to the first one\n    const bestSentence = relevantSentences[0] || sentences[0];\n    \n    const transition = index === 0 \n      ? \"\" \n      : \"\\nAdditionally, \";\n    \n    explanation += transition + rephraseContent(bestSentence, isTrue);\n  });\n\n  // Add a specific learning tip based on the statement content\n  const topicWords = statement.toLowerCase().split(' ').filter(word => word.length > 4);\n  const topic = topicWords[0] || 'this concept';\n  \n  explanation += `\\n\\nTo deepen your understanding: Consider how ${topic} relates to the broader context and try to identify similar examples in the material.`;\n  \n  return explanation;\n}\n\nfunction selectQuestions(questions) {\n  const shuffledQuestions = [...questions]\n    .sort(() => Math.random() - 0.5)\n    .filter((question, index, self) => \n      index === self.findIndex((q) => \n        q.text.toLowerCase().replace(/[^\\w\\s]/g, '') === \n        question.text.toLowerCase().replace(/[^\\w\\s]/g, '')\n      )\n    );\n\n  const selectedQuestions = [];\n  const targetPerDifficulty = Math.ceil(Number(questionCount.value) / 3);\n  const difficultyCount = { easy: 0, medium: 0, hard: 0 };\n\n  for (const difficulty of ['easy', 'medium', 'hard']) {\n    const questionsOfDifficulty = shuffledQuestions.filter(q => \n      q.difficulty === difficulty && !selectedQuestions.includes(q)\n    );\n    \n    for (const question of questionsOfDifficulty) {\n      if (difficultyCount[difficulty] < targetPerDifficulty && \n          selectedQuestions.length < Number(questionCount.value)) {\n        selectedQuestions.push(question);\n        difficultyCount[difficulty]++;\n      }\n    }\n  }\n\n  while (selectedQuestions.length < Number(questionCount.value)) {\n    const remainingQuestion = shuffledQuestions.find(q => !selectedQuestions.includes(q));\n    if (remainingQuestion) {\n      selectedQuestions.push(remainingQuestion);\n    } else {\n      break;\n    }\n  }\n\n  return selectedQuestions;\n}\n\nfunction calculatePredictedScore() {\n  const contentCoverage = analyzeContentForCoverage();\n  const contentComplexity = analyzeContentComplexity();\n  const questionDiversity = analyzeQuestionDiversity();\n  \n  // Weight factors\n  const coverageWeight = 0.4;\n  const complexityWeight = 0.3;\n  const diversityWeight = 0.3;\n  \n  // Calculate weighted score\n  const predictedScore = (\n    contentCoverage * coverageWeight +\n    contentComplexity * complexityWeight +\n    questionDiversity * diversityWeight\n  );\n  \n  return Math.max(0, Math.min(100, Math.round(predictedScore)));\n}\n\nfunction analyzeContentForCoverage() {\n  // Analyze how well the content matches with generated questions\n  const totalContent = extractedContent.value.length;\n  if (totalContent === 0) return 0;\n  \n  // Calculate coverage based on content length and number of questions\n  const averageContentPerQuestion = 500; // baseline characters per question\n  const expectedQuestions = Math.ceil(totalContent / averageContentPerQuestion);\n  const actualQuestions = Number(questionCount.value);\n  \n  const coverage = Math.min(actualQuestions / expectedQuestions, 1) * 100;\n  return coverage;\n}\n\nfunction analyzeContentComplexity() {\n  const content = extractedContent.value.toLowerCase();\n  \n  // Define complexity indicators\n  const complexityIndicators = [\n    'analyze', 'compare', 'contrast', 'evaluate', 'explain',\n    'describe', 'discuss', 'examine', 'interpret', 'justify',\n    'therefore', 'however', 'although', 'furthermore', 'consequently'\n  ];\n  \n  // Count complexity indicators\n  let complexityScore = 0;\n  complexityIndicators.forEach(indicator => {\n    const regex = new RegExp(indicator, 'g');\n    const matches = content.match(regex);\n    if (matches) {\n      complexityScore += matches.length;\n    }\n  });\n  \n  // Normalize score to 0-100 range\n  const normalizedScore = Math.min(complexityScore * 5, 100);\n  return normalizedScore;\n}\n\nfunction analyzeQuestionDiversity() {\n  if (!adaptiveQuestions.value.length) return 0;\n  \n  // Count different types of questions\n  const types = new Set(adaptiveQuestions.value.map(q => q.type));\n  const typesDiversity = (types.size / 2) * 50; // 2 is max types (multiple-choice and true-false)\n  \n  // Analyze question text similarity to ensure diverse topics\n  const questionTexts = adaptiveQuestions.value.map(q => q.text.toLowerCase());\n  let uniqueTopics = 0;\n  const processedKeywords = new Set();\n  \n  questionTexts.forEach(text => {\n    const keywords = text.split(' ')\n      .filter(word => word.length > 4) // Consider only significant words\n      .map(word => word.replace(/[^a-z]/g, '')); // Clean up words\n      \n    keywords.forEach(keyword => {\n      if (!processedKeywords.has(keyword)) {\n        uniqueTopics++;\n        processedKeywords.add(keyword);\n      }\n    });\n  });\n  \n  const topicsDiversity = Math.min(uniqueTopics / questionTexts.length * 50, 50);\n  \n  return typesDiversity + topicsDiversity;\n}\n\n// Results formatting\nconst formatQuestionsForResults = computed(() => {\n  return adaptiveQuestions.value.map((q, index) => ({\n    text: q.text,\n    type: q.type,\n    options: q.options,\n    userAnswer: userResponses.value[index]?.userAnswer,\n    correctAnswer: q.correctAnswer,\n    explanation: q.explanation,\n    isCorrect: userResponses.value[index]?.correct\n  }));\n});\n\nconst formatUserAnswersForResults = computed(() => {\n  return userResponses.value.map(r => r.userAnswer);\n});\n\nconst correctAnswersCount = computed(() => {\n  return userResponses.value.filter(r => r.correct).length;\n});\n</script>\n\n<style scoped>\n.app-container {\n  min-height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: #f5f5f5;\n  font-family: \"Helvetica\", \"Arial\", sans-serif;\n}\n\n.upload-container {\n  background-color: white;\n  padding: 2rem;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 90%;\n  max-width: 600px;\n}\n\nh1 {\n  text-align: center;\n  color: #333;\n  margin-bottom: 2rem;\n}\n\nh2 {\n  color: #444;\n  margin-bottom: 1rem;\n}\n\n.file-upload-section {\n  margin-bottom: 2rem;\n}\n\n.upload-area {\n  border: 2px dashed #ccc;\n  border-radius: 8px;\n  padding: 2rem;\n  text-align: center;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  margin-bottom: 1rem;\n  outline: none;\n}\n\n.upload-area:hover {\n  border-color: #666;\n  background-color: #f8f8f8;\n}\n\n.upload-area:focus {\n  border-color: #4CAF50;\n  box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\n}\n\n.file-input {\n  display: none;\n}\n\n.upload-prompt {\n  color: #666;\n}\n\n.upload-prompt p {\n  margin: 0.5rem 0;\n}\n\n.selected-files {\n  margin-top: 1rem;\n}\n\n.selected-files ul {\n  list-style: none;\n  padding: 0;\n}\n\n.selected-files li {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.5rem;\n  background-color: #f8f8f8;\n  margin-bottom: 0.5rem;\n  border-radius: 4px;\n}\n\n.remove-btn {\n  background: none;\n  border: none;\n  color: #ff4444;\n  cursor: pointer;\n  font-size: 1.2rem;\n  padding: 0 0.5rem;\n}\n\n.questions-section {\n  margin-top: 2rem;\n}\n\n.question-input input {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-size: 1rem;\n}\n\n.submit-btn {\n  width: 100%;\n  padding: 1rem;\n  background-color: #4CAF50;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  font-size: 1rem;\n  cursor: pointer;\n  margin-top: 2rem;\n  transition: background-color 0.3s;\n}\n\n.submit-btn:disabled {\n  background-color: #cccccc;\n  cursor: not-allowed;\n}\n\n.submit-btn:not(:disabled):hover {\n  background-color: #45a049;\n}\n\n.questions-list {\n  margin-top: 2rem;\n  padding: 1rem;\n  background-color: #f8f8f8;\n  border-radius: 4px;\n}\n\n.question-item {\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: white;\n  border-radius: 4px;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n.error-message {\n  color: #ff4444;\n  margin-top: 1rem;\n  text-align: center;\n}\n\n.quiz-container {\n  margin-top: 2rem;\n  padding: 2rem;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.question {\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: #f8f8f8;\n  border-radius: 4px;\n}\n\n.options {\n  display: flex;\n  flex-direction: column;\n  gap: 0.8rem;\n  margin: 1.5rem 0;\n}\n\n.options.true-false {\n  flex-direction: row;\n  justify-content: center;\n  gap: 1.5rem;\n}\n\n.option-btn {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  padding: 1rem;\n  border: 2px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: white;\n  color: #333;\n  cursor: pointer;\n  font-size: 1rem;\n  text-align: left;\n  transition: all 0.2s ease;\n}\n\n.options.true-false .option-btn {\n  width: auto;\n  min-width: 120px;\n  justify-content: center;\n  font-size: 1.1rem;\n  font-weight: 500;\n}\n\n.option-letter {\n  background-color: #f5f5f5;\n  color: #666;\n  width: 30px;\n  height: 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 50%;\n  margin-right: 1rem;\n  font-weight: 600;\n}\n\n.option-text {\n  flex: 1;\n}\n\n.option-btn:hover:not(:disabled) {\n  border-color: #2196F3;\n  background-color: #f8f9fa;\n}\n\n.option-btn.selected {\n  border-color: #2196F3;\n  background-color: #e3f2fd;\n}\n\n.option-btn.correct {\n  border-color: #4CAF50;\n  background-color: #E8F5E9;\n  color: #2E7D32;\n}\n\n.option-btn.incorrect {\n  border-color: #f44336;\n  background-color: #FFEBEE;\n  color: #c62828;\n}\n\n.feedback {\n  margin-top: 1.5rem;\n  text-align: center;\n}\n\n.correct-text {\n  color: #4CAF50;\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0.5rem 0;\n}\n\n.incorrect-text {\n  color: #f44336;\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0.5rem 0;\n}\n\n.next-btn {\n  background-color: #2196F3;\n  color: white;\n  border: none;\n  padding: 0.8rem 2rem;\n  border-radius: 25px;\n  cursor: pointer;\n  font-size: 1rem;\n  margin-top: 1rem;\n  transition: all 0.2s ease;\n}\n\n.next-btn:hover {\n  background-color: #1976D2;\n  transform: translateY(-1px);\n}\n\n.quiz-progress {\n  margin-bottom: 2rem;\n}\n\n.progress-bar {\n  width: 100%;\n  height: 8px;\n  background-color: #e0e0e0;\n  border-radius: 4px;\n  overflow: hidden;\n  margin-bottom: 0.5rem;\n}\n\n.progress-fill {\n  height: 100%;\n  background-color: #4CAF50;\n  transition: width 0.3s ease;\n}\n\n.progress-text {\n  display: block;\n  text-align: center;\n  color: #666;\n  font-size: 0.9rem;\n}\n\n.next-btn {\n  width: auto;\n  min-width: 150px;\n  margin-top: 1rem;\n}\n\n.quiz-results {\n  padding: 2rem;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.score-summary {\n  text-align: center;\n  margin-bottom: 2rem;\n  padding: 1rem;\n  background-color: #f5f5f5;\n  border-radius: 8px;\n}\n\n.questions-review {\n  margin-top: 2rem;\n}\n\n.question-review {\n  margin-bottom: 2rem;\n  padding: 1rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: #fff;\n}\n\n.question-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid #e0e0e0;\n}\n\n.question-number {\n  font-weight: bold;\n  color: #666;\n}\n\n.answer-status {\n  padding: 0.25rem 0.75rem;\n  border-radius: 4px;\n  font-weight: bold;\n}\n\n.answer-status.correct {\n  background-color: #E8F5E9;\n  color: #2E7D32;\n}\n\n.answer-status.incorrect {\n  background-color: #FFEBEE;\n  color: #C62828;\n}\n\n.question-text {\n  font-size: 1.1rem;\n  margin-bottom: 1rem;\n  color: #333;\n}\n\n.answer-details {\n  background-color: #f8f9fa;\n  padding: 1rem;\n  border-radius: 4px;\n}\n\n.your-answer, .correct-answer {\n  margin-bottom: 0.5rem;\n}\n\n.question-explanation {\n  margin-top: 1rem;\n  padding-top: 1rem;\n  border-top: 1px solid #e0e0e0;\n}\n\n.explanation-text {\n  margin-top: 1rem;\n  padding: 1rem;\n  background-color: #f8f9fa;\n  border-left: 3px solid #2196F3;\n  border-radius: 4px;\n  color: #333;\n  font-size: 0.95rem;\n  line-height: 1.5;\n}\n\n.explanation-text p {\n  margin: 0.5rem 0;\n}\n\n.explanation-text strong {\n  color: #2196F3;\n}\n\n.supported-formats {\n  margin-top: 1rem;\n  text-align: left;\n  display: inline-block;\n}\n\n.supported-formats ul {\n  list-style: none;\n  padding: 0;\n  margin: 0.5rem 0;\n}\n\n.supported-formats li {\n  margin: 0.3rem 0;\n  color: #555;\n}\n\n.format-icon {\n  margin-right: 0.5rem;\n}\n\n.predicted-score-container {\n  text-align: center;\n  padding: 2rem;\n  background-color: #fff;\n  border-radius: 12px;\n  box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n}\n\n.score-prediction {\n  margin: 2rem 0;\n}\n\n.score-circle {\n  width: 180px;\n  height: 180px;\n  border-radius: 50%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin: 0 auto;\n  transition: all 0.3s ease;\n}\n\n.score-circle.high {\n  background-color: #e8f5e9;\n  border: 4px solid #4CAF50;\n}\n\n.score-circle.medium {\n  background-color: #fff3e0;\n  border: 4px solid #ff9800;\n}\n\n.score-circle.low {\n  background-color: #ffebee;\n  border: 4px solid #f44336;\n}\n\n.predicted-value {\n  font-size: 3rem;\n  font-weight: bold;\n  line-height: 1;\n  margin-bottom: 0.5rem;\n}\n\n.prediction-label {\n  font-size: 1rem;\n  opacity: 0.8;\n}\n\n.prediction-explanation {\n  color: #666;\n  margin: 1.5rem 0;\n  font-size: 1.1rem;\n  line-height: 1.5;\n}\n\n.start-quiz-btn {\n  background-color: #2196F3;\n  color: white;\n  padding: 1rem 2.5rem;\n  border: none;\n  border-radius: 25px;\n  font-size: 1.2rem;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);\n}\n\n.start-quiz-btn:hover {\n  background-color: #1976D2;\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(33, 150, 243, 0.4);\n}\n</style> "],"mappings":"AAmHA,SAASA,GAAG,EAAEC,QAAQ,QAAQ,KAAK;AACnC,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,gBAAgB,MAAM,mCAAmC;AAChE,OAAOC,WAAW,MAAM,8BAA8B;AACtD,OAAOC,aAAa,MAAM,gCAAgC;;AAE1D;;;;;;;;IACA,MAAMC,aAAa,GAAGN,GAAG,CAAC,EAAE,CAAC;IAC7B,MAAMO,SAAS,GAAGP,GAAG,CAAC,IAAI,CAAC;IAC3B,MAAMQ,gBAAgB,GAAGR,GAAG,CAAC,EAAE,CAAC;IAChC,MAAMS,gBAAgB,GAAGT,GAAG,CAAC,EAAE,CAAC;;IAEhC;IACA,MAAMU,aAAa,GAAGV,GAAG,CAAC,EAAE,CAAC;IAC7B,MAAMW,SAAS,GAAGX,GAAG,CAAC,KAAK,CAAC;IAC5B,MAAMY,KAAK,GAAGZ,GAAG,CAAC,EAAE,CAAC;IACrB,MAAMa,cAAc,GAAGb,GAAG,CAAC,IAAI,CAAC;IAChC,MAAMc,WAAW,GAAGd,GAAG,CAAC,KAAK,CAAC;IAC9B,MAAMe,YAAY,GAAGf,GAAG,CAAC,KAAK,CAAC;IAC/B,MAAMgB,iBAAiB,GAAGhB,GAAG,CAAC,EAAE,CAAC;IACjC,MAAMiB,aAAa,GAAGjB,GAAG,CAAC,EAAE,CAAC;IAC7B,MAAMkB,gBAAgB,GAAGlB,GAAG,CAAC,EAAE,CAAC;;IAEhC;IACA,MAAMmB,WAAW,GAAGlB,QAAQ,CAAC,MAAM;MACjC,OAAOK,aAAa,CAACc,KAAK,CAACC,MAAM,GAAG,CAAC,IAAIX,aAAa,CAACU,KAAK,GAAG,CAAC;IAClE,CAAC,CAAC;IAEF,MAAME,aAAa,GAAGrB,QAAQ,CAAC,MAAM;MACnC,OAAOQ,gBAAgB,CAACW,KAAK,CAACC,MAAM,GAAG,CAAC,IAAIb,gBAAgB,CAACY,KAAK,CAACC,MAAM,GAAG,CAAC;IAC/E,CAAC,CAAC;IAEF,MAAME,sBAAsB,GAAGtB,QAAQ,CAAC,MAAM;MAC5C,IAAIY,cAAc,CAACO,KAAK,IAAI,EAAE,EAAE,OAAO,MAAM;MAC7C,IAAIP,cAAc,CAACO,KAAK,IAAI,EAAE,EAAE,OAAO,QAAQ;MAC/C,OAAO,KAAK;IACd,CAAC,CAAC;;IAEF;IACA,MAAMI,gBAAgB,GAAGA,CAAA,KAAM;MAC7BjB,SAAS,CAACa,KAAK,CAACK,KAAK,CAAC,CAAC;IACzB,CAAC;IAED,MAAMC,gBAAgB,GAAIC,KAAK,IAAK;MAClC,MAAMC,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACH,KAAK,CAACI,MAAM,CAACH,KAAK,CAAC;MAC5CI,QAAQ,CAACJ,KAAK,CAAC;IACjB,CAAC;IAED,MAAMK,UAAU,GAAIN,KAAK,IAAK;MAC5B,MAAMC,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACH,KAAK,CAACO,YAAY,CAACN,KAAK,CAAC;MAClDI,QAAQ,CAACJ,KAAK,CAAC;IACjB,CAAC;IAED,MAAMI,QAAQ,GAAIJ,KAAK,IAAK;MAC1B,MAAMO,UAAU,GAAG,CACjB,oBAAoB,EACpB,yEAAyE,EACzE,+BAA+B,EAC/B,2EAA2E,EAC3E,YAAY,EACZ,iBAAiB,EACjB,WAAW,EACX,YAAY,EACZ,WAAW,EACX,YAAY,EACZ,WAAU,CACX;MAED,MAAMC,UAAU,GAAG,EAAE;MACrB,MAAMC,YAAY,GAAG,EAAE;MAEvBT,KAAK,CAACU,OAAO,CAACC,IAAI,IAAI;QACpB,IAAIJ,UAAU,CAACK,QAAQ,CAACD,IAAI,CAACE,IAAI,CAAC,EAAE;UAClCL,UAAU,CAACM,IAAI,CAACH,IAAI,CAAC;QACvB,CAAC,MAAM;UACLF,YAAY,CAACK,IAAI,CAACH,IAAI,CAAC;QACzB;MACF,CAAC,CAAC;MAEFjC,aAAa,CAACc,KAAK,GAAG,CAAC,GAAGd,aAAa,CAACc,KAAK,EAAE,GAAGgB,UAAU,CAAC;MAC7D5B,gBAAgB,CAACY,KAAK,GAAG,CAAC,GAAGZ,gBAAgB,CAACY,KAAK,EAAE,GAAGiB,YAAY,CAAC;IACvE,CAAC;IAED,MAAMM,UAAU,GAAIC,KAAK,IAAK;MAC5BtC,aAAa,CAACc,KAAK,CAACyB,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IACtC,CAAC;;IAED;IACA,MAAME,YAAY,GAAG,MAAAA,CAAA,KAAY;MAC/B,IAAI,CAAC3B,WAAW,CAACC,KAAK,EAAE;MAExBT,SAAS,CAACS,KAAK,GAAG,IAAI;MACtBR,KAAK,CAACQ,KAAK,GAAG,EAAE;MAChBJ,iBAAiB,CAACI,KAAK,GAAG,EAAE;MAC5BP,cAAc,CAACO,KAAK,GAAG,IAAI;MAC3BN,WAAW,CAACM,KAAK,GAAG,KAAK;MACzBH,aAAa,CAACG,KAAK,GAAG,EAAE;MACxBF,gBAAgB,CAACE,KAAK,GAAG,EAAE;MAE3B,IAAI;QACF,MAAM2B,YAAY,GAAG,MAAMC,OAAO,CAACC,GAAG,CACpC3C,aAAa,CAACc,KAAK,CAAC8B,GAAG,CAACX,IAAI,IAAIY,eAAe,CAACZ,IAAI,CAAC,CACvD,CAAC;QAEDrB,gBAAgB,CAACE,KAAK,GAAG2B,YAAY,CAACK,IAAI,CAAC,MAAM,CAAC;QAClD,MAAMC,sBAAsB,GAAGC,IAAI,CAACC,GAAG,CAACC,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;QAE5E,MAAMqC,QAAQ,GAAG,MAAMC,iBAAiB,CAACxC,gBAAgB,CAACE,KAAK,EAAEiC,sBAAsB,CAAC;QACxF,MAAMM,aAAa,GAAGC,mBAAmB,CAACH,QAAQ,EAAEvC,gBAAgB,CAACE,KAAK,CAAC;QAE3EJ,iBAAiB,CAACI,KAAK,GAAGyC,eAAe,CAACF,aAAa,CAACG,SAAS,CAAC;QAClEjD,cAAc,CAACO,KAAK,GAAG2C,uBAAuB,CAAC,CAAC;MAElD,CAAC,CAAC,OAAOC,GAAG,EAAE;QACZpD,KAAK,CAACQ,KAAK,GAAG,+BAA+B4C,GAAG,CAACP,QAAQ,EAAEQ,IAAI,EAAErD,KAAK,EAAEsD,OAAO,IAAIF,GAAG,CAACE,OAAO,EAAE;MAClG,CAAC,SAAS;QACRvD,SAAS,CAACS,KAAK,GAAG,KAAK;MACzB;IACF,CAAC;IAED,MAAM+C,SAAS,GAAGA,CAAA,KAAM;MACtBrD,WAAW,CAACM,KAAK,GAAG,IAAI;MACxBL,YAAY,CAACK,KAAK,GAAG,KAAK;IAC5B,CAAC;IAED,MAAMgD,kBAAkB,GAAIC,SAAS,IAAK;MACxCpD,aAAa,CAACG,KAAK,GAAGiD,SAAS;MAC/BvD,WAAW,CAACM,KAAK,GAAG,KAAK;MACzBL,YAAY,CAACK,KAAK,GAAG,IAAI;IAC3B,CAAC;IAED,MAAMkD,WAAW,GAAGA,CAAA,KAAM;MACxBxD,WAAW,CAACM,KAAK,GAAG,IAAI;MACxBL,YAAY,CAACK,KAAK,GAAG,KAAK;MAC1BH,aAAa,CAACG,KAAK,GAAG,EAAE;IAC1B,CAAC;IAED,MAAMmD,iBAAiB,GAAGA,CAAA,KAAM;MAC9BjE,aAAa,CAACc,KAAK,GAAG,EAAE;MACxBZ,gBAAgB,CAACY,KAAK,GAAG,EAAE;MAC3BX,gBAAgB,CAACW,KAAK,GAAG,EAAE;MAC3BV,aAAa,CAACU,KAAK,GAAG,EAAE;MACxBR,KAAK,CAACQ,KAAK,GAAG,EAAE;MAChBT,SAAS,CAACS,KAAK,GAAG,KAAK;MACvBP,cAAc,CAACO,KAAK,GAAG,IAAI;MAC3BN,WAAW,CAACM,KAAK,GAAG,KAAK;MACzBL,YAAY,CAACK,KAAK,GAAG,KAAK;MAC1BJ,iBAAiB,CAACI,KAAK,GAAG,EAAE;MAC5BH,aAAa,CAACG,KAAK,GAAG,EAAE;MACxB,IAAIb,SAAS,CAACa,KAAK,EAAE;QACnBb,SAAS,CAACa,KAAK,CAACA,KAAK,GAAG,EAAE;MAC5B;IACF,CAAC;;IAED;IACA,eAAe+B,eAAeA,CAACZ,IAAI,EAAE;MACnC,OAAO,IAAIS,OAAO,CAAEwB,OAAO,IAAK;QAC9B,IACEjC,IAAI,CAACE,IAAI,KAAK,iBAAiB,IAC/BF,IAAI,CAACE,IAAI,KAAK,2EAA2E,IACzFF,IAAI,CAACE,IAAI,KAAK,yEAAyE,IACvFF,IAAI,CAACE,IAAI,CAACgC,UAAU,CAAC,QAAQ,GAC7B;UACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;UAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAErC,IAAI,CAAC;UAE7B,MAAMsC,UAAU,GAAGC,OAAO,CAACC,GAAG,CAACC,mBAAmB,IAAI,uBAAuB;UAC7EC,KAAK,CAAC,GAAGJ,UAAU,eAAe,EAAE;YAClCK,MAAM,EAAE,MAAM;YACdC,IAAI,EAAET;UACR,CAAC,EACEU,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,IAAI,CAAC,CAAC,EACtBF,IAAI,CAACnB,IAAI,IAAI;YACZ,IAAIA,IAAI,CAACsB,IAAI,EAAE;cACbf,OAAO,CAACP,IAAI,CAACsB,IAAI,CAAC;YACpB,CAAC,MAAM;cACL9E,gBAAgB,CAACW,KAAK,CAACsB,IAAI,CAAC;gBAC1B8C,QAAQ,EAAEjD,IAAI,CAACkD,IAAI;gBACnBvB,OAAO,EAAED,IAAI,CAACrD,KAAK,IAAI;cACzB,CAAC,CAAC;cACF4D,OAAO,CAAC,+BAA+B,CAAC;YAC1C;UACF,CAAC,EACAkB,KAAK,CAAC,MAAM;YACXjF,gBAAgB,CAACW,KAAK,CAACsB,IAAI,CAAC;cAC1B8C,QAAQ,EAAEjD,IAAI,CAACkD,IAAI;cACnBvB,OAAO,EAAE;YACX,CAAC,CAAC;YACFM,OAAO,CAAC,+BAA+B,CAAC;UAC1C,CAAC,CAAC;QACN,CAAC,MAAM,IAAIjC,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE;UACrC,MAAMkD,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;UAC/BD,MAAM,CAACE,MAAM,GAAIC,CAAC,IAAKtB,OAAO,CAACsB,CAAC,CAAC/D,MAAM,CAACgE,MAAM,CAAC;UAC/CJ,MAAM,CAACK,OAAO,GAAG,MAAM;YACrBvF,gBAAgB,CAACW,KAAK,CAACsB,IAAI,CAAC;cAC1B8C,QAAQ,EAAEjD,IAAI,CAACkD,IAAI;cACnBvB,OAAO,EAAE;YACX,CAAC,CAAC;YACFM,OAAO,CAAC,uBAAuB,CAAC;UAClC,CAAC;UACDmB,MAAM,CAACM,UAAU,CAAC1D,IAAI,CAAC;QACzB,CAAC,MAAM;UACLiC,OAAO,CAAC,IAAIjC,IAAI,CAACkD,IAAI,iCAAiC,CAAC;QACzD;MACF,CAAC,CAAC;IACJ;IAEA,eAAe/B,iBAAiBA,CAACwC,OAAO,EAAEC,KAAK,EAAE;MAC/C,MAAMC,MAAM,GAAG,sBAAsBD,KAAK;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAED,OAAO,EAAE;MAET,MAAMzC,QAAQ,GAAG,MAAMvD,KAAK,CAACmG,IAAI,CAC/B,gGAAgGvB,OAAO,CAACC,GAAG,CAACuB,sBAAsB,EAAE,EACpI;QACEC,QAAQ,EAAE,CAAC;UACTC,KAAK,EAAE,CAAC;YACNjB,IAAI,EAAEa;UACR,CAAC;QACH,CAAC,CAAC;QACFK,gBAAgB,EAAE;UAChBC,WAAW,EAAE,GAAG;UAChBC,IAAI,EAAE,EAAE;UACRC,IAAI,EAAE,IAAI;UACVC,eAAe,EAAE;QACnB;MACF,CAAC,EACD;QACEC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB;MACF,CACF,CAAC;MAED,OAAOrD,QAAQ,CAACQ,IAAI,CAAC8C,UAAU,CAAC,CAAC,CAAC,CAACb,OAAO,CAACM,KAAK,CAAC,CAAC,CAAC,CAACjB,IAAI;IAC1D;IAEA,SAAS3B,mBAAmBA,CAACH,QAAQ,EAAEyC,OAAO,EAAE;MAC9C,MAAMpC,SAAS,GAAG,EAAE;MACpB,MAAMkD,KAAK,GAAGvD,QAAQ,CAACwD,KAAK,CAAC,IAAI,CAAC;MAClC,IAAIC,eAAe,GAAG,IAAI;MAC1B,IAAIC,iBAAiB,GAAG,KAAK;MAE7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAAC3F,MAAM,EAAE+F,CAAC,EAAE,EAAE;QACrC,MAAMC,IAAI,GAAGL,KAAK,CAACI,CAAC,CAAC,CAACE,IAAI,CAAC,CAAC;QAC5B,IAAI,CAACD,IAAI,EAAE;QAEX,IAAI,0EAA0E,CAACE,IAAI,CAACF,IAAI,CAAC,EAAE;UACzF,IAAIH,eAAe,EAAE;YACnBM,0BAA0B,CAACN,eAAe,EAAEhB,OAAO,CAAC;YACpDpC,SAAS,CAACpB,IAAI,CAACwE,eAAe,CAAC;UACjC;UACAA,eAAe,GAAG;YAChB3B,IAAI,EAAE8B,IAAI,CAACI,OAAO,CAAC,0EAA0E,EAAE,EAAE,CAAC,CAACH,IAAI,CAAC,CAAC;YACzG7E,IAAI,EAAE,iBAAiB;YACvBiF,OAAO,EAAE,CAAC,CAAC;YACXC,aAAa,EAAE,EAAE;YACjBC,WAAW,EAAE,EAAE;YACfC,UAAU,EAAE;UACd,CAAC;UACDV,iBAAiB,GAAG,IAAI;QAC1B,CAAC,MAAM,IAAI,0CAA0C,CAACI,IAAI,CAACF,IAAI,CAAC,EAAE;UAChE,IAAIH,eAAe,EAAE;YACnBM,0BAA0B,CAACN,eAAe,EAAEhB,OAAO,CAAC;YACpDpC,SAAS,CAACpB,IAAI,CAACwE,eAAe,CAAC;UACjC;UACAA,eAAe,GAAG;YAChB3B,IAAI,EAAE8B,IAAI,CAACI,OAAO,CAAC,0CAA0C,EAAE,EAAE,CAAC,CAACH,IAAI,CAAC,CAAC;YACzE7E,IAAI,EAAE,YAAY;YAClBiF,OAAO,EAAE;cACP,MAAM,EAAE,MAAM;cACd,OAAO,EAAE;YACX,CAAC;YACDC,aAAa,EAAE,EAAE;YACjBC,WAAW,EAAE,EAAE;YACfC,UAAU,EAAE;UACd,CAAC;UACDV,iBAAiB,GAAG,IAAI;QAC1B,CAAC,MAAM,IAAID,eAAe,IAAIC,iBAAiB,EAAE;UAC/C,IAAID,eAAe,CAACzE,IAAI,KAAK,iBAAiB,EAAE;YAC9C,MAAMqF,WAAW,GAAGT,IAAI,CAACU,KAAK,CAAC,wBAAwB,CAAC;YACxD,IAAID,WAAW,EAAE;cACf,MAAME,MAAM,GAAGF,WAAW,CAAC,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC;cAC3C,IAAIC,MAAM,GAAGJ,WAAW,CAAC,CAAC,CAAC,CAACR,IAAI,CAAC,CAAC;;cAElC;cACA,IAAIY,MAAM,CAACzD,UAAU,CAAC,GAAG,CAAC,IAAIyD,MAAM,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAClDjB,eAAe,CAACS,aAAa,GAAGK,MAAM;gBACtCE,MAAM,GAAGA,MAAM,CAACT,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAACH,IAAI,CAAC,CAAC;cAChD;cACAJ,eAAe,CAACQ,OAAO,CAACM,MAAM,CAAC,GAAGE,MAAM;YAC1C,CAAC,MAAM,IAAIb,IAAI,CAACe,WAAW,CAAC,CAAC,CAAC3D,UAAU,CAAC,cAAc,CAAC,EAAE;cACxD0C,iBAAiB,GAAG,KAAK;YAC3B;UACF,CAAC,MAAM,IAAID,eAAe,CAACzE,IAAI,KAAK,YAAY,EAAE;YAChD;YACA,IAAI4E,IAAI,CAACe,WAAW,CAAC,CAAC,CAAC3D,UAAU,CAAC,SAAS,CAAC,EAAE;cAC5C,MAAM4D,MAAM,GAAGhB,IAAI,CAACiB,SAAS,CAAC,CAAC,CAAC,CAAChB,IAAI,CAAC,CAAC,CAACc,WAAW,CAAC,CAAC;cACrD,IAAIC,MAAM,CAAC7F,QAAQ,CAAC,OAAO,CAAC,IAAI6F,MAAM,CAAC7F,QAAQ,CAAC,OAAO,CAAC,EAAE;gBACxD0E,eAAe,CAACS,aAAa,GAAG,MAAM;cACxC,CAAC,MAAM,IAAIU,MAAM,CAAC7F,QAAQ,CAAC,QAAQ,CAAC,IAAI6F,MAAM,CAAC7F,QAAQ,CAAC,QAAQ,CAAC,EAAE;gBACjE0E,eAAe,CAACS,aAAa,GAAG,OAAO;cACzC;YACF,CAAC,MAAM,IAAIN,IAAI,CAACe,WAAW,CAAC,CAAC,CAAC3D,UAAU,CAAC,cAAc,CAAC,EAAE;cACxD0C,iBAAiB,GAAG,KAAK;YAC3B;UACF;QACF;MACF;MAEA,IAAID,eAAe,EAAE;QACnBM,0BAA0B,CAACN,eAAe,EAAEhB,OAAO,CAAC;QACpDpC,SAAS,CAACpB,IAAI,CAACwE,eAAe,CAAC;MACjC;;MAEA;MACA,MAAMqB,cAAc,GAAGzE,SAAS,CAAC0E,MAAM,CAACC,CAAC,IAAI;QAC3C,IAAIA,CAAC,CAAChG,IAAI,KAAK,iBAAiB,EAAE;UAChC;UACA,MAAMiG,gBAAgB,GAAGC,MAAM,CAACC,IAAI,CAACH,CAAC,CAACf,OAAO,CAAC,CAACrG,MAAM,IAAI,CAAC;UAC3D,IAAI,CAACqH,gBAAgB,IAAI,CAACD,CAAC,CAACd,aAAa,EAAE;YACzCkB,OAAO,CAACC,IAAI,CAAC,mCAAmC,EAAEL,CAAC,CAAC;YACpD,OAAO,KAAK;UACd;UACA,OAAO,IAAI;QACb,CAAC,MAAM,IAAIA,CAAC,CAAChG,IAAI,KAAK,YAAY,EAAE;UAClC;UACA,IAAI,CAACgG,CAAC,CAACd,aAAa,IAAIc,CAAC,CAACb,WAAW,EAAE;YACrC,MAAMmB,gBAAgB,GAAGN,CAAC,CAACb,WAAW,CAACQ,WAAW,CAAC,CAAC;YACpD,IAAIW,gBAAgB,CAACvG,QAAQ,CAAC,wBAAwB,CAAC,EAAE;cACvDiG,CAAC,CAACd,aAAa,GAAG,MAAM;YAC1B,CAAC,MAAM,IAAIoB,gBAAgB,CAACvG,QAAQ,CAAC,yBAAyB,CAAC,EAAE;cAC/DiG,CAAC,CAACd,aAAa,GAAG,OAAO;YAC3B;UACF;;UAEA;UACA,IAAI,CAACc,CAAC,CAACd,aAAa,EAAE;YACpBkB,OAAO,CAACC,IAAI,CAAC,qEAAqE,EAAEL,CAAC,CAAC;YACtF;YACA,MAAMO,aAAa,GAAGP,CAAC,CAAClD,IAAI,CAAC6C,WAAW,CAAC,CAAC;YAC1C,MAAMa,qBAAqB,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,CAAC,CAACC,IAAI,CAACC,IAAI,IAC1FH,aAAa,CAACxG,QAAQ,CAAC2G,IAAI,CAC7B,CAAC;YACDV,CAAC,CAACd,aAAa,GAAGsB,qBAAqB,GAAG,OAAO,GAAG,MAAM;UAC5D;UACA,OAAO,IAAI;QACb;QACA,OAAO,KAAK;MACd,CAAC,CAAC;MAEF,IAAIV,cAAc,CAAClH,MAAM,KAAK,CAAC,EAAE;QAC/B,MAAM,IAAI+H,KAAK,CAAC,yDAAyD,CAAC;MAC5E;MAEA,OAAO;QAAEtF,SAAS,EAAEyE;MAAe,CAAC;IACtC;IAEA,SAASf,0BAA0BA,CAAC6B,QAAQ,EAAEnD,OAAO,EAAE;MACrD;MACA,MAAMoD,UAAU,GAAGpD,OAAO,CAACe,KAAK,CAAC,SAAS,CAAC;;MAE3C;MACA,MAAMsC,WAAW,GAAG,CAClB,GAAGF,QAAQ,CAAC9D,IAAI,CAAC6C,WAAW,CAAC,CAAC,CAACX,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAACR,KAAK,CAAC,GAAG,CAAC,EAChE,IAAIoC,QAAQ,CAAC5G,IAAI,KAAK,iBAAiB,IAAI4G,QAAQ,CAAC3B,OAAO,CAAC2B,QAAQ,CAAC1B,aAAa,CAAC,GAC/E0B,QAAQ,CAAC3B,OAAO,CAAC2B,QAAQ,CAAC1B,aAAa,CAAC,CAACS,WAAW,CAAC,CAAC,CAACnB,KAAK,CAAC,GAAG,CAAC,GACjE,EAAE,EACP,CAACuB,MAAM,CAACW,IAAI,IAAIA,IAAI,CAAC9H,MAAM,GAAG,CAAC,CAAC;;MAEjC;MACA,MAAMmI,kBAAkB,GAAGF,UAAU,CAACpG,GAAG,CAACuG,SAAS,IAAI;QACrD,MAAMC,mBAAmB,GAAGD,SAAS,CAACrB,WAAW,CAAC,CAAC;QACnD,IAAIuB,KAAK,GAAG,CAAC;QACb,IAAIC,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;;QAE9B;QACA,IAAIH,mBAAmB,CAAClH,QAAQ,CAAC6G,QAAQ,CAAC9D,IAAI,CAAC6C,WAAW,CAAC,CAAC,CAAC,EAAE;UAC7DuB,KAAK,IAAI,EAAE;QACb;;QAEA;QACAJ,WAAW,CAACjH,OAAO,CAACwH,IAAI,IAAI;UAC1B,IAAIJ,mBAAmB,CAAClH,QAAQ,CAACsH,IAAI,CAAC,EAAE;YACtCH,KAAK,IAAI,CAAC;YACVC,cAAc,CAACG,GAAG,CAACD,IAAI,CAAC;;YAExB;YACAP,WAAW,CAACjH,OAAO,CAAC0H,SAAS,IAAI;cAC/B,IAAIF,IAAI,KAAKE,SAAS,EAAE;gBACtB,MAAMC,SAAS,GAAGP,mBAAmB,CAACQ,OAAO,CAACJ,IAAI,CAAC;gBACnD,MAAMK,UAAU,GAAGT,mBAAmB,CAACQ,OAAO,CAACF,SAAS,CAAC;gBACzD,IAAIG,UAAU,KAAK,CAAC,CAAC,IAAI7G,IAAI,CAAC8G,GAAG,CAACH,SAAS,GAAGE,UAAU,CAAC,GAAG,EAAE,EAAE;kBAC9DR,KAAK,IAAI,CAAC;gBACZ;cACF;YACF,CAAC,CAAC;UACJ;QACF,CAAC,CAAC;QAEF,OAAO;UACLpE,IAAI,EAAEkE,SAAS,CAACnC,IAAI,CAAC,CAAC;UACtBqC,KAAK;UACLC,cAAc,EAAE/H,KAAK,CAACC,IAAI,CAAC8H,cAAc;QAC3C,CAAC;MACH,CAAC,CAAC,CAACpB,MAAM,CAAC6B,CAAC,IAAIA,CAAC,CAACV,KAAK,GAAG,CAAC,EACvBW,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACb,KAAK,GAAGY,CAAC,CAACZ,KAAK,EAChCc,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;MAEhB,IAAIjB,kBAAkB,CAACnI,MAAM,GAAG,CAAC,EAAE;QACjC;QACA,IAAIuG,WAAW,GAAG,EAAE;QAEpB,IAAIyB,QAAQ,CAAC5G,IAAI,KAAK,YAAY,EAAE;UAClC,MAAMiI,MAAM,GAAGrB,QAAQ,CAAC1B,aAAa,KAAK,MAAM;UAChDC,WAAW,GAAG+C,4BAA4B,CACxCtB,QAAQ,CAAC9D,IAAI,EACbmF,MAAM,EACNlB,kBACF,CAAC;QACH,CAAC,MAAM;UACL5B,WAAW,GAAGgD,iCAAiC,CAC7CvB,QAAQ,EACRG,kBACF,CAAC;QACH;QAEAH,QAAQ,CAACzB,WAAW,GAAGA,WAAW;MACpC,CAAC,MAAM;QACL;QACA,IAAIyB,QAAQ,CAAC5G,IAAI,KAAK,YAAY,EAAE;UAClC,MAAMiI,MAAM,GAAGrB,QAAQ,CAAC1B,aAAa,KAAK,MAAM;UAChD0B,QAAQ,CAACzB,WAAW,GAAG,qBAAqB8C,MAAM,GAAG,MAAM,GAAG,OAAO,0FAA0F;QACjK,CAAC,MAAM;UACL,MAAMG,aAAa,GAAGxB,QAAQ,CAAC3B,OAAO,CAAC2B,QAAQ,CAAC1B,aAAa,CAAC;UAC9D0B,QAAQ,CAACzB,WAAW,GAAG,0BAA0BiD,aAAa,wFAAwF;QACxJ;MACF;IACF;IAEA,SAASC,eAAeA,CAACvF,IAAI,EAAEwF,YAAY,EAAE;MAC3C;MACA,IAAIC,OAAO,GAAGzF,IAAI,CAAC+B,IAAI,CAAC,EACrBG,OAAO,CAAC,yEAAyE,EAAE,EAAE,EACrFA,OAAO,CAAC,QAAQ,EAAE,GAAG,EACrBH,IAAI,CAAC,CAAC;;MAET;MACA0D,OAAO,GAAGA,OAAO,CAACC,MAAM,CAAC,CAAC,CAAC,CAAChD,WAAW,CAAC,CAAC,GAAG+C,OAAO,CAACP,KAAK,CAAC,CAAC,CAAC;;MAE5D;MACA,MAAMS,cAAc,GAAGH,YAAY,GAAG,CACpC,6BAA6B,EAC7B,6BAA6B,EAC7B,uCAAuC,EACvC,wCAAwC,EACxC,sCAAsC,EACtC,4CAA4C,EAC5C,2CAA2C,EAC3C,mDAAkD,CACnD,GAAG,CACF,mCAAmC,EACnC,mCAAmC,EACnC,0DAA0D,EAC1D,sDAAsD,EACtD,mCAAmC,EACnC,8DAA8D,EAC9D,oCAAoC,EACpC,wDAAuD,CACxD;;MAED;MACA,IAAII,cAAc;MAClB,IAAIH,OAAO,CAAC3J,MAAM,GAAG,GAAG,EAAE;QACxB;QACA8J,cAAc,GAAGD,cAAc,CAACE,IAAI,CAACC,MAAM,IACzCA,MAAM,CAAC7I,QAAQ,CAAC,YAAY,CAAC,IAAI6I,MAAM,CAAC7I,QAAQ,CAAC,SAAS,CAAC,IAAI6I,MAAM,CAAC7I,QAAQ,CAAC,WAAW,CAC5F,CAAC,IAAI0I,cAAc,CAAC,CAAC,CAAC;MACxB,CAAC,MAAM;QACL;QACAC,cAAc,GAAGD,cAAc,CAACE,IAAI,CAACC,MAAM,IACzC,CAACA,MAAM,CAAC7I,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC6I,MAAM,CAAC7I,QAAQ,CAAC,SAAS,CAC9D,CAAC,IAAI0I,cAAc,CAAC,CAAC,CAAC;MACxB;;MAEA;MACA,MAAMI,UAAU,GAAG,CACjB,kCAAkC,EAClC,2BAA2B,EAC3B,wBAAwB,EACxB,uBAAuB,EACvB,oBAAmB,CACpB;;MAED;MACA,MAAMC,SAAS,GAAGP,OAAO,CAAC/D,KAAK,CAAC,eAAe,CAAC;MAEhD,IAAIsE,SAAS,CAAClK,MAAM,GAAG,CAAC,EAAE;QACxB;QACA,MAAMmK,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC;QAC9B,MAAME,eAAe,GAAGF,SAAS,CAAC,CAAC,CAAC;QACpC,MAAMG,SAAS,GAAGJ,UAAU,CAAChI,IAAI,CAACqI,KAAK,CAACrI,IAAI,CAACsI,MAAM,CAAC,CAAC,GAAGN,UAAU,CAACjK,MAAM,CAAC,CAAC;QAE3E,OAAO,GAAG8J,cAAc,GAAGK,SAAS,GAAGE,SAAS,GAAGD,eAAe,CAACrD,WAAW,CAAC,CAAC,EAAE;MACpF;MAEA,OAAO,GAAG+C,cAAc,GAAGH,OAAO,EAAE;IACtC;IAEA,SAASJ,iCAAiCA,CAACvB,QAAQ,EAAEG,kBAAkB,EAAE;MACvE,MAAMqB,aAAa,GAAGxB,QAAQ,CAAC3B,OAAO,CAAC2B,QAAQ,CAAC1B,aAAa,CAAC;MAE9D,IAAIC,WAAW,GAAG,yBAAyBiD,aAAa,8BAA8B;;MAEtF;MACArB,kBAAkB,CAAClH,OAAO,CAAC,CAACuJ,IAAI,EAAEjJ,KAAK,KAAK;QAC1C,MAAMkJ,UAAU,GAAGlJ,KAAK,KAAK,CAAC,GAC1B,EAAE,GACF,iBAAiB;;QAErB;QACA,MAAM2I,SAAS,GAAGM,IAAI,CAACtG,IAAI,CAAC0B,KAAK,CAAC,QAAQ,CAAC,CAACuB,MAAM,CAACuD,CAAC,IAAIA,CAAC,CAACzE,IAAI,CAAC,CAAC,CAACjG,MAAM,GAAG,CAAC,CAAC;QAC5E,MAAM2K,iBAAiB,GAAGT,SAAS,CAAC/C,MAAM,CAACuD,CAAC,IAC1CF,IAAI,CAACjC,cAAc,CAACV,IAAI,CAAC+C,OAAO,IAC9BF,CAAC,CAAC3D,WAAW,CAAC,CAAC,CAAC5F,QAAQ,CAACyJ,OAAO,CAClC,CACF,CAAC;;QAED;QACA,MAAMC,YAAY,GAAGF,iBAAiB,CAAC,CAAC,CAAC,IAAIT,SAAS,CAAC,CAAC,CAAC;QACzD3D,WAAW,IAAIkE,UAAU,GAAGhB,eAAe,CAACoB,YAAY,EAAE,IAAI,CAAC;MACjE,CAAC,CAAC;;MAEF;MACA,MAAMC,gBAAgB,GAAGxD,MAAM,CAACyD,OAAO,CAAC/C,QAAQ,CAAC3B,OAAO,EACrDc,MAAM,CAAC,CAAC,CAAC6D,GAAG,CAAC,KAAKA,GAAG,KAAKhD,QAAQ,CAAC1B,aAAa,EAChDzE,GAAG,CAAC,CAAC,GAAGqC,IAAI,CAAC,KAAKA,IAAI,CAAC;MAE1B,IAAI4G,gBAAgB,CAAC9K,MAAM,GAAG,CAAC,EAAE;QAC/BuG,WAAW,IAAI,wDAAwD;QACvEuE,gBAAgB,CAAC7J,OAAO,CAAC4F,MAAM,IAAI;UACjCN,WAAW,IAAI,mBAAmBM,MAAM,yFAAyF4C,eAAe,CAACtB,kBAAkB,CAAC,CAAC,CAAC,CAACjE,IAAI,EAAE,KAAK,CAAC,EAAE;QACvL,CAAC,CAAC;MACJ;;MAEA;MACA,MAAM+G,aAAa,GAAGjD,QAAQ,CAAC9D,IAAI,CAAC6C,WAAW,CAAC,CAAC,CAACnB,KAAK,CAAC,GAAG,CAAC,CAACuB,MAAM,CAACW,IAAI,IAAIA,IAAI,CAAC9H,MAAM,GAAG,CAAC,CAAC;MAC5FuG,WAAW,IAAI,yCAAyC0E,aAAa,CAAC,CAAC,CAAC,IAAI,YAAY,+CAA+CA,aAAa,CAAC,CAAC,CAAC,IAAI,kBAAkB,mBAAmB;MAEhM,OAAO1E,WAAW;IACpB;IAEA,SAAS+C,4BAA4BA,CAAC4B,SAAS,EAAE7B,MAAM,EAAElB,kBAAkB,EAAE;MAC3E,MAAMgD,WAAW,GAAG9B,MAAM,GACtB,4CAA4C,GAC5C,2DAA2D;MAE/D,IAAI9C,WAAW,GAAG,GAAG4E,WAAW,MAAM;MAEtChD,kBAAkB,CAAClH,OAAO,CAAC,CAACuJ,IAAI,EAAEjJ,KAAK,KAAK;QAC1C;QACA,MAAM2I,SAAS,GAAGM,IAAI,CAACtG,IAAI,CAAC0B,KAAK,CAAC,QAAQ,CAAC,CAACuB,MAAM,CAACuD,CAAC,IAAIA,CAAC,CAACzE,IAAI,CAAC,CAAC,CAACjG,MAAM,GAAG,CAAC,CAAC;QAC5E,MAAM2K,iBAAiB,GAAGT,SAAS,CAAC/C,MAAM,CAACuD,CAAC,IAC1CF,IAAI,CAACjC,cAAc,CAACV,IAAI,CAAC+C,OAAO,IAC9BF,CAAC,CAAC3D,WAAW,CAAC,CAAC,CAAC5F,QAAQ,CAACyJ,OAAO,CAClC,CACF,CAAC;;QAED;QACA,MAAMC,YAAY,GAAGF,iBAAiB,CAAC,CAAC,CAAC,IAAIT,SAAS,CAAC,CAAC,CAAC;QAEzD,MAAMO,UAAU,GAAGlJ,KAAK,KAAK,CAAC,GAC1B,EAAE,GACF,kBAAkB;QAEtBgF,WAAW,IAAIkE,UAAU,GAAGhB,eAAe,CAACoB,YAAY,EAAExB,MAAM,CAAC;MACnE,CAAC,CAAC;;MAEF;MACA,MAAM+B,UAAU,GAAGF,SAAS,CAACnE,WAAW,CAAC,CAAC,CAACnB,KAAK,CAAC,GAAG,CAAC,CAACuB,MAAM,CAACW,IAAI,IAAIA,IAAI,CAAC9H,MAAM,GAAG,CAAC,CAAC;MACrF,MAAMqL,KAAK,GAAGD,UAAU,CAAC,CAAC,CAAC,IAAI,cAAc;MAE7C7E,WAAW,IAAI,kDAAkD8E,KAAK,uFAAuF;MAE7J,OAAO9E,WAAW;IACpB;IAEA,SAAS/D,eAAeA,CAACC,SAAS,EAAE;MAClC,MAAM6I,iBAAiB,GAAG,CAAC,GAAG7I,SAAS,EACpCwG,IAAI,CAAC,MAAMhH,IAAI,CAACsI,MAAM,CAAC,CAAC,GAAG,GAAG,EAC9BpD,MAAM,CAAC,CAACa,QAAQ,EAAEzG,KAAK,EAAEgK,IAAI,KAC5BhK,KAAK,KAAKgK,IAAI,CAACC,SAAS,CAAEpE,CAAC,IACzBA,CAAC,CAAClD,IAAI,CAAC6C,WAAW,CAAC,CAAC,CAACX,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,KAC5C4B,QAAQ,CAAC9D,IAAI,CAAC6C,WAAW,CAAC,CAAC,CAACX,OAAO,CAAC,UAAU,EAAE,EAAE,CACpD,CACF,CAAC;MAEH,MAAMqF,iBAAiB,GAAG,EAAE;MAC5B,MAAMC,mBAAmB,GAAGzJ,IAAI,CAAC0J,IAAI,CAACxJ,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,GAAG,CAAC,CAAC;MACtE,MAAM6L,eAAe,GAAG;QAAEC,IAAI,EAAE,CAAC;QAAEC,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAE,CAAC;MAEvD,KAAK,MAAMvF,UAAU,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,CAAC,EAAE;QACnD,MAAMwF,qBAAqB,GAAGV,iBAAiB,CAACnE,MAAM,CAACC,CAAC,IACtDA,CAAC,CAACZ,UAAU,KAAKA,UAAU,IAAI,CAACiF,iBAAiB,CAACtK,QAAQ,CAACiG,CAAC,CAC9D,CAAC;QAED,KAAK,MAAMY,QAAQ,IAAIgE,qBAAqB,EAAE;UAC5C,IAAIJ,eAAe,CAACpF,UAAU,CAAC,GAAGkF,mBAAmB,IACjDD,iBAAiB,CAACzL,MAAM,GAAGmC,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,EAAE;YAC1D0L,iBAAiB,CAACpK,IAAI,CAAC2G,QAAQ,CAAC;YAChC4D,eAAe,CAACpF,UAAU,CAAC,EAAE;UAC/B;QACF;MACF;MAEA,OAAOiF,iBAAiB,CAACzL,MAAM,GAAGmC,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC,EAAE;QAC7D,MAAMkM,iBAAiB,GAAGX,iBAAiB,CAACvB,IAAI,CAAC3C,CAAC,IAAI,CAACqE,iBAAiB,CAACtK,QAAQ,CAACiG,CAAC,CAAC,CAAC;QACrF,IAAI6E,iBAAiB,EAAE;UACrBR,iBAAiB,CAACpK,IAAI,CAAC4K,iBAAiB,CAAC;QAC3C,CAAC,MAAM;UACL;QACF;MACF;MAEA,OAAOR,iBAAiB;IAC1B;IAEA,SAAS/I,uBAAuBA,CAAA,EAAG;MACjC,MAAMwJ,eAAe,GAAGC,yBAAyB,CAAC,CAAC;MACnD,MAAMC,iBAAiB,GAAGC,wBAAwB,CAAC,CAAC;MACpD,MAAMC,iBAAiB,GAAGC,wBAAwB,CAAC,CAAC;;MAEpD;MACA,MAAMC,cAAc,GAAG,GAAG;MAC1B,MAAMC,gBAAgB,GAAG,GAAG;MAC5B,MAAMC,eAAe,GAAG,GAAG;;MAE3B;MACA,MAAMlN,cAAc,GAClB0M,eAAe,GAAGM,cAAc,GAChCJ,iBAAiB,GAAGK,gBAAgB,GACpCH,iBAAiB,GAAGI,eACrB;MAED,OAAOzK,IAAI,CAAC0K,GAAG,CAAC,CAAC,EAAE1K,IAAI,CAACC,GAAG,CAAC,GAAG,EAAED,IAAI,CAAC2K,KAAK,CAACpN,cAAc,CAAC,CAAC,CAAC;IAC/D;IAEA,SAAS2M,yBAAyBA,CAAA,EAAG;MACnC;MACA,MAAMU,YAAY,GAAGhN,gBAAgB,CAACE,KAAK,CAACC,MAAM;MAClD,IAAI6M,YAAY,KAAK,CAAC,EAAE,OAAO,CAAC;;MAEhC;MACA,MAAMC,yBAAyB,GAAG,GAAG,CAAC,CAAC;MACvC,MAAMC,iBAAiB,GAAG9K,IAAI,CAAC0J,IAAI,CAACkB,YAAY,GAAGC,yBAAyB,CAAC;MAC7E,MAAME,eAAe,GAAG7K,MAAM,CAAC9C,aAAa,CAACU,KAAK,CAAC;MAEnD,MAAMkN,QAAQ,GAAGhL,IAAI,CAACC,GAAG,CAAC8K,eAAe,GAAGD,iBAAiB,EAAE,CAAC,CAAC,GAAG,GAAG;MACvE,OAAOE,QAAQ;IACjB;IAEA,SAASZ,wBAAwBA,CAAA,EAAG;MAClC,MAAMxH,OAAO,GAAGhF,gBAAgB,CAACE,KAAK,CAACgH,WAAW,CAAC,CAAC;;MAEpD;MACA,MAAMmG,oBAAoB,GAAG,CAC3B,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,EAAE,SAAS,EACvD,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,SAAS,EACxD,WAAW,EAAE,SAAS,EAAE,UAAU,EAAE,aAAa,EAAE,cAAa,CACjE;;MAED;MACA,IAAIC,eAAe,GAAG,CAAC;MACvBD,oBAAoB,CAACjM,OAAO,CAACmM,SAAS,IAAI;QACxC,MAAMC,KAAK,GAAG,IAAIC,MAAM,CAACF,SAAS,EAAE,GAAG,CAAC;QACxC,MAAMG,OAAO,GAAG1I,OAAO,CAAC6B,KAAK,CAAC2G,KAAK,CAAC;QACpC,IAAIE,OAAO,EAAE;UACXJ,eAAe,IAAII,OAAO,CAACvN,MAAM;QACnC;MACF,CAAC,CAAC;;MAEF;MACA,MAAMwN,eAAe,GAAGvL,IAAI,CAACC,GAAG,CAACiL,eAAe,GAAG,CAAC,EAAE,GAAG,CAAC;MAC1D,OAAOK,eAAe;IACxB;IAEA,SAASjB,wBAAwBA,CAAA,EAAG;MAClC,IAAI,CAAC5M,iBAAiB,CAACI,KAAK,CAACC,MAAM,EAAE,OAAO,CAAC;;MAE7C;MACA,MAAMyN,KAAK,GAAG,IAAIjF,GAAG,CAAC7I,iBAAiB,CAACI,KAAK,CAAC8B,GAAG,CAACuF,CAAC,IAAIA,CAAC,CAAChG,IAAI,CAAC,CAAC;MAC/D,MAAMsM,cAAc,GAAID,KAAK,CAACE,IAAI,GAAG,CAAC,GAAI,EAAE,CAAC,CAAC;;MAE9C;MACA,MAAMC,aAAa,GAAGjO,iBAAiB,CAACI,KAAK,CAAC8B,GAAG,CAACuF,CAAC,IAAIA,CAAC,CAAClD,IAAI,CAAC6C,WAAW,CAAC,CAAC,CAAC;MAC5E,IAAI8G,YAAY,GAAG,CAAC;MACpB,MAAMC,iBAAiB,GAAG,IAAItF,GAAG,CAAC,CAAC;MAEnCoF,aAAa,CAAC3M,OAAO,CAACiD,IAAI,IAAI;QAC5B,MAAM6J,QAAQ,GAAG7J,IAAI,CAAC0B,KAAK,CAAC,GAAG,EAC5BuB,MAAM,CAACW,IAAI,IAAIA,IAAI,CAAC9H,MAAM,GAAG,CAAC,CAAC,CAAC;QAAA,CAChC6B,GAAG,CAACiG,IAAI,IAAIA,IAAI,CAAC1B,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;;QAE7C2H,QAAQ,CAAC9M,OAAO,CAAC2J,OAAO,IAAI;UAC1B,IAAI,CAACkD,iBAAiB,CAACE,GAAG,CAACpD,OAAO,CAAC,EAAE;YACnCiD,YAAY,EAAE;YACdC,iBAAiB,CAACpF,GAAG,CAACkC,OAAO,CAAC;UAChC;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,MAAMqD,eAAe,GAAGhM,IAAI,CAACC,GAAG,CAAC2L,YAAY,GAAGD,aAAa,CAAC5N,MAAM,GAAG,EAAE,EAAE,EAAE,CAAC;MAE9E,OAAO0N,cAAc,GAAGO,eAAe;IACzC;;IAEA;IACA,MAAMC,yBAAyB,GAAGtP,QAAQ,CAAC,MAAM;MAC/C,OAAOe,iBAAiB,CAACI,KAAK,CAAC8B,GAAG,CAAC,CAACuF,CAAC,EAAE7F,KAAK,MAAM;QAChD2C,IAAI,EAAEkD,CAAC,CAAClD,IAAI;QACZ9C,IAAI,EAAEgG,CAAC,CAAChG,IAAI;QACZiF,OAAO,EAAEe,CAAC,CAACf,OAAO;QAClB8H,UAAU,EAAEvO,aAAa,CAACG,KAAK,CAACwB,KAAK,CAAC,EAAE4M,UAAU;QAClD7H,aAAa,EAAEc,CAAC,CAACd,aAAa;QAC9BC,WAAW,EAAEa,CAAC,CAACb,WAAW;QAC1B6H,SAAS,EAAExO,aAAa,CAACG,KAAK,CAACwB,KAAK,CAAC,EAAE8M;MACzC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,MAAMC,2BAA2B,GAAG1P,QAAQ,CAAC,MAAM;MACjD,OAAOgB,aAAa,CAACG,KAAK,CAAC8B,GAAG,CAAC0M,CAAC,IAAIA,CAAC,CAACJ,UAAU,CAAC;IACnD,CAAC,CAAC;IAEF,MAAMK,mBAAmB,GAAG5P,QAAQ,CAAC,MAAM;MACzC,OAAOgB,aAAa,CAACG,KAAK,CAACoH,MAAM,CAACoH,CAAC,IAAIA,CAAC,CAACF,OAAO,CAAC,CAACrO,MAAM;IAC1D,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
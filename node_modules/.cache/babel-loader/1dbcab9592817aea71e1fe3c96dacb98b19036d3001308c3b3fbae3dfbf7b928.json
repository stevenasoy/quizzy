{"ast":null,"code":"import \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\r\n * Scoring Algorithms Module with Machine Learning\r\n */\n\n/**\r\n * Calculates weighted average score with adaptive weights\r\n * @param {Object} scores - Object containing different scores\r\n * @param {Object} weights - Weight for each score type\r\n * @returns {number} Final weighted score\r\n */\nexport function calculateWeightedScore(scores, weights) {\n  // Get adaptive weights if available\n  var adaptiveWeights = getAdaptiveWeights() || weights;\n  var totalScore = 0;\n  var totalWeight = 0;\n\n  // Ensure we have valid scores and weights\n  Object.keys(adaptiveWeights).forEach(function (key) {\n    var score = scores[key] || 0;\n    var weight = adaptiveWeights[key] || 0;\n    totalScore += score * weight;\n    totalWeight += weight;\n  });\n\n  // Prevent division by zero\n  if (totalWeight === 0) {\n    return 0;\n  }\n\n  // Return normalized score\n  return normalizeScore(totalScore / totalWeight);\n}\n\n/**\r\n * Performs multi-factor analysis for prediction\r\n * @param {Object} factors - Different factors to analyze\r\n * @returns {Object} Analysis results\r\n */\nexport function analyzeMultipleFactors(factors) {\n  var analysis = {\n    contentCoverage: factors.contentCoverage || 0,\n    complexity: factors.complexity || 0,\n    diversity: factors.diversity || 0,\n    overallScore: 0,\n    confidence: 0\n  };\n\n  // Calculate overall score\n  analysis.overallScore = calculateWeightedScore(factors, {\n    contentCoverage: 0.4,\n    complexity: 0.3,\n    diversity: 0.3\n  });\n\n  // Calculate confidence based on data completeness\n  var availableFactors = Object.keys(factors).filter(function (key) {\n    return factors[key] !== undefined;\n  }).length;\n  analysis.confidence = availableFactors / Object.keys(factors).length * 100;\n  return analysis;\n}\n\n/**\r\n * Normalizes scores to a specific range\r\n * @param {number} score - Raw score\r\n * @param {number} min - Minimum value\r\n * @param {number} max - Maximum value\r\n * @returns {number} Normalized score\r\n */\nexport function normalizeScore(score) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  return Math.max(min, Math.min(max, score));\n}\n\n/**\r\n * Predicts performance using machine learning model\r\n * @param {Object} metrics - Performance metrics\r\n * @returns {Object} Performance prediction\r\n */\nexport function predictPerformance(metrics) {\n  // Get historical data for model training\n  var historicalData = getHistoricalData();\n\n  // Train model if enough data is available\n  if (historicalData.length >= 10) {\n    trainModel(historicalData);\n  }\n\n  // Get prediction from trained model or use heuristic approach\n  var prediction = historicalData.length >= 10 ? getPredictionFromModel(metrics) : getPredictionFromHeuristics(metrics);\n\n  // Update weights based on prediction accuracy\n  updateWeights(prediction);\n  return {\n    predictedScore: normalizeScore(prediction.score),\n    confidence: prediction.confidence,\n    factors: {\n      contentComplexity: metrics.contentComplexity || 0,\n      questionDifficulty: metrics.questionDifficulty || 0,\n      contentCoverage: metrics.contentCoverage || 0,\n      topicDiversity: metrics.topicDiversity || 0\n    },\n    model: {\n      type: historicalData.length >= 10 ? 'machine-learning' : 'heuristic',\n      accuracy: prediction.accuracy,\n      dataPoints: historicalData.length\n    }\n  };\n}\n\n/**\r\n * Gets historical performance data from storage\r\n * @returns {Array} Historical data\r\n */\nfunction getHistoricalData() {\n  try {\n    var data = localStorage.getItem('performanceHistory');\n    return data ? JSON.parse(data) : [];\n  } catch (error) {\n    console.error('Error loading historical data:', error);\n    return [];\n  }\n}\n\n/**\r\n * Gets adaptive weights from storage\r\n * @returns {Object|null} Adaptive weights\r\n */\nfunction getAdaptiveWeights() {\n  try {\n    var weights = localStorage.getItem('adaptiveWeights');\n    return weights ? JSON.parse(weights) : null;\n  } catch (error) {\n    console.error('Error loading adaptive weights:', error);\n    return null;\n  }\n}\n\n/**\r\n * Trains machine learning model on historical data\r\n * @param {Array} data - Training data\r\n */\nfunction trainModel(data) {\n  // Prepare training data\n  var features = data.map(function (entry) {\n    return [entry.metrics.contentComplexity, entry.metrics.questionDifficulty, entry.metrics.contentCoverage, entry.metrics.topicDiversity];\n  });\n  var labels = data.map(function (entry) {\n    return entry.actualScore;\n  });\n\n  // Train model using simple linear regression\n  var model = trainLinearRegression(features, labels);\n\n  // Save model parameters\n  localStorage.setItem('modelParameters', JSON.stringify(model));\n}\n\n/**\r\n * Gets prediction from trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\nfunction getPredictionFromModel(metrics) {\n  try {\n    var model = JSON.parse(localStorage.getItem('modelParameters'));\n    if (!model) return getPredictionFromHeuristics(metrics);\n\n    // Prepare feature vector\n    var features = [metrics.contentComplexity, metrics.questionDifficulty, metrics.contentCoverage, metrics.topicDiversity];\n\n    // Make prediction\n    var predictedScore = predictLinearRegression(features, model);\n    var confidence = calculateModelConfidence(model, metrics);\n    return {\n      score: predictedScore,\n      confidence: confidence,\n      accuracy: model.accuracy,\n      method: 'machine-learning'\n    };\n  } catch (error) {\n    console.error('Error using ML model:', error);\n    return getPredictionFromHeuristics(metrics);\n  }\n}\n\n/**\r\n * Gets prediction using heuristic approach\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\nfunction getPredictionFromHeuristics(metrics) {\n  // Ensure metrics has valid values\n  var validMetrics = {\n    contentComplexity: metrics.contentComplexity || 0,\n    questionDifficulty: metrics.questionDifficulty || 0,\n    contentCoverage: metrics.contentCoverage || 0,\n    topicDiversity: metrics.topicDiversity || 0\n  };\n  var weights = {\n    contentComplexity: 0.3,\n    questionDifficulty: 0.3,\n    contentCoverage: 0.2,\n    topicDiversity: 0.2\n  };\n\n  // Calculate base score with validated metrics\n  var baseScore = calculateWeightedScore(validMetrics, weights);\n  var confidence = calculateConfidence(validMetrics);\n\n  // Ensure we return a valid score between 0 and 100\n  return {\n    score: normalizeScore(baseScore * (confidence / 100)),\n    confidence: confidence,\n    accuracy: 0.7,\n    // Default accuracy for heuristic approach\n    method: 'heuristic'\n  };\n}\n\n/**\r\n * Updates weights based on prediction accuracy\r\n * @param {Object} prediction - Prediction results\r\n */\nfunction updateWeights(prediction) {\n  var currentWeights = getAdaptiveWeights() || {\n    contentComplexity: 0.3,\n    questionDifficulty: 0.3,\n    contentCoverage: 0.2,\n    topicDiversity: 0.2\n  };\n\n  // Adjust weights based on prediction accuracy\n  if (prediction.accuracy < 0.8) {\n    var adjustedWeights = {};\n    Object.keys(currentWeights).forEach(function (key) {\n      var correlation = calculateCorrelation(getHistoricalData(), key, 'actualScore');\n      adjustedWeights[key] = normalizeWeight(currentWeights[key] * (1 + correlation));\n    });\n\n    // Normalize weights to sum to 1\n    var totalWeight = Object.values(adjustedWeights).reduce(function (a, b) {\n      return a + b;\n    }, 0);\n    Object.keys(adjustedWeights).forEach(function (key) {\n      adjustedWeights[key] /= totalWeight;\n    });\n\n    // Save adjusted weights\n    localStorage.setItem('adaptiveWeights', JSON.stringify(adjustedWeights));\n  }\n}\n\n/**\r\n * Trains simple linear regression model\r\n * @param {Array} features - Training features\r\n * @param {Array} labels - Training labels\r\n * @returns {Object} Trained model parameters\r\n */\nfunction trainLinearRegression(features, labels) {\n  var n = features.length;\n  var numFeatures = features[0].length;\n\n  // Initialize parameters\n  var weights = new Array(numFeatures).fill(0);\n  var learningRate = 0.01;\n  var iterations = 100;\n\n  // Gradient descent\n  for (var iter = 0; iter < iterations; iter++) {\n    var _predictions = features.map(function (feature) {\n      return feature.reduce(function (sum, value, i) {\n        return sum + value * weights[i];\n      }, 0);\n    });\n\n    // Update weights\n    var _loop = function _loop(j) {\n      var gradient = _predictions.reduce(function (sum, pred, i) {\n        return sum + (pred - labels[i]) * features[i][j];\n      }, 0) / n;\n      weights[j] -= learningRate * gradient;\n    };\n    for (var j = 0; j < numFeatures; j++) {\n      _loop(j);\n    }\n  }\n\n  // Calculate model accuracy\n  var predictions = features.map(function (feature) {\n    return feature.reduce(function (sum, value, i) {\n      return sum + value * weights[i];\n    }, 0);\n  });\n  var accuracy = 1 - calculateRMSE(predictions, labels) / 100;\n  return {\n    weights: weights,\n    accuracy: accuracy\n  };\n}\n\n/**\r\n * Predicts using linear regression model\r\n * @param {Array} features - Input features\r\n * @param {Object} model - Trained model\r\n * @returns {number} Predicted score\r\n */\nfunction predictLinearRegression(features, model) {\n  return features.reduce(function (sum, value, i) {\n    return sum + value * model.weights[i];\n  }, 0);\n}\n\n/**\r\n * Calculates root mean square error\r\n * @param {Array} predictions - Predicted values\r\n * @param {Array} actuals - Actual values\r\n * @returns {number} RMSE value\r\n */\nfunction calculateRMSE(predictions, actuals) {\n  var squaredErrors = predictions.map(function (pred, i) {\n    return Math.pow(pred - actuals[i], 2);\n  });\n  return Math.sqrt(squaredErrors.reduce(function (a, b) {\n    return a + b;\n  }, 0) / predictions.length);\n}\n\n/**\r\n * Calculates correlation between two variables\r\n * @param {Array} data - Historical data\r\n * @param {string} variable1 - First variable name\r\n * @param {string} variable2 - Second variable name\r\n * @returns {number} Correlation coefficient\r\n */\nfunction calculateCorrelation(data, variable1, variable2) {\n  var values1 = data.map(function (entry) {\n    return variable1.includes('.') ? entry.metrics[variable1.split('.')[1]] : entry[variable1];\n  });\n  var values2 = data.map(function (entry) {\n    return entry[variable2];\n  });\n  var mean1 = values1.reduce(function (a, b) {\n    return a + b;\n  }, 0) / values1.length;\n  var mean2 = values2.reduce(function (a, b) {\n    return a + b;\n  }, 0) / values2.length;\n  var variance1 = values1.reduce(function (sum, val) {\n    return sum + Math.pow(val - mean1, 2);\n  }, 0);\n  var variance2 = values2.reduce(function (sum, val) {\n    return sum + Math.pow(val - mean2, 2);\n  }, 0);\n  var covariance = values1.reduce(function (sum, val, i) {\n    return sum + (val - mean1) * (values2[i] - mean2);\n  }, 0);\n  return covariance / Math.sqrt(variance1 * variance2);\n}\n\n/**\r\n * Normalizes a weight value\r\n * @param {number} weight - Weight to normalize\r\n * @returns {number} Normalized weight\r\n */\nfunction normalizeWeight(weight) {\n  return Math.max(0.1, Math.min(0.5, weight));\n}\n\n/**\r\n * Calculates model confidence\r\n * @param {Object} model - Trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {number} Confidence score\r\n */\nfunction calculateModelConfidence(model, metrics) {\n  // Base confidence on model accuracy\n  var confidence = model.accuracy * 100;\n\n  // Adjust based on data completeness\n  var completeness = Object.values(metrics).filter(function (v) {\n    return v !== undefined;\n  }).length / 4;\n  confidence *= completeness;\n\n  // Adjust based on metric values being within expected ranges\n  var inRange = Object.values(metrics).every(function (v) {\n    return v >= 0 && v <= 100;\n  });\n  if (!inRange) confidence *= 0.8;\n  return Math.min(100, confidence);\n}\n\n/**\r\n * Calculates confidence level for predictions\r\n * @param {Object} metrics - Metrics used for prediction\r\n * @returns {number} Confidence percentage\r\n */\nfunction calculateConfidence(metrics) {\n  var requiredMetrics = ['contentComplexity', 'questionDifficulty', 'contentCoverage', 'topicDiversity'];\n  var availableMetrics = requiredMetrics.filter(function (metric) {\n    return metrics[metric] !== undefined;\n  });\n  return availableMetrics.length / requiredMetrics.length * 100;\n}","map":{"version":3,"names":["calculateWeightedScore","scores","weights","adaptiveWeights","getAdaptiveWeights","totalScore","totalWeight","Object","keys","forEach","key","score","weight","normalizeScore","analyzeMultipleFactors","factors","analysis","contentCoverage","complexity","diversity","overallScore","confidence","availableFactors","filter","undefined","length","min","arguments","max","Math","predictPerformance","metrics","historicalData","getHistoricalData","trainModel","prediction","getPredictionFromModel","getPredictionFromHeuristics","updateWeights","predictedScore","contentComplexity","questionDifficulty","topicDiversity","model","type","accuracy","dataPoints","data","localStorage","getItem","JSON","parse","error","console","features","map","entry","labels","actualScore","trainLinearRegression","setItem","stringify","predictLinearRegression","calculateModelConfidence","method","validMetrics","baseScore","calculateConfidence","currentWeights","adjustedWeights","correlation","calculateCorrelation","normalizeWeight","values","reduce","a","b","n","numFeatures","Array","fill","learningRate","iterations","iter","predictions","feature","sum","value","i","_loop","j","gradient","pred","calculateRMSE","actuals","squaredErrors","pow","sqrt","variable1","variable2","values1","includes","split","values2","mean1","mean2","variance1","val","variance2","covariance","completeness","v","inRange","every","requiredMetrics","availableMetrics","metric"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/algorithms/scoring/index.js"],"sourcesContent":["/**\r\n * Scoring Algorithms Module with Machine Learning\r\n */\r\n\r\n/**\r\n * Calculates weighted average score with adaptive weights\r\n * @param {Object} scores - Object containing different scores\r\n * @param {Object} weights - Weight for each score type\r\n * @returns {number} Final weighted score\r\n */\r\nexport function calculateWeightedScore(scores, weights) {\r\n  // Get adaptive weights if available\r\n  const adaptiveWeights = getAdaptiveWeights() || weights;\r\n  \r\n  let totalScore = 0;\r\n  let totalWeight = 0;\r\n  \r\n  // Ensure we have valid scores and weights\r\n  Object.keys(adaptiveWeights).forEach(key => {\r\n    const score = scores[key] || 0;\r\n    const weight = adaptiveWeights[key] || 0;\r\n    \r\n    totalScore += score * weight;\r\n    totalWeight += weight;\r\n  });\r\n  \r\n  // Prevent division by zero\r\n  if (totalWeight === 0) {\r\n    return 0;\r\n  }\r\n  \r\n  // Return normalized score\r\n  return normalizeScore(totalScore / totalWeight);\r\n}\r\n\r\n/**\r\n * Performs multi-factor analysis for prediction\r\n * @param {Object} factors - Different factors to analyze\r\n * @returns {Object} Analysis results\r\n */\r\nexport function analyzeMultipleFactors(factors) {\r\n  const analysis = {\r\n    contentCoverage: factors.contentCoverage || 0,\r\n    complexity: factors.complexity || 0,\r\n    diversity: factors.diversity || 0,\r\n    overallScore: 0,\r\n    confidence: 0\r\n  };\r\n  \r\n  // Calculate overall score\r\n  analysis.overallScore = calculateWeightedScore(factors, {\r\n    contentCoverage: 0.4,\r\n    complexity: 0.3,\r\n    diversity: 0.3\r\n  });\r\n  \r\n  // Calculate confidence based on data completeness\r\n  const availableFactors = Object.keys(factors).filter(key => factors[key] !== undefined).length;\r\n  analysis.confidence = (availableFactors / Object.keys(factors).length) * 100;\r\n  \r\n  return analysis;\r\n}\r\n\r\n/**\r\n * Normalizes scores to a specific range\r\n * @param {number} score - Raw score\r\n * @param {number} min - Minimum value\r\n * @param {number} max - Maximum value\r\n * @returns {number} Normalized score\r\n */\r\nexport function normalizeScore(score, min = 0, max = 100) {\r\n  return Math.max(min, Math.min(max, score));\r\n}\r\n\r\n/**\r\n * Predicts performance using machine learning model\r\n * @param {Object} metrics - Performance metrics\r\n * @returns {Object} Performance prediction\r\n */\r\nexport function predictPerformance(metrics) {\r\n  // Get historical data for model training\r\n  const historicalData = getHistoricalData();\r\n  \r\n  // Train model if enough data is available\r\n  if (historicalData.length >= 10) {\r\n    trainModel(historicalData);\r\n  }\r\n  \r\n  // Get prediction from trained model or use heuristic approach\r\n  const prediction = historicalData.length >= 10 \r\n    ? getPredictionFromModel(metrics)\r\n    : getPredictionFromHeuristics(metrics);\r\n  \r\n  // Update weights based on prediction accuracy\r\n  updateWeights(prediction);\r\n  \r\n  return {\r\n    predictedScore: normalizeScore(prediction.score),\r\n    confidence: prediction.confidence,\r\n    factors: {\r\n      contentComplexity: metrics.contentComplexity || 0,\r\n      questionDifficulty: metrics.questionDifficulty || 0,\r\n      contentCoverage: metrics.contentCoverage || 0,\r\n      topicDiversity: metrics.topicDiversity || 0\r\n    },\r\n    model: {\r\n      type: historicalData.length >= 10 ? 'machine-learning' : 'heuristic',\r\n      accuracy: prediction.accuracy,\r\n      dataPoints: historicalData.length\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Gets historical performance data from storage\r\n * @returns {Array} Historical data\r\n */\r\nfunction getHistoricalData() {\r\n  try {\r\n    const data = localStorage.getItem('performanceHistory');\r\n    return data ? JSON.parse(data) : [];\r\n  } catch (error) {\r\n    console.error('Error loading historical data:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Gets adaptive weights from storage\r\n * @returns {Object|null} Adaptive weights\r\n */\r\nfunction getAdaptiveWeights() {\r\n  try {\r\n    const weights = localStorage.getItem('adaptiveWeights');\r\n    return weights ? JSON.parse(weights) : null;\r\n  } catch (error) {\r\n    console.error('Error loading adaptive weights:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Trains machine learning model on historical data\r\n * @param {Array} data - Training data\r\n */\r\nfunction trainModel(data) {\r\n  // Prepare training data\r\n  const features = data.map(entry => [\r\n    entry.metrics.contentComplexity,\r\n    entry.metrics.questionDifficulty,\r\n    entry.metrics.contentCoverage,\r\n    entry.metrics.topicDiversity\r\n  ]);\r\n  \r\n  const labels = data.map(entry => entry.actualScore);\r\n  \r\n  // Train model using simple linear regression\r\n  const model = trainLinearRegression(features, labels);\r\n  \r\n  // Save model parameters\r\n  localStorage.setItem('modelParameters', JSON.stringify(model));\r\n}\r\n\r\n/**\r\n * Gets prediction from trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\r\nfunction getPredictionFromModel(metrics) {\r\n  try {\r\n    const model = JSON.parse(localStorage.getItem('modelParameters'));\r\n    if (!model) return getPredictionFromHeuristics(metrics);\r\n    \r\n    // Prepare feature vector\r\n    const features = [\r\n      metrics.contentComplexity,\r\n      metrics.questionDifficulty,\r\n      metrics.contentCoverage,\r\n      metrics.topicDiversity\r\n    ];\r\n    \r\n    // Make prediction\r\n    const predictedScore = predictLinearRegression(features, model);\r\n    const confidence = calculateModelConfidence(model, metrics);\r\n    \r\n    return {\r\n      score: predictedScore,\r\n      confidence,\r\n      accuracy: model.accuracy,\r\n      method: 'machine-learning'\r\n    };\r\n  } catch (error) {\r\n    console.error('Error using ML model:', error);\r\n    return getPredictionFromHeuristics(metrics);\r\n  }\r\n}\r\n\r\n/**\r\n * Gets prediction using heuristic approach\r\n * @param {Object} metrics - Current metrics\r\n * @returns {Object} Prediction results\r\n */\r\nfunction getPredictionFromHeuristics(metrics) {\r\n  // Ensure metrics has valid values\r\n  const validMetrics = {\r\n    contentComplexity: metrics.contentComplexity || 0,\r\n    questionDifficulty: metrics.questionDifficulty || 0,\r\n    contentCoverage: metrics.contentCoverage || 0,\r\n    topicDiversity: metrics.topicDiversity || 0\r\n  };\r\n\r\n  const weights = {\r\n    contentComplexity: 0.3,\r\n    questionDifficulty: 0.3,\r\n    contentCoverage: 0.2,\r\n    topicDiversity: 0.2\r\n  };\r\n  \r\n  // Calculate base score with validated metrics\r\n  const baseScore = calculateWeightedScore(validMetrics, weights);\r\n  const confidence = calculateConfidence(validMetrics);\r\n  \r\n  // Ensure we return a valid score between 0 and 100\r\n  return {\r\n    score: normalizeScore(baseScore * (confidence / 100)),\r\n    confidence,\r\n    accuracy: 0.7, // Default accuracy for heuristic approach\r\n    method: 'heuristic'\r\n  };\r\n}\r\n\r\n/**\r\n * Updates weights based on prediction accuracy\r\n * @param {Object} prediction - Prediction results\r\n */\r\nfunction updateWeights(prediction) {\r\n  const currentWeights = getAdaptiveWeights() || {\r\n    contentComplexity: 0.3,\r\n    questionDifficulty: 0.3,\r\n    contentCoverage: 0.2,\r\n    topicDiversity: 0.2\r\n  };\r\n  \r\n  // Adjust weights based on prediction accuracy\r\n  if (prediction.accuracy < 0.8) {\r\n    const adjustedWeights = {};\r\n    Object.keys(currentWeights).forEach(key => {\r\n      const correlation = calculateCorrelation(\r\n        getHistoricalData(),\r\n        key,\r\n        'actualScore'\r\n      );\r\n      adjustedWeights[key] = normalizeWeight(currentWeights[key] * (1 + correlation));\r\n    });\r\n    \r\n    // Normalize weights to sum to 1\r\n    const totalWeight = Object.values(adjustedWeights).reduce((a, b) => a + b, 0);\r\n    Object.keys(adjustedWeights).forEach(key => {\r\n      adjustedWeights[key] /= totalWeight;\r\n    });\r\n    \r\n    // Save adjusted weights\r\n    localStorage.setItem('adaptiveWeights', JSON.stringify(adjustedWeights));\r\n  }\r\n}\r\n\r\n/**\r\n * Trains simple linear regression model\r\n * @param {Array} features - Training features\r\n * @param {Array} labels - Training labels\r\n * @returns {Object} Trained model parameters\r\n */\r\nfunction trainLinearRegression(features, labels) {\r\n  const n = features.length;\r\n  const numFeatures = features[0].length;\r\n  \r\n  // Initialize parameters\r\n  const weights = new Array(numFeatures).fill(0);\r\n  const learningRate = 0.01;\r\n  const iterations = 100;\r\n  \r\n  // Gradient descent\r\n  for (let iter = 0; iter < iterations; iter++) {\r\n    const predictions = features.map(feature => \r\n      feature.reduce((sum, value, i) => sum + value * weights[i], 0)\r\n    );\r\n    \r\n    // Update weights\r\n    for (let j = 0; j < numFeatures; j++) {\r\n      const gradient = predictions.reduce((sum, pred, i) => \r\n        sum + (pred - labels[i]) * features[i][j], 0\r\n      ) / n;\r\n      \r\n      weights[j] -= learningRate * gradient;\r\n    }\r\n  }\r\n  \r\n  // Calculate model accuracy\r\n  const predictions = features.map(feature => \r\n    feature.reduce((sum, value, i) => sum + value * weights[i], 0)\r\n  );\r\n  \r\n  const accuracy = 1 - calculateRMSE(predictions, labels) / 100;\r\n  \r\n  return { weights, accuracy };\r\n}\r\n\r\n/**\r\n * Predicts using linear regression model\r\n * @param {Array} features - Input features\r\n * @param {Object} model - Trained model\r\n * @returns {number} Predicted score\r\n */\r\nfunction predictLinearRegression(features, model) {\r\n  return features.reduce((sum, value, i) => sum + value * model.weights[i], 0);\r\n}\r\n\r\n/**\r\n * Calculates root mean square error\r\n * @param {Array} predictions - Predicted values\r\n * @param {Array} actuals - Actual values\r\n * @returns {number} RMSE value\r\n */\r\nfunction calculateRMSE(predictions, actuals) {\r\n  const squaredErrors = predictions.map((pred, i) => \r\n    Math.pow(pred - actuals[i], 2)\r\n  );\r\n  return Math.sqrt(squaredErrors.reduce((a, b) => a + b, 0) / predictions.length);\r\n}\r\n\r\n/**\r\n * Calculates correlation between two variables\r\n * @param {Array} data - Historical data\r\n * @param {string} variable1 - First variable name\r\n * @param {string} variable2 - Second variable name\r\n * @returns {number} Correlation coefficient\r\n */\r\nfunction calculateCorrelation(data, variable1, variable2) {\r\n  const values1 = data.map(entry => \r\n    variable1.includes('.') \r\n      ? entry.metrics[variable1.split('.')[1]]\r\n      : entry[variable1]\r\n  );\r\n  \r\n  const values2 = data.map(entry => entry[variable2]);\r\n  \r\n  const mean1 = values1.reduce((a, b) => a + b, 0) / values1.length;\r\n  const mean2 = values2.reduce((a, b) => a + b, 0) / values2.length;\r\n  \r\n  const variance1 = values1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0);\r\n  const variance2 = values2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0);\r\n  \r\n  const covariance = values1.reduce((sum, val, i) => \r\n    sum + (val - mean1) * (values2[i] - mean2), 0\r\n  );\r\n  \r\n  return covariance / Math.sqrt(variance1 * variance2);\r\n}\r\n\r\n/**\r\n * Normalizes a weight value\r\n * @param {number} weight - Weight to normalize\r\n * @returns {number} Normalized weight\r\n */\r\nfunction normalizeWeight(weight) {\r\n  return Math.max(0.1, Math.min(0.5, weight));\r\n}\r\n\r\n/**\r\n * Calculates model confidence\r\n * @param {Object} model - Trained model\r\n * @param {Object} metrics - Current metrics\r\n * @returns {number} Confidence score\r\n */\r\nfunction calculateModelConfidence(model, metrics) {\r\n  // Base confidence on model accuracy\r\n  let confidence = model.accuracy * 100;\r\n  \r\n  // Adjust based on data completeness\r\n  const completeness = Object.values(metrics).filter(v => v !== undefined).length / 4;\r\n  confidence *= completeness;\r\n  \r\n  // Adjust based on metric values being within expected ranges\r\n  const inRange = Object.values(metrics).every(v => v >= 0 && v <= 100);\r\n  if (!inRange) confidence *= 0.8;\r\n  \r\n  return Math.min(100, confidence);\r\n}\r\n\r\n/**\r\n * Calculates confidence level for predictions\r\n * @param {Object} metrics - Metrics used for prediction\r\n * @returns {number} Confidence percentage\r\n */\r\nfunction calculateConfidence(metrics) {\r\n  const requiredMetrics = ['contentComplexity', 'questionDifficulty', 'contentCoverage', 'topicDiversity'];\r\n  const availableMetrics = requiredMetrics.filter(metric => metrics[metric] !== undefined);\r\n  \r\n  return (availableMetrics.length / requiredMetrics.length) * 100;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { ref, computed, onMounted } from 'vue';\nimport axios from 'axios';\nimport FileErrorDisplay from './components/FileErrorDisplay.vue';\nimport QuizResults from './components/QuizResults.vue';\nimport FlashcardQuiz from './components/FlashcardQuiz.vue';\nimport Sidebar from './components/Sidebar.vue';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport { Document } from 'docx';\nimport { PptxParser } from 'pptx-parser';\n\n// Set up PDF.js worker\n\nexport default {\n  __name: 'App',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\n    // File handling state\n    const selectedFiles = ref([]);\n    const fileInput = ref(null);\n    const unsupportedFiles = ref([]);\n    const extractionErrors = ref([]);\n\n    // Quiz state\n    const questionCount = ref('');\n    const isLoading = ref(false);\n    const error = ref('');\n    const predictedScore = ref(null);\n    const quizStarted = ref(false);\n    const quizFinished = ref(false);\n    const adaptiveQuestions = ref([]);\n    const userResponses = ref([]);\n    const extractedContent = ref('');\n\n    // Add quiz history state\n    const quizHistory = ref([]);\n\n    // Add isRetaking flag to track retakes\n    const isRetaking = ref(false);\n    const retakeIndex = ref(-1);\n\n    // Load quiz history from localStorage on mount\n    onMounted(() => {\n      const savedHistory = localStorage.getItem('quizHistory');\n      if (savedHistory) {\n        quizHistory.value = JSON.parse(savedHistory);\n      }\n    });\n\n    // Computed properties\n    const isFormValid = computed(() => {\n      return selectedFiles.value.length > 0 && questionCount.value > 0;\n    });\n    const hasFileErrors = computed(() => {\n      return extractionErrors.value.length > 0 || unsupportedFiles.value.length > 0;\n    });\n    const getPredictedScoreClass = computed(() => {\n      if (predictedScore.value >= 80) return 'high';\n      if (predictedScore.value >= 60) return 'medium';\n      return 'low';\n    });\n\n    // File handling methods\n    const triggerFileInput = () => {\n      fileInput.value.click();\n    };\n    const handleFileSelect = event => {\n      const files = Array.from(event.target.files);\n      addFiles(files);\n    };\n    const handleDrop = event => {\n      const files = Array.from(event.dataTransfer.files);\n      addFiles(files);\n    };\n    const addFiles = files => {\n      const validTypes = ['application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'text/plain', 'application/pdf', 'image/png', 'image/jpeg', 'image/jpg', 'image/tiff', 'image/bmp'];\n      const validFiles = [];\n      const invalidFiles = [];\n      files.forEach(file => {\n        if (validTypes.includes(file.type)) {\n          validFiles.push(file);\n        } else {\n          invalidFiles.push(file);\n        }\n      });\n      selectedFiles.value = [...selectedFiles.value, ...validFiles];\n      unsupportedFiles.value = [...unsupportedFiles.value, ...invalidFiles];\n    };\n    const removeFile = index => {\n      selectedFiles.value.splice(index, 1);\n    };\n\n    // Quiz handling methods\n    const handleSubmit = async () => {\n      if (!isFormValid.value) return;\n      isLoading.value = true;\n      error.value = '';\n      adaptiveQuestions.value = [];\n      predictedScore.value = null;\n      quizStarted.value = false;\n      userResponses.value = [];\n      extractedContent.value = '';\n      extractionErrors.value = []; // Clear previous errors\n\n      try {\n        console.log('Processing files:', selectedFiles.value.map(f => ({\n          name: f.name,\n          type: f.type\n        })));\n        const fileContents = await Promise.all(selectedFiles.value.map(file => readFileContent(file)));\n\n        // Filter out empty content and join\n        const validContents = fileContents.filter(content => content && content.trim().length > 0);\n        console.log('Number of files with valid content:', validContents.length);\n        if (validContents.length === 0) {\n          throw new Error('No valid content could be extracted from the selected files. Please upload text (.txt) files with actual content.');\n        }\n        extractedContent.value = validContents.join('\\n\\n');\n        console.log('Total content length:', extractedContent.value.length);\n        if (extractedContent.value.trim().length < 50) {\n          throw new Error('The extracted content is too short to generate meaningful questions. Please provide more content (at least 50 characters).');\n        }\n        const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n        console.log('Requesting questions:', requestedQuestionCount);\n        const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n        if (!response) {\n          throw new Error('No response received from the question generation service.');\n        }\n        const processedQuiz = processQuizResponse(response, extractedContent.value);\n        if (!processedQuiz || !processedQuiz.questions || processedQuiz.questions.length === 0) {\n          throw new Error('No valid questions could be generated. Please check if the content is suitable for question generation.');\n        }\n        console.log('Generated questions:', processedQuiz.questions.length);\n        adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n        predictedScore.value = calculatePredictedScore();\n      } catch (err) {\n        console.error('Error in handleSubmit:', err);\n        error.value = err.message || 'An unexpected error occurred while generating questions.';\n      } finally {\n        isLoading.value = false;\n      }\n    };\n    const startQuiz = () => {\n      quizStarted.value = true;\n      quizFinished.value = false;\n    };\n    const handleQuizComplete = responses => {\n      userResponses.value = responses;\n      // Update the adaptiveQuestions with user answers\n      adaptiveQuestions.value = adaptiveQuestions.value.map((question, index) => ({\n        ...question,\n        userAnswer: responses[index]?.userAnswer,\n        isCorrect: responses[index]?.correct\n      }));\n      quizFinished.value = true;\n      saveQuizResults();\n    };\n    const restartQuiz = () => {\n      quizStarted.value = true;\n      quizFinished.value = false;\n      userResponses.value = [];\n    };\n    const resetToMainScreen = () => {\n      selectedFiles.value = [];\n      unsupportedFiles.value = [];\n      extractionErrors.value = [];\n      questionCount.value = '';\n      error.value = '';\n      isLoading.value = false;\n      predictedScore.value = null;\n      quizStarted.value = false;\n      quizFinished.value = false;\n      adaptiveQuestions.value = [];\n      userResponses.value = [];\n      if (fileInput.value) {\n        fileInput.value.value = '';\n      }\n    };\n\n    // Helper functions\n    async function readFileContent(file) {\n      return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = async e => {\n          try {\n            console.log('File type:', file.type);\n            console.log('File name:', file.name);\n\n            // Handle text files\n            if (file.type === \"text/plain\" || file.name.toLowerCase().endsWith('.txt')) {\n              const content = e.target.result;\n              if (!content || content.trim().length === 0) {\n                extractionErrors.value.push({\n                  fileName: file.name,\n                  message: 'File appears to be empty'\n                });\n                resolve('');\n              } else {\n                resolve(content);\n              }\n            }\n            // Handle PDF files\n            else if (file.type === \"application/pdf\" || file.name.toLowerCase().endsWith('.pdf')) {\n              try {\n                const arrayBuffer = e.target.result;\n                const pdf = await pdfjsLib.getDocument({\n                  data: arrayBuffer\n                }).promise;\n                let fullText = '';\n                for (let i = 1; i <= pdf.numPages; i++) {\n                  const page = await pdf.getPage(i);\n                  const textContent = await page.getTextContent();\n                  const pageText = textContent.items.map(item => item.str).join(' ');\n                  fullText += pageText + '\\n\\n';\n                }\n                if (!fullText.trim()) {\n                  throw new Error('No text content found in PDF');\n                }\n                resolve(fullText);\n              } catch (error) {\n                console.error('Error extracting PDF text:', error);\n                extractionErrors.value.push({\n                  fileName: file.name,\n                  message: `Error extracting PDF text: ${error.message}`\n                });\n                resolve('');\n              }\n            }\n            // Handle DOCX files\n            else if (file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" || file.name.toLowerCase().endsWith('.docx')) {\n              try {\n                const arrayBuffer = e.target.result;\n                const doc = new Document(arrayBuffer);\n                const text = doc.getParagraphs().map(p => p.text).join('\\n\\n');\n                if (!text.trim()) {\n                  throw new Error('No text content found in DOCX');\n                }\n                resolve(text);\n              } catch (error) {\n                console.error('Error extracting DOCX text:', error);\n                extractionErrors.value.push({\n                  fileName: file.name,\n                  message: `Error extracting DOCX text: ${error.message}`\n                });\n                resolve('');\n              }\n            }\n            // Handle PPTX files\n            else if (file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" || file.name.toLowerCase().endsWith('.pptx')) {\n              try {\n                const arrayBuffer = e.target.result;\n                const parser = new PptxParser();\n                const pptx = await parser.parse(arrayBuffer);\n                let text = '';\n                pptx.slides.forEach(slide => {\n                  if (slide.text) {\n                    text += slide.text + '\\n\\n';\n                  }\n                });\n                if (!text.trim()) {\n                  throw new Error('No text content found in PPTX');\n                }\n                resolve(text);\n              } catch (error) {\n                console.error('Error extracting PPTX text:', error);\n                extractionErrors.value.push({\n                  fileName: file.name,\n                  message: `Error extracting PPTX text: ${error.message}`\n                });\n                resolve('');\n              }\n            }\n            // Handle unsupported types\n            else {\n              console.warn('Unsupported file type:', file.type);\n              extractionErrors.value.push({\n                fileName: file.name,\n                message: `Unsupported file type: ${file.type || 'unknown'}. Please use PDF, DOCX, PPTX, or TXT files.`\n              });\n              resolve('');\n            }\n          } catch (error) {\n            console.error('Error processing file:', error);\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: `Error processing file: ${error.message}`\n            });\n            resolve('');\n          }\n        };\n        reader.onerror = error => {\n          console.error('Error reading file:', error);\n          extractionErrors.value.push({\n            fileName: file.name,\n            message: `Error reading file: ${error}`\n          });\n          resolve('');\n        };\n\n        // Read file as ArrayBuffer for binary files (PDF, DOCX, PPTX)\n        if (file.type === \"application/pdf\" || file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" || file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" || file.name.toLowerCase().match(/\\.(pdf|docx|pptx)$/)) {\n          reader.readAsArrayBuffer(file);\n        } else {\n          reader.readAsText(file);\n        }\n      });\n    }\n    async function generateQuestions(content, count) {\n      const prompt = `Create a quiz with ${count} COMPLETELY UNIQUE and DIVERSE questions based on this text. Each question MUST cover a different concept or aspect. NO REPETITIVE or SIMILAR questions allowed.\n\nCRITICAL REQUIREMENTS:\n1. Each explanation MUST be a direct quote or paraphrased content from the original text\n2. Explanations should reference specific parts of the text that justify the correct answer\n3. Do NOT make up explanations - they must be based on the actual content provided\n4. If a concept isn't clearly explained in the text, don't create a question about it\n5. Automatically determine appropriate difficulty (easy/medium/hard) based on:\n   - Easy: Basic facts, definitions, or simple concepts\n   - Medium: Understanding relationships between concepts\n   - Hard: Analysis, evaluation, or complex relationships\n\nFormat requirements for each question:\n\nFor multiple choice questions:\n1. Question: [unique question text]\n2. Options (mark correct with *):\n   A) [option]\n   B) [option]\n   C) [option]\n   D) [option]\n3. Explanation: [quote or paraphrase relevant text that explains the correct answer]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nFor true/false questions:\n1. True/False: [unique question text]\n2. Answer: [Write ONLY \"True*\" if true is correct, or \"False*\" if false is correct]\n3. Explanation: [quote or paraphrase relevant text that explains why the statement is true or false]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nIMPORTANT:\n- Each question MUST cover a different topic/concept\n- NO similar or overlapping questions\n- Make questions engaging and thought-provoking\n- Ensure clear, unambiguous wording\n- ALL explanations must come from the provided text\n- For true/false questions, ALWAYS mark the correct answer with an asterisk (*)\n- Distribute difficulties naturally based on content complexity\n\nText to base questions on:\n${content}`;\n      const response = await axios.post(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.VUE_APP_GEMINI_API_KEY}`, {\n        contents: [{\n          parts: [{\n            text: prompt\n          }]\n        }],\n        generationConfig: {\n          temperature: 0.7,\n          topK: 40,\n          topP: 0.95,\n          maxOutputTokens: 2048\n        }\n      }, {\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      return response.data.candidates[0].content.parts[0].text;\n    }\n    function processQuizResponse(response, content) {\n      const questions = [];\n      const lines = response.split('\\n');\n      let currentQuestion = null;\n      let collectingOptions = false;\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i].trim();\n        if (!line) continue;\n        if (/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i.test(line)) {\n          if (currentQuestion) {\n            findExplanationFromContent(currentQuestion, content);\n            questions.push(currentQuestion);\n          }\n          currentQuestion = {\n            text: line.replace(/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i, '').trim(),\n            type: 'multiple-choice',\n            options: {},\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n          collectingOptions = true;\n        } else if (/^\\d*\\.?\\s*(True\\/False:|True or False:)/i.test(line)) {\n          if (currentQuestion) {\n            findExplanationFromContent(currentQuestion, content);\n            questions.push(currentQuestion);\n          }\n          currentQuestion = {\n            text: line.replace(/^\\d*\\.?\\s*(True\\/False:|True or False:)/i, '').trim(),\n            type: 'true-false',\n            options: {\n              'true': 'True',\n              'false': 'False'\n            },\n            correctAnswer: '',\n            explanation: '',\n            difficulty: 'medium'\n          };\n          collectingOptions = true;\n        } else if (currentQuestion && collectingOptions) {\n          if (currentQuestion.type === 'multiple-choice') {\n            const optionMatch = line.match(/^([A-Da-d])[).]\\s*(.*)/);\n            if (optionMatch) {\n              const letter = optionMatch[1].toUpperCase();\n              let option = optionMatch[2].trim();\n              if (option.startsWith('*') || option.endsWith('*')) {\n                currentQuestion.correctAnswer = letter;\n                option = option.replace(/^\\*|\\*$/g, '').trim();\n              }\n              currentQuestion.options[letter] = option;\n            }\n          } else if (currentQuestion.type === 'true-false') {\n            if (line.toLowerCase().startsWith('answer:')) {\n              const answer = line.substring(7).trim().toLowerCase();\n              if (answer.includes('true*') || answer.includes('*true')) {\n                currentQuestion.correctAnswer = 'true';\n              } else if (answer.includes('false*') || answer.includes('*false')) {\n                currentQuestion.correctAnswer = 'false';\n              }\n            }\n          }\n          if (line.toLowerCase().startsWith('difficulty:')) {\n            const difficulty = line.substring(10).trim().toLowerCase();\n            if (['easy', 'medium', 'hard'].includes(difficulty)) {\n              currentQuestion.difficulty = difficulty;\n            }\n          }\n        }\n      }\n\n      // Don't forget to add the last question\n      if (currentQuestion) {\n        findExplanationFromContent(currentQuestion, content);\n        questions.push(currentQuestion);\n      }\n\n      // Validate and fix questions\n      const validQuestions = questions.filter(q => {\n        if (q.type === 'multiple-choice') {\n          return Object.keys(q.options).length >= 2 && q.correctAnswer;\n        } else if (q.type === 'true-false') {\n          if (!q.correctAnswer) {\n            q.correctAnswer = 'false'; // Default to false if not specified\n          }\n          return true;\n        }\n        return false;\n      });\n      if (validQuestions.length === 0) {\n        throw new Error('No valid questions could be generated from the content.');\n      }\n      return {\n        questions: validQuestions\n      };\n    }\n    function findExplanationFromContent(question, content) {\n      // Split content into paragraphs\n      const paragraphs = content.split(/\\n\\s*\\n/);\n\n      // Create search terms from the question and answer\n      const searchTerms = [...question.text.toLowerCase().replace(/[.,?!]/g, '').split(' '), ...(question.type === 'multiple-choice' && question.options[question.correctAnswer] ? question.options[question.correctAnswer].toLowerCase().split(' ') : [])].filter(word => word.length > 3);\n\n      // Find relevant paragraphs with scoring\n      const relevantParagraphs = paragraphs.map(paragraph => {\n        const normalizedParagraph = paragraph.toLowerCase();\n        let score = 0;\n\n        // Score exact phrase matches higher\n        if (normalizedParagraph.includes(question.text.toLowerCase())) {\n          score += 15;\n        }\n\n        // Score keyword matches\n        searchTerms.forEach(term => {\n          if (normalizedParagraph.includes(term)) {\n            score += 2;\n          }\n        });\n        return {\n          text: paragraph.trim(),\n          score\n        };\n      }).filter(p => p.score > 0).sort((a, b) => b.score - a.score).slice(0, 1); // Get most relevant paragraph\n\n      if (relevantParagraphs.length > 0) {\n        question.explanation = relevantParagraphs[0].text;\n      } else {\n        // Basic fallback explanations\n        if (question.type === 'true-false') {\n          const isTrue = question.correctAnswer === 'true';\n          question.explanation = `This statement is ${isTrue ? 'true' : 'false'} based on the provided content.`;\n        } else {\n          const correctOption = question.options[question.correctAnswer];\n          question.explanation = `The correct answer is \"${correctOption}\" according to the material.`;\n        }\n      }\n    }\n    function selectQuestions(questions) {\n      // First, shuffle all questions\n      const shuffledQuestions = [...questions].sort(() => Math.random() - 0.5);\n\n      // Remove duplicates while preserving order\n      const uniqueQuestions = shuffledQuestions.filter((question, index, self) => index === self.findIndex(q => q.text.toLowerCase().replace(/[^\\w\\s]/g, '') === question.text.toLowerCase().replace(/[^\\w\\s]/g, '')));\n\n      // Make sure we have enough questions\n      if (uniqueQuestions.length < Number(questionCount.value)) {\n        console.warn(`Only ${uniqueQuestions.length} unique questions available for ${questionCount.value} requested questions`);\n        return uniqueQuestions;\n      }\n\n      // Select the requested number of questions while maintaining difficulty distribution\n      const targetPerDifficulty = Math.ceil(Number(questionCount.value) / 3);\n      const selectedQuestions = [];\n      const difficultyCount = {\n        easy: 0,\n        medium: 0,\n        hard: 0\n      };\n\n      // First pass: try to get equal distribution\n      uniqueQuestions.forEach(question => {\n        const difficulty = question.difficulty || 'medium';\n        if (difficultyCount[difficulty] < targetPerDifficulty && selectedQuestions.length < Number(questionCount.value)) {\n          selectedQuestions.push(question);\n          difficultyCount[difficulty]++;\n        }\n      });\n\n      // Second pass: fill remaining slots if any\n      if (selectedQuestions.length < Number(questionCount.value)) {\n        uniqueQuestions.forEach(question => {\n          if (!selectedQuestions.includes(question) && selectedQuestions.length < Number(questionCount.value)) {\n            selectedQuestions.push(question);\n          }\n        });\n      }\n      return selectedQuestions;\n    }\n    function calculatePredictedScore() {\n      const contentCoverage = analyzeContentForCoverage();\n      const contentComplexity = analyzeContentComplexity();\n      const questionDiversity = analyzeQuestionDiversity();\n\n      // Weight factors\n      const coverageWeight = 0.4;\n      const complexityWeight = 0.3;\n      const diversityWeight = 0.3;\n\n      // Calculate weighted score\n      const predictedScore = contentCoverage * coverageWeight + contentComplexity * complexityWeight + questionDiversity * diversityWeight;\n      return Math.max(0, Math.min(100, Math.round(predictedScore)));\n    }\n    function analyzeContentForCoverage() {\n      // Analyze how well the content matches with generated questions\n      const totalContent = extractedContent.value.length;\n      if (totalContent === 0) return 0;\n\n      // Calculate coverage based on content length and number of questions\n      const averageContentPerQuestion = 500; // baseline characters per question\n      const expectedQuestions = Math.ceil(totalContent / averageContentPerQuestion);\n      const actualQuestions = Number(questionCount.value);\n      const coverage = Math.min(actualQuestions / expectedQuestions, 1) * 100;\n      return coverage;\n    }\n    function analyzeContentComplexity() {\n      const content = extractedContent.value.toLowerCase();\n\n      // Define complexity indicators\n      const complexityIndicators = ['analyze', 'compare', 'contrast', 'evaluate', 'explain', 'describe', 'discuss', 'examine', 'interpret', 'justify', 'therefore', 'however', 'although', 'furthermore', 'consequently'];\n\n      // Count complexity indicators\n      let complexityScore = 0;\n      complexityIndicators.forEach(indicator => {\n        const regex = new RegExp(indicator, 'g');\n        const matches = content.match(regex);\n        if (matches) {\n          complexityScore += matches.length;\n        }\n      });\n\n      // Normalize score to 0-100 range\n      const normalizedScore = Math.min(complexityScore * 5, 100);\n      return normalizedScore;\n    }\n    function analyzeQuestionDiversity() {\n      if (!adaptiveQuestions.value.length) return 0;\n\n      // Count different types of questions\n      const types = new Set(adaptiveQuestions.value.map(q => q.type));\n      const typesDiversity = types.size / 2 * 50; // 2 is max types (multiple-choice and true-false)\n\n      // Analyze question text similarity to ensure diverse topics\n      const questionTexts = adaptiveQuestions.value.map(q => q.text.toLowerCase());\n      let uniqueTopics = 0;\n      const processedKeywords = new Set();\n      questionTexts.forEach(text => {\n        const keywords = text.split(' ').filter(word => word.length > 4) // Consider only significant words\n        .map(word => word.replace(/[^a-z]/g, '')); // Clean up words\n\n        keywords.forEach(keyword => {\n          if (!processedKeywords.has(keyword)) {\n            uniqueTopics++;\n            processedKeywords.add(keyword);\n          }\n        });\n      });\n      const topicsDiversity = Math.min(uniqueTopics / questionTexts.length * 50, 50);\n      return typesDiversity + topicsDiversity;\n    }\n\n    // Results formatting\n    const formatQuestionsForResults = computed(() => {\n      return adaptiveQuestions.value.map((q, index) => ({\n        text: q.text,\n        type: q.type,\n        options: q.options,\n        userAnswer: userResponses.value[index]?.userAnswer,\n        correctAnswer: q.correctAnswer,\n        explanation: q.explanation,\n        isCorrect: userResponses.value[index]?.correct\n      }));\n    });\n    const formatUserAnswersForResults = computed(() => {\n      return userResponses.value.map(r => r.userAnswer);\n    });\n    const correctAnswersCount = computed(() => {\n      return userResponses.value.filter(r => r.correct).length;\n    });\n\n    // Update the calculateScore function\n    const calculateScore = () => {\n      if (!userResponses.value.length) return 0;\n      const correctAnswers = userResponses.value.filter(r => r.correct).length;\n      return Math.round(correctAnswers / userResponses.value.length * 100);\n    };\n\n    // Update the saveQuizResults function to handle retakes\n    const saveQuizResults = () => {\n      const quizResult = {\n        fileName: selectedFiles.value[0]?.name || 'Untitled Quiz',\n        questionCount: Number(questionCount.value),\n        predictedScore: predictedScore.value,\n        actualScore: calculateScore(),\n        date: new Date(),\n        fileContent: extractedContent.value\n      };\n      if (isRetaking.value && retakeIndex.value !== -1) {\n        // Update existing record\n        quizHistory.value[retakeIndex.value] = {\n          ...quizHistory.value[retakeIndex.value],\n          actualScore: quizResult.actualScore,\n          date: quizResult.date\n        };\n      } else {\n        // Add new record\n        quizHistory.value.unshift(quizResult);\n      }\n      localStorage.setItem('quizHistory', JSON.stringify(quizHistory.value));\n\n      // Reset retake flags\n      isRetaking.value = false;\n      retakeIndex.value = -1;\n    };\n\n    // Update the handleRetakeQuiz function to set retake flags\n    const handleRetakeQuiz = async quizToRetake => {\n      // Find the index of the quiz being retaken\n      retakeIndex.value = quizHistory.value.findIndex(quiz => quiz.fileName === quizToRetake.fileName && quiz.questionCount === quizToRetake.questionCount && quiz.fileContent === quizToRetake.fileContent);\n      if (retakeIndex.value === -1) {\n        console.error('Could not find original quiz to retake');\n        return;\n      }\n      isRetaking.value = true;\n\n      // Reset quiz state\n      quizStarted.value = false;\n      quizFinished.value = false;\n      predictedScore.value = null;\n      error.value = '';\n      adaptiveQuestions.value = [];\n      userResponses.value = [];\n\n      // Set the question count from the previous quiz\n      questionCount.value = quizToRetake.questionCount.toString();\n\n      // Create a dummy file with the same name\n      const file = new File([''], quizToRetake.fileName, {\n        type: 'text/plain'\n      });\n\n      // Set the selected file and content\n      selectedFiles.value = [file];\n      extractedContent.value = quizToRetake.fileContent;\n\n      // Generate new quiz using the stored content\n      try {\n        isLoading.value = true;\n        const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n        const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n        const processedQuiz = processQuizResponse(response, extractedContent.value);\n        adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n        predictedScore.value = calculatePredictedScore();\n      } catch (err) {\n        error.value = `Error generating questions: ${err.response?.data?.error?.message || err.message}`;\n        // Reset retake flags on error\n        isRetaking.value = false;\n        retakeIndex.value = -1;\n      } finally {\n        isLoading.value = false;\n      }\n    };\n\n    // Update handleCreateQuiz to reset retake flags\n    const handleCreateQuiz = () => {\n      // Reset the quiz state\n      quizStarted.value = false;\n      quizFinished.value = false;\n      predictedScore.value = null;\n      selectedFiles.value = [];\n      questionCount.value = '';\n      error.value = '';\n      extractedContent.value = '';\n      adaptiveQuestions.value = [];\n      userResponses.value = [];\n      isRetaking.value = false;\n      retakeIndex.value = -1;\n    };\n\n    // Add the clearHistory function\n    const clearHistory = () => {\n      if (confirm('Are you sure you want to clear all quiz history? This cannot be undone.')) {\n        quizHistory.value = [];\n        localStorage.removeItem('quizHistory');\n      }\n    };\n    const __returned__ = {\n      selectedFiles,\n      fileInput,\n      unsupportedFiles,\n      extractionErrors,\n      questionCount,\n      isLoading,\n      error,\n      predictedScore,\n      quizStarted,\n      quizFinished,\n      adaptiveQuestions,\n      userResponses,\n      extractedContent,\n      quizHistory,\n      isRetaking,\n      retakeIndex,\n      isFormValid,\n      hasFileErrors,\n      getPredictedScoreClass,\n      triggerFileInput,\n      handleFileSelect,\n      handleDrop,\n      addFiles,\n      removeFile,\n      handleSubmit,\n      startQuiz,\n      handleQuizComplete,\n      restartQuiz,\n      resetToMainScreen,\n      readFileContent,\n      generateQuestions,\n      processQuizResponse,\n      findExplanationFromContent,\n      selectQuestions,\n      calculatePredictedScore,\n      analyzeContentForCoverage,\n      analyzeContentComplexity,\n      analyzeQuestionDiversity,\n      formatQuestionsForResults,\n      formatUserAnswersForResults,\n      correctAnswersCount,\n      calculateScore,\n      saveQuizResults,\n      handleRetakeQuiz,\n      handleCreateQuiz,\n      clearHistory,\n      ref,\n      computed,\n      onMounted,\n      get axios() {\n        return axios;\n      },\n      FileErrorDisplay,\n      QuizResults,\n      FlashcardQuiz,\n      Sidebar,\n      get pdfjsLib() {\n        return pdfjsLib;\n      },\n      get Document() {\n        return Document;\n      },\n      get PptxParser() {\n        return PptxParser;\n      }\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ref","computed","onMounted","axios","FileErrorDisplay","QuizResults","FlashcardQuiz","Sidebar","pdfjsLib","Document","PptxParser","GlobalWorkerOptions","workerSrc","version","selectedFiles","fileInput","unsupportedFiles","extractionErrors","questionCount","isLoading","error","predictedScore","quizStarted","quizFinished","adaptiveQuestions","userResponses","extractedContent","quizHistory","isRetaking","retakeIndex","savedHistory","localStorage","getItem","value","JSON","parse","isFormValid","length","hasFileErrors","getPredictedScoreClass","triggerFileInput","click","handleFileSelect","event","files","Array","from","target","addFiles","handleDrop","dataTransfer","validTypes","validFiles","invalidFiles","forEach","file","includes","type","push","removeFile","index","splice","handleSubmit","console","log","map","f","name","fileContents","Promise","all","readFileContent","validContents","filter","content","trim","Error","join","requestedQuestionCount","Math","min","Number","response","generateQuestions","processedQuiz","processQuizResponse","questions","selectQuestions","calculatePredictedScore","err","message","startQuiz","handleQuizComplete","responses","question","userAnswer","isCorrect","correct","saveQuizResults","restartQuiz","resetToMainScreen","resolve","reader","FileReader","onload","e","toLowerCase","endsWith","result","fileName","arrayBuffer","pdf","getDocument","data","promise","fullText","i","numPages","page","getPage","textContent","getTextContent","pageText","items","item","str","doc","text","getParagraphs","p","parser","pptx","slides","slide","warn","onerror","match","readAsArrayBuffer","readAsText","count","prompt","post","process","env","VUE_APP_GEMINI_API_KEY","contents","parts","generationConfig","temperature","topK","topP","maxOutputTokens","headers","candidates","lines","split","currentQuestion","collectingOptions","line","test","findExplanationFromContent","replace","options","correctAnswer","explanation","difficulty","optionMatch","letter","toUpperCase","option","startsWith","answer","substring","validQuestions","q","Object","keys","paragraphs","searchTerms","word","relevantParagraphs","paragraph","normalizedParagraph","score","term","sort","a","b","slice","isTrue","correctOption","shuffledQuestions","random","uniqueQuestions","self","findIndex","targetPerDifficulty","ceil","selectedQuestions","difficultyCount","easy","medium","hard","contentCoverage","analyzeContentForCoverage","contentComplexity","analyzeContentComplexity","questionDiversity","analyzeQuestionDiversity","coverageWeight","complexityWeight","diversityWeight","max","round","totalContent","averageContentPerQuestion","expectedQuestions","actualQuestions","coverage","complexityIndicators","complexityScore","indicator","regex","RegExp","matches","normalizedScore","types","Set","typesDiversity","size","questionTexts","uniqueTopics","processedKeywords","keywords","keyword","has","add","topicsDiversity","formatQuestionsForResults","formatUserAnswersForResults","r","correctAnswersCount","calculateScore","correctAnswers","quizResult","actualScore","date","Date","fileContent","unshift","setItem","stringify","handleRetakeQuiz","quizToRetake","quiz","toString","File","handleCreateQuiz","clearHistory","confirm","removeItem"],"sources":["C:/Users/StevenJakeASOY/Documents/cursor-projects/src/App.vue"],"sourcesContent":["<template>\n  <div class=\"app-container\">\n    <Sidebar \n      :quiz-history=\"quizHistory\" \n      @create-quiz=\"handleCreateQuiz\"\n      @retake-quiz=\"handleRetakeQuiz\"\n      @clear-history=\"clearHistory\"\n    />\n    <div class=\"main-content\">\n      <div class=\"upload-container\">\n        <h1>QUIZZy</h1>\n        \n        <div v-if=\"!quizStarted && !quizFinished && predictedScore === null\" class=\"file-upload-section\">\n          <h2>Upload Files</h2>\n          <div class=\"upload-area\" \n            @dragover.prevent \n            @drop.prevent=\"handleDrop\"\n            @click=\"triggerFileInput\"\n            role=\"button\"\n            tabindex=\"0\"\n            @keydown.enter=\"triggerFileInput\"\n          >\n            <input \n              type=\"file\" \n              @change=\"handleFileSelect\" \n              accept=\".pdf,.docx,.pptx,.txt\"\n              ref=\"fileInput\"\n              class=\"file-input\"\n            >\n            <div class=\"upload-prompt\">\n              <p>Drag and drop files here or click to select</p>\n              <div class=\"supported-formats\">\n                <p>Supported formats:</p>\n                <ul>\n                  <li><span class=\"format-icon\">üìÑ</span> Documents (PDF, DOCX)</li>\n                  <li><span class=\"format-icon\">üìä</span> Presentations (PPTX)</li>\n                  <li><span class=\"format-icon\">üìù</span> Text files (TXT)</li>\n                </ul>\n              </div>\n            </div>\n          </div>\n          \n          <div v-if=\"hasFileErrors\" class=\"error-section\">\n            <FileErrorDisplay\n              :extraction-errors=\"extractionErrors\"\n              :unsupported-files=\"unsupportedFiles\"\n            />\n          </div>\n\n          <div v-if=\"selectedFiles.length > 0\" class=\"selected-files\">\n            <h3>Selected Files:</h3>\n            <ul>\n              <li v-for=\"(file, index) in selectedFiles\" :key=\"index\" class=\"file-item\">\n                <span class=\"file-name\">{{ file.name }}</span>\n                <button @click=\"removeFile(index)\" class=\"remove-btn\" title=\"Remove file\">√ó</button>\n              </li>\n            </ul>\n          </div>\n\n          <div class=\"questions-section\">\n            <h2>Number of Questions</h2>\n            <div class=\"question-input\">\n              <input\n                type=\"number\"\n                v-model=\"questionCount\"\n                min=\"1\"\n                max=\"20\"\n                placeholder=\"Enter number of questions\"\n              />\n            </div>\n          </div>\n\n          <button \n            class=\"submit-btn\" \n            :disabled=\"!isFormValid || isLoading\"\n            @click=\"handleSubmit\"\n          >\n            {{ isLoading ? 'Generating Questions...' : 'Submit' }}\n          </button>\n        </div>\n\n        <div v-if=\"predictedScore !== null && !quizStarted && !quizFinished\">\n          <div class=\"predicted-score-container\">\n            <h2>Ready to Start!</h2>\n            <div class=\"score-prediction\">\n              <div class=\"score-circle\" :class=\"getPredictedScoreClass\">\n                <span class=\"predicted-value\">{{ predictedScore }}%</span>\n                <span class=\"prediction-label\">Predicted Score</span>\n              </div>\n            </div>\n            <p class=\"prediction-explanation\">\n              Based on your study material, we predict you'll score around {{ predictedScore }}%.\n            </p>\n            <button class=\"start-quiz-btn\" @click=\"startQuiz\">Start Quiz</button>\n          </div>\n        </div>\n\n        <FlashcardQuiz\n          v-if=\"quizStarted && !quizFinished\"\n          :questions=\"adaptiveQuestions\"\n          :total-questions=\"Number(questionCount)\"\n          @quiz-completed=\"handleQuizComplete\"\n        />\n\n        <QuizResults\n          v-if=\"quizFinished\"\n          :questions=\"formatQuestionsForResults\"\n          :user-answers=\"formatUserAnswersForResults\"\n          :score=\"correctAnswersCount\"\n          :predicted-score=\"predictedScore\"\n          @restart=\"restartQuiz\"\n          @go-back=\"resetToMainScreen\"\n        />\n\n        <div v-if=\"error\" class=\"error-message\">\n          {{ error }}\n        </div>\n      </div>\n    </div>\n\n    <!-- Loading Overlay -->\n    <div v-if=\"isLoading\" class=\"loading-overlay\">\n      <div class=\"loading-content\">\n        <div class=\"typewriter\">Generating quiz</div>\n        <div class=\"dots\">\n          <span>.</span>\n          <span>.</span>\n          <span>.</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from 'vue';\nimport axios from 'axios';\nimport FileErrorDisplay from './components/FileErrorDisplay.vue';\nimport QuizResults from './components/QuizResults.vue';\nimport FlashcardQuiz from './components/FlashcardQuiz.vue';\nimport Sidebar from './components/Sidebar.vue';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport { Document } from 'docx';\nimport { PptxParser } from 'pptx-parser';\n\n// Set up PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\n// File handling state\nconst selectedFiles = ref([]);\nconst fileInput = ref(null);\nconst unsupportedFiles = ref([]);\nconst extractionErrors = ref([]);\n\n// Quiz state\nconst questionCount = ref('');\nconst isLoading = ref(false);\nconst error = ref('');\nconst predictedScore = ref(null);\nconst quizStarted = ref(false);\nconst quizFinished = ref(false);\nconst adaptiveQuestions = ref([]);\nconst userResponses = ref([]);\nconst extractedContent = ref('');\n\n// Add quiz history state\nconst quizHistory = ref([]);\n\n// Add isRetaking flag to track retakes\nconst isRetaking = ref(false);\nconst retakeIndex = ref(-1);\n\n// Load quiz history from localStorage on mount\nonMounted(() => {\n  const savedHistory = localStorage.getItem('quizHistory');\n  if (savedHistory) {\n    quizHistory.value = JSON.parse(savedHistory);\n  }\n});\n\n// Computed properties\nconst isFormValid = computed(() => {\n  return selectedFiles.value.length > 0 && questionCount.value > 0;\n});\n\nconst hasFileErrors = computed(() => {\n  return extractionErrors.value.length > 0 || unsupportedFiles.value.length > 0;\n});\n\nconst getPredictedScoreClass = computed(() => {\n  if (predictedScore.value >= 80) return 'high';\n  if (predictedScore.value >= 60) return 'medium';\n  return 'low';\n});\n\n// File handling methods\nconst triggerFileInput = () => {\n  fileInput.value.click();\n};\n\nconst handleFileSelect = (event) => {\n  const files = Array.from(event.target.files);\n  addFiles(files);\n};\n\nconst handleDrop = (event) => {\n  const files = Array.from(event.dataTransfer.files);\n  addFiles(files);\n};\n\nconst addFiles = (files) => {\n  const validTypes = [\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/vnd.ms-powerpoint',\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n    'text/plain',\n    'application/pdf',\n    'image/png',\n    'image/jpeg',\n    'image/jpg',\n    'image/tiff',\n    'image/bmp'\n  ];\n  \n  const validFiles = [];\n  const invalidFiles = [];\n  \n  files.forEach(file => {\n    if (validTypes.includes(file.type)) {\n      validFiles.push(file);\n    } else {\n      invalidFiles.push(file);\n    }\n  });\n  \n  selectedFiles.value = [...selectedFiles.value, ...validFiles];\n  unsupportedFiles.value = [...unsupportedFiles.value, ...invalidFiles];\n};\n\nconst removeFile = (index) => {\n  selectedFiles.value.splice(index, 1);\n};\n\n// Quiz handling methods\nconst handleSubmit = async () => {\n  if (!isFormValid.value) return;\n\n  isLoading.value = true;\n  error.value = '';\n  adaptiveQuestions.value = [];\n  predictedScore.value = null;\n  quizStarted.value = false;\n  userResponses.value = [];\n  extractedContent.value = '';\n  extractionErrors.value = []; // Clear previous errors\n\n  try {\n    console.log('Processing files:', selectedFiles.value.map(f => ({ name: f.name, type: f.type })));\n    \n    const fileContents = await Promise.all(\n      selectedFiles.value.map(file => readFileContent(file))\n    );\n\n    // Filter out empty content and join\n    const validContents = fileContents.filter(content => content && content.trim().length > 0);\n    console.log('Number of files with valid content:', validContents.length);\n    \n    if (validContents.length === 0) {\n      throw new Error('No valid content could be extracted from the selected files. Please upload text (.txt) files with actual content.');\n    }\n\n    extractedContent.value = validContents.join('\\n\\n');\n    console.log('Total content length:', extractedContent.value.length);\n    \n    if (extractedContent.value.trim().length < 50) {\n      throw new Error('The extracted content is too short to generate meaningful questions. Please provide more content (at least 50 characters).');\n    }\n\n    const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n    console.log('Requesting questions:', requestedQuestionCount);\n    \n    const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n    \n    if (!response) {\n      throw new Error('No response received from the question generation service.');\n    }\n\n    const processedQuiz = processQuizResponse(response, extractedContent.value);\n    \n    if (!processedQuiz || !processedQuiz.questions || processedQuiz.questions.length === 0) {\n      throw new Error('No valid questions could be generated. Please check if the content is suitable for question generation.');\n    }\n\n    console.log('Generated questions:', processedQuiz.questions.length);\n    adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n    predictedScore.value = calculatePredictedScore();\n\n  } catch (err) {\n    console.error('Error in handleSubmit:', err);\n    error.value = err.message || 'An unexpected error occurred while generating questions.';\n  } finally {\n    isLoading.value = false;\n  }\n};\n\nconst startQuiz = () => {\n  quizStarted.value = true;\n  quizFinished.value = false;\n};\n\nconst handleQuizComplete = (responses) => {\n  userResponses.value = responses;\n  // Update the adaptiveQuestions with user answers\n  adaptiveQuestions.value = adaptiveQuestions.value.map((question, index) => ({\n    ...question,\n    userAnswer: responses[index]?.userAnswer,\n    isCorrect: responses[index]?.correct\n  }));\n  quizFinished.value = true;\n  saveQuizResults();\n};\n\nconst restartQuiz = () => {\n  quizStarted.value = true;\n  quizFinished.value = false;\n  userResponses.value = [];\n};\n\nconst resetToMainScreen = () => {\n  selectedFiles.value = [];\n  unsupportedFiles.value = [];\n  extractionErrors.value = [];\n  questionCount.value = '';\n  error.value = '';\n  isLoading.value = false;\n  predictedScore.value = null;\n  quizStarted.value = false;\n  quizFinished.value = false;\n  adaptiveQuestions.value = [];\n  userResponses.value = [];\n  if (fileInput.value) {\n    fileInput.value.value = '';\n  }\n};\n\n// Helper functions\nasync function readFileContent(file) {\n  return new Promise((resolve) => {\n    const reader = new FileReader();\n    \n    reader.onload = async (e) => {\n      try {\n        console.log('File type:', file.type);\n        console.log('File name:', file.name);\n        \n        // Handle text files\n        if (file.type === \"text/plain\" || file.name.toLowerCase().endsWith('.txt')) {\n          const content = e.target.result;\n          if (!content || content.trim().length === 0) {\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: 'File appears to be empty'\n            });\n            resolve('');\n          } else {\n            resolve(content);\n          }\n        }\n        // Handle PDF files\n        else if (file.type === \"application/pdf\" || file.name.toLowerCase().endsWith('.pdf')) {\n          try {\n            const arrayBuffer = e.target.result;\n            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n            let fullText = '';\n            \n            for (let i = 1; i <= pdf.numPages; i++) {\n              const page = await pdf.getPage(i);\n              const textContent = await page.getTextContent();\n              const pageText = textContent.items.map(item => item.str).join(' ');\n              fullText += pageText + '\\n\\n';\n            }\n            \n            if (!fullText.trim()) {\n              throw new Error('No text content found in PDF');\n            }\n            \n            resolve(fullText);\n          } catch (error) {\n            console.error('Error extracting PDF text:', error);\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: `Error extracting PDF text: ${error.message}`\n            });\n            resolve('');\n          }\n        }\n        // Handle DOCX files\n        else if (file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" || \n                 file.name.toLowerCase().endsWith('.docx')) {\n          try {\n            const arrayBuffer = e.target.result;\n            const doc = new Document(arrayBuffer);\n            const text = doc.getParagraphs()\n              .map(p => p.text)\n              .join('\\n\\n');\n            \n            if (!text.trim()) {\n              throw new Error('No text content found in DOCX');\n            }\n            \n            resolve(text);\n          } catch (error) {\n            console.error('Error extracting DOCX text:', error);\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: `Error extracting DOCX text: ${error.message}`\n            });\n            resolve('');\n          }\n        }\n        // Handle PPTX files\n        else if (file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" || \n                 file.name.toLowerCase().endsWith('.pptx')) {\n          try {\n            const arrayBuffer = e.target.result;\n            const parser = new PptxParser();\n            const pptx = await parser.parse(arrayBuffer);\n            let text = '';\n            \n            pptx.slides.forEach(slide => {\n              if (slide.text) {\n                text += slide.text + '\\n\\n';\n              }\n            });\n            \n            if (!text.trim()) {\n              throw new Error('No text content found in PPTX');\n            }\n            \n            resolve(text);\n          } catch (error) {\n            console.error('Error extracting PPTX text:', error);\n            extractionErrors.value.push({\n              fileName: file.name,\n              message: `Error extracting PPTX text: ${error.message}`\n            });\n            resolve('');\n          }\n        }\n        // Handle unsupported types\n        else {\n          console.warn('Unsupported file type:', file.type);\n          extractionErrors.value.push({\n            fileName: file.name,\n            message: `Unsupported file type: ${file.type || 'unknown'}. Please use PDF, DOCX, PPTX, or TXT files.`\n          });\n          resolve('');\n        }\n      } catch (error) {\n        console.error('Error processing file:', error);\n        extractionErrors.value.push({\n          fileName: file.name,\n          message: `Error processing file: ${error.message}`\n        });\n        resolve('');\n      }\n    };\n    \n    reader.onerror = (error) => {\n      console.error('Error reading file:', error);\n      extractionErrors.value.push({\n        fileName: file.name,\n        message: `Error reading file: ${error}`\n      });\n      resolve('');\n    };\n    \n    // Read file as ArrayBuffer for binary files (PDF, DOCX, PPTX)\n    if (file.type === \"application/pdf\" || \n        file.type === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\" ||\n        file.type === \"application/vnd.openxmlformats-officedocument.presentationml.presentation\" ||\n        file.name.toLowerCase().match(/\\.(pdf|docx|pptx)$/)) {\n      reader.readAsArrayBuffer(file);\n    } else {\n      reader.readAsText(file);\n    }\n  });\n}\n\nasync function generateQuestions(content, count) {\n  const prompt = `Create a quiz with ${count} COMPLETELY UNIQUE and DIVERSE questions based on this text. Each question MUST cover a different concept or aspect. NO REPETITIVE or SIMILAR questions allowed.\n\nCRITICAL REQUIREMENTS:\n1. Each explanation MUST be a direct quote or paraphrased content from the original text\n2. Explanations should reference specific parts of the text that justify the correct answer\n3. Do NOT make up explanations - they must be based on the actual content provided\n4. If a concept isn't clearly explained in the text, don't create a question about it\n5. Automatically determine appropriate difficulty (easy/medium/hard) based on:\n   - Easy: Basic facts, definitions, or simple concepts\n   - Medium: Understanding relationships between concepts\n   - Hard: Analysis, evaluation, or complex relationships\n\nFormat requirements for each question:\n\nFor multiple choice questions:\n1. Question: [unique question text]\n2. Options (mark correct with *):\n   A) [option]\n   B) [option]\n   C) [option]\n   D) [option]\n3. Explanation: [quote or paraphrase relevant text that explains the correct answer]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nFor true/false questions:\n1. True/False: [unique question text]\n2. Answer: [Write ONLY \"True*\" if true is correct, or \"False*\" if false is correct]\n3. Explanation: [quote or paraphrase relevant text that explains why the statement is true or false]\n4. Difficulty: [AI determines: easy|medium|hard]\n\nIMPORTANT:\n- Each question MUST cover a different topic/concept\n- NO similar or overlapping questions\n- Make questions engaging and thought-provoking\n- Ensure clear, unambiguous wording\n- ALL explanations must come from the provided text\n- For true/false questions, ALWAYS mark the correct answer with an asterisk (*)\n- Distribute difficulties naturally based on content complexity\n\nText to base questions on:\n${content}`;\n\n  const response = await axios.post(\n    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${process.env.VUE_APP_GEMINI_API_KEY}`,\n    {\n      contents: [{\n        parts: [{\n          text: prompt\n        }]\n      }],\n      generationConfig: {\n        temperature: 0.7,\n        topK: 40,\n        topP: 0.95,\n        maxOutputTokens: 2048,\n      }\n    },\n    {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }\n  );\n\n  return response.data.candidates[0].content.parts[0].text;\n}\n\nfunction processQuizResponse(response, content) {\n  const questions = [];\n  const lines = response.split('\\n');\n  let currentQuestion = null;\n  let collectingOptions = false;\n  \n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    \n    if (/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i.test(line)) {\n      if (currentQuestion) {\n        findExplanationFromContent(currentQuestion, content);\n        questions.push(currentQuestion);\n      }\n      currentQuestion = {\n        text: line.replace(/^\\d*\\.?\\s*(Question:|Q:|Easy Question:|Hard Question:|Medium Question:)/i, '').trim(),\n        type: 'multiple-choice',\n        options: {},\n        correctAnswer: '',\n        explanation: '',\n        difficulty: 'medium'\n      };\n      collectingOptions = true;\n    } else if (/^\\d*\\.?\\s*(True\\/False:|True or False:)/i.test(line)) {\n      if (currentQuestion) {\n        findExplanationFromContent(currentQuestion, content);\n        questions.push(currentQuestion);\n      }\n      currentQuestion = {\n        text: line.replace(/^\\d*\\.?\\s*(True\\/False:|True or False:)/i, '').trim(),\n        type: 'true-false',\n        options: { \n          'true': 'True',\n          'false': 'False'\n        },\n        correctAnswer: '',\n        explanation: '',\n        difficulty: 'medium'\n      };\n      collectingOptions = true;\n    } else if (currentQuestion && collectingOptions) {\n      if (currentQuestion.type === 'multiple-choice') {\n        const optionMatch = line.match(/^([A-Da-d])[).]\\s*(.*)/);\n        if (optionMatch) {\n          const letter = optionMatch[1].toUpperCase();\n          let option = optionMatch[2].trim();\n          \n          if (option.startsWith('*') || option.endsWith('*')) {\n            currentQuestion.correctAnswer = letter;\n            option = option.replace(/^\\*|\\*$/g, '').trim();\n          }\n          currentQuestion.options[letter] = option;\n        }\n      } else if (currentQuestion.type === 'true-false') {\n        if (line.toLowerCase().startsWith('answer:')) {\n          const answer = line.substring(7).trim().toLowerCase();\n          if (answer.includes('true*') || answer.includes('*true')) {\n            currentQuestion.correctAnswer = 'true';\n          } else if (answer.includes('false*') || answer.includes('*false')) {\n            currentQuestion.correctAnswer = 'false';\n          }\n        }\n      }\n      \n      if (line.toLowerCase().startsWith('difficulty:')) {\n        const difficulty = line.substring(10).trim().toLowerCase();\n        if (['easy', 'medium', 'hard'].includes(difficulty)) {\n          currentQuestion.difficulty = difficulty;\n        }\n      }\n    }\n  }\n  \n  // Don't forget to add the last question\n  if (currentQuestion) {\n    findExplanationFromContent(currentQuestion, content);\n    questions.push(currentQuestion);\n  }\n\n  // Validate and fix questions\n  const validQuestions = questions.filter(q => {\n    if (q.type === 'multiple-choice') {\n      return Object.keys(q.options).length >= 2 && q.correctAnswer;\n    } else if (q.type === 'true-false') {\n      if (!q.correctAnswer) {\n        q.correctAnswer = 'false'; // Default to false if not specified\n      }\n      return true;\n    }\n    return false;\n  });\n\n  if (validQuestions.length === 0) {\n    throw new Error('No valid questions could be generated from the content.');\n  }\n  \n  return { questions: validQuestions };\n}\n\nfunction findExplanationFromContent(question, content) {\n  // Split content into paragraphs\n  const paragraphs = content.split(/\\n\\s*\\n/);\n  \n  // Create search terms from the question and answer\n  const searchTerms = [\n    ...question.text.toLowerCase().replace(/[.,?!]/g, '').split(' '),\n    ...(question.type === 'multiple-choice' && question.options[question.correctAnswer] \n      ? question.options[question.correctAnswer].toLowerCase().split(' ') \n      : [])\n  ].filter(word => word.length > 3);\n  \n  // Find relevant paragraphs with scoring\n  const relevantParagraphs = paragraphs.map(paragraph => {\n    const normalizedParagraph = paragraph.toLowerCase();\n    let score = 0;\n    \n    // Score exact phrase matches higher\n    if (normalizedParagraph.includes(question.text.toLowerCase())) {\n      score += 15;\n    }\n    \n    // Score keyword matches\n    searchTerms.forEach(term => {\n      if (normalizedParagraph.includes(term)) {\n        score += 2;\n      }\n    });\n\n    return {\n      text: paragraph.trim(),\n      score\n    };\n  }).filter(p => p.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 1); // Get most relevant paragraph\n\n  if (relevantParagraphs.length > 0) {\n    question.explanation = relevantParagraphs[0].text;\n  } else {\n    // Basic fallback explanations\n    if (question.type === 'true-false') {\n      const isTrue = question.correctAnswer === 'true';\n      question.explanation = `This statement is ${isTrue ? 'true' : 'false'} based on the provided content.`;\n    } else {\n      const correctOption = question.options[question.correctAnswer];\n      question.explanation = `The correct answer is \"${correctOption}\" according to the material.`;\n    }\n  }\n}\n\nfunction selectQuestions(questions) {\n  // First, shuffle all questions\n  const shuffledQuestions = [...questions].sort(() => Math.random() - 0.5);\n  \n  // Remove duplicates while preserving order\n  const uniqueQuestions = shuffledQuestions.filter((question, index, self) => \n    index === self.findIndex((q) => \n      q.text.toLowerCase().replace(/[^\\w\\s]/g, '') === \n      question.text.toLowerCase().replace(/[^\\w\\s]/g, '')\n    )\n  );\n\n  // Make sure we have enough questions\n  if (uniqueQuestions.length < Number(questionCount.value)) {\n    console.warn(`Only ${uniqueQuestions.length} unique questions available for ${questionCount.value} requested questions`);\n    return uniqueQuestions;\n  }\n\n  // Select the requested number of questions while maintaining difficulty distribution\n  const targetPerDifficulty = Math.ceil(Number(questionCount.value) / 3);\n  const selectedQuestions = [];\n  const difficultyCount = { easy: 0, medium: 0, hard: 0 };\n\n  // First pass: try to get equal distribution\n  uniqueQuestions.forEach(question => {\n    const difficulty = question.difficulty || 'medium';\n    if (difficultyCount[difficulty] < targetPerDifficulty && \n        selectedQuestions.length < Number(questionCount.value)) {\n      selectedQuestions.push(question);\n      difficultyCount[difficulty]++;\n    }\n  });\n\n  // Second pass: fill remaining slots if any\n  if (selectedQuestions.length < Number(questionCount.value)) {\n    uniqueQuestions.forEach(question => {\n      if (!selectedQuestions.includes(question) && \n          selectedQuestions.length < Number(questionCount.value)) {\n        selectedQuestions.push(question);\n      }\n    });\n  }\n\n  return selectedQuestions;\n}\n\nfunction calculatePredictedScore() {\n  const contentCoverage = analyzeContentForCoverage();\n  const contentComplexity = analyzeContentComplexity();\n  const questionDiversity = analyzeQuestionDiversity();\n  \n  // Weight factors\n  const coverageWeight = 0.4;\n  const complexityWeight = 0.3;\n  const diversityWeight = 0.3;\n  \n  // Calculate weighted score\n  const predictedScore = (\n    contentCoverage * coverageWeight +\n    contentComplexity * complexityWeight +\n    questionDiversity * diversityWeight\n  );\n  \n  return Math.max(0, Math.min(100, Math.round(predictedScore)));\n}\n\nfunction analyzeContentForCoverage() {\n  // Analyze how well the content matches with generated questions\n  const totalContent = extractedContent.value.length;\n  if (totalContent === 0) return 0;\n  \n  // Calculate coverage based on content length and number of questions\n  const averageContentPerQuestion = 500; // baseline characters per question\n  const expectedQuestions = Math.ceil(totalContent / averageContentPerQuestion);\n  const actualQuestions = Number(questionCount.value);\n  \n  const coverage = Math.min(actualQuestions / expectedQuestions, 1) * 100;\n  return coverage;\n}\n\nfunction analyzeContentComplexity() {\n  const content = extractedContent.value.toLowerCase();\n  \n  // Define complexity indicators\n  const complexityIndicators = [\n    'analyze', 'compare', 'contrast', 'evaluate', 'explain',\n    'describe', 'discuss', 'examine', 'interpret', 'justify',\n    'therefore', 'however', 'although', 'furthermore', 'consequently'\n  ];\n  \n  // Count complexity indicators\n  let complexityScore = 0;\n  complexityIndicators.forEach(indicator => {\n    const regex = new RegExp(indicator, 'g');\n    const matches = content.match(regex);\n    if (matches) {\n      complexityScore += matches.length;\n    }\n  });\n  \n  // Normalize score to 0-100 range\n  const normalizedScore = Math.min(complexityScore * 5, 100);\n  return normalizedScore;\n}\n\nfunction analyzeQuestionDiversity() {\n  if (!adaptiveQuestions.value.length) return 0;\n  \n  // Count different types of questions\n  const types = new Set(adaptiveQuestions.value.map(q => q.type));\n  const typesDiversity = (types.size / 2) * 50; // 2 is max types (multiple-choice and true-false)\n  \n  // Analyze question text similarity to ensure diverse topics\n  const questionTexts = adaptiveQuestions.value.map(q => q.text.toLowerCase());\n  let uniqueTopics = 0;\n  const processedKeywords = new Set();\n  \n  questionTexts.forEach(text => {\n    const keywords = text.split(' ')\n      .filter(word => word.length > 4) // Consider only significant words\n      .map(word => word.replace(/[^a-z]/g, '')); // Clean up words\n      \n    keywords.forEach(keyword => {\n      if (!processedKeywords.has(keyword)) {\n        uniqueTopics++;\n        processedKeywords.add(keyword);\n      }\n    });\n  });\n  \n  const topicsDiversity = Math.min(uniqueTopics / questionTexts.length * 50, 50);\n  \n  return typesDiversity + topicsDiversity;\n}\n\n// Results formatting\nconst formatQuestionsForResults = computed(() => {\n  return adaptiveQuestions.value.map((q, index) => ({\n    text: q.text,\n    type: q.type,\n    options: q.options,\n    userAnswer: userResponses.value[index]?.userAnswer,\n    correctAnswer: q.correctAnswer,\n    explanation: q.explanation,\n    isCorrect: userResponses.value[index]?.correct\n  }));\n});\n\nconst formatUserAnswersForResults = computed(() => {\n  return userResponses.value.map(r => r.userAnswer);\n});\n\nconst correctAnswersCount = computed(() => {\n  return userResponses.value.filter(r => r.correct).length;\n});\n\n// Update the calculateScore function\nconst calculateScore = () => {\n  if (!userResponses.value.length) return 0;\n  const correctAnswers = userResponses.value.filter(r => r.correct).length;\n  return Math.round((correctAnswers / userResponses.value.length) * 100);\n};\n\n// Update the saveQuizResults function to handle retakes\nconst saveQuizResults = () => {\n  const quizResult = {\n    fileName: selectedFiles.value[0]?.name || 'Untitled Quiz',\n    questionCount: Number(questionCount.value),\n    predictedScore: predictedScore.value,\n    actualScore: calculateScore(),\n    date: new Date(),\n    fileContent: extractedContent.value\n  };\n  \n  if (isRetaking.value && retakeIndex.value !== -1) {\n    // Update existing record\n    quizHistory.value[retakeIndex.value] = {\n      ...quizHistory.value[retakeIndex.value],\n      actualScore: quizResult.actualScore,\n      date: quizResult.date\n    };\n  } else {\n    // Add new record\n    quizHistory.value.unshift(quizResult);\n  }\n  \n  localStorage.setItem('quizHistory', JSON.stringify(quizHistory.value));\n  \n  // Reset retake flags\n  isRetaking.value = false;\n  retakeIndex.value = -1;\n};\n\n// Update the handleRetakeQuiz function to set retake flags\nconst handleRetakeQuiz = async (quizToRetake) => {\n  // Find the index of the quiz being retaken\n  retakeIndex.value = quizHistory.value.findIndex(quiz => \n    quiz.fileName === quizToRetake.fileName && \n    quiz.questionCount === quizToRetake.questionCount &&\n    quiz.fileContent === quizToRetake.fileContent\n  );\n  \n  if (retakeIndex.value === -1) {\n    console.error('Could not find original quiz to retake');\n    return;\n  }\n  \n  isRetaking.value = true;\n  \n  // Reset quiz state\n  quizStarted.value = false;\n  quizFinished.value = false;\n  predictedScore.value = null;\n  error.value = '';\n  adaptiveQuestions.value = [];\n  userResponses.value = [];\n  \n  // Set the question count from the previous quiz\n  questionCount.value = quizToRetake.questionCount.toString();\n  \n  // Create a dummy file with the same name\n  const file = new File([''], quizToRetake.fileName, {\n    type: 'text/plain'\n  });\n  \n  // Set the selected file and content\n  selectedFiles.value = [file];\n  extractedContent.value = quizToRetake.fileContent;\n  \n  // Generate new quiz using the stored content\n  try {\n    isLoading.value = true;\n    const requestedQuestionCount = Math.min(Number(questionCount.value) * 3, 30);\n    \n    const response = await generateQuestions(extractedContent.value, requestedQuestionCount);\n    const processedQuiz = processQuizResponse(response, extractedContent.value);\n    \n    adaptiveQuestions.value = selectQuestions(processedQuiz.questions);\n    predictedScore.value = calculatePredictedScore();\n  } catch (err) {\n    error.value = `Error generating questions: ${err.response?.data?.error?.message || err.message}`;\n    // Reset retake flags on error\n    isRetaking.value = false;\n    retakeIndex.value = -1;\n  } finally {\n    isLoading.value = false;\n  }\n};\n\n// Update handleCreateQuiz to reset retake flags\nconst handleCreateQuiz = () => {\n  // Reset the quiz state\n  quizStarted.value = false;\n  quizFinished.value = false;\n  predictedScore.value = null;\n  selectedFiles.value = [];\n  questionCount.value = '';\n  error.value = '';\n  extractedContent.value = '';\n  adaptiveQuestions.value = [];\n  userResponses.value = [];\n  isRetaking.value = false;\n  retakeIndex.value = -1;\n};\n\n// Add the clearHistory function\nconst clearHistory = () => {\n  if (confirm('Are you sure you want to clear all quiz history? This cannot be undone.')) {\n    quizHistory.value = [];\n    localStorage.removeItem('quizHistory');\n  }\n};\n</script>\n\n<style scoped>\n.app-container {\n  min-height: 100vh;\n  display: flex;\n  background-color: #f5f5f5;\n  font-family: \"Helvetica\", \"Arial\", sans-serif;\n}\n\n.main-content {\n  flex: 1;\n  margin-left: 280px; /* Same as sidebar width */\n  padding: 2rem;\n  display: flex;\n  justify-content: center;\n}\n\n.upload-container {\n  background-color: white;\n  padding: 2rem;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  width: 90%;\n  max-width: 600px;\n}\n\nh1 {\n  text-align: center;\n  color: #333;\n  margin-bottom: 2rem;\n}\n\nh2 {\n  color: #444;\n  margin-bottom: 1rem;\n}\n\n.file-upload-section {\n  margin-bottom: 2rem;\n}\n\n.upload-area {\n  border: 2px dashed #ccc;\n  border-radius: 8px;\n  padding: 2rem;\n  text-align: center;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  margin-bottom: 1rem;\n  outline: none;\n}\n\n.upload-area:hover {\n  border-color: #666;\n  background-color: #f8f8f8;\n}\n\n.upload-area:focus {\n  border-color: #4CAF50;\n  box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\n}\n\n.file-input {\n  display: none;\n}\n\n.upload-prompt {\n  color: #666;\n}\n\n.upload-prompt p {\n  margin: 0.5rem 0;\n}\n\n.selected-files {\n  margin-top: 1rem;\n}\n\n.selected-files ul {\n  list-style: none;\n  padding: 0;\n}\n\n.selected-files li {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.5rem;\n  background-color: #f8f8f8;\n  margin-bottom: 0.5rem;\n  border-radius: 4px;\n}\n\n.remove-btn {\n  background: none;\n  border: none;\n  color: #ff4444;\n  cursor: pointer;\n  font-size: 1.2rem;\n  padding: 0 0.5rem;\n}\n\n.questions-section {\n  margin-top: 2rem;\n}\n\n.question-input input {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  font-size: 1rem;\n}\n\n.submit-btn {\n  width: 100%;\n  padding: 1rem;\n  background-color: #4CAF50;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  font-size: 1rem;\n  cursor: pointer;\n  margin-top: 2rem;\n  transition: background-color 0.3s;\n}\n\n.submit-btn:disabled {\n  background-color: #cccccc;\n  cursor: not-allowed;\n}\n\n.submit-btn:not(:disabled):hover {\n  background-color: #45a049;\n}\n\n.questions-list {\n  margin-top: 2rem;\n  padding: 1rem;\n  background-color: #f8f8f8;\n  border-radius: 4px;\n}\n\n.question-item {\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: white;\n  border-radius: 4px;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n}\n\n.error-message {\n  color: #ff4444;\n  margin-top: 1rem;\n  text-align: center;\n}\n\n.quiz-container {\n  margin-top: 2rem;\n  padding: 2rem;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.question {\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background-color: #f8f8f8;\n  border-radius: 4px;\n}\n\n.options {\n  display: flex;\n  flex-direction: column;\n  gap: 0.8rem;\n  margin: 1.5rem 0;\n}\n\n.options.true-false {\n  flex-direction: row;\n  justify-content: center;\n  gap: 1.5rem;\n}\n\n.option-btn {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  padding: 1rem;\n  border: 2px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: white;\n  color: #333;\n  cursor: pointer;\n  font-size: 1rem;\n  text-align: left;\n  transition: all 0.2s ease;\n}\n\n.options.true-false .option-btn {\n  width: auto;\n  min-width: 120px;\n  justify-content: center;\n  font-size: 1.1rem;\n  font-weight: 500;\n}\n\n.option-letter {\n  background-color: #f5f5f5;\n  color: #666;\n  width: 30px;\n  height: 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 50%;\n  margin-right: 1rem;\n  font-weight: 600;\n}\n\n.option-text {\n  flex: 1;\n}\n\n.option-btn:hover:not(:disabled) {\n  border-color: #2196F3;\n  background-color: #f8f9fa;\n}\n\n.option-btn.selected {\n  border-color: #2196F3;\n  background-color: #e3f2fd;\n}\n\n.option-btn.correct {\n  border-color: #4CAF50;\n  background-color: #E8F5E9;\n  color: #2E7D32;\n}\n\n.option-btn.incorrect {\n  border-color: #f44336;\n  background-color: #FFEBEE;\n  color: #c62828;\n}\n\n.feedback {\n  margin-top: 1.5rem;\n  text-align: center;\n}\n\n.correct-text {\n  color: #4CAF50;\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0.5rem 0;\n}\n\n.incorrect-text {\n  color: #f44336;\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0.5rem 0;\n}\n\n.next-btn {\n  background-color: #2196F3;\n  color: white;\n  border: none;\n  padding: 0.8rem 2rem;\n  border-radius: 25px;\n  cursor: pointer;\n  font-size: 1rem;\n  margin-top: 1rem;\n  transition: all 0.2s ease;\n}\n\n.next-btn:hover {\n  background-color: #1976D2;\n  transform: translateY(-1px);\n}\n\n.quiz-progress {\n  margin-bottom: 2rem;\n}\n\n.progress-bar {\n  width: 100%;\n  height: 8px;\n  background-color: #e0e0e0;\n  border-radius: 4px;\n  overflow: hidden;\n  margin-bottom: 0.5rem;\n}\n\n.progress-fill {\n  height: 100%;\n  background-color: #4CAF50;\n  transition: width 0.3s ease;\n}\n\n.progress-text {\n  display: block;\n  text-align: center;\n  color: #666;\n  font-size: 0.9rem;\n}\n\n.next-btn {\n  width: auto;\n  min-width: 150px;\n  margin-top: 1rem;\n}\n\n.quiz-results {\n  padding: 2rem;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.score-summary {\n  text-align: center;\n  margin-bottom: 2rem;\n  padding: 1rem;\n  background-color: #f5f5f5;\n  border-radius: 8px;\n}\n\n.questions-review {\n  margin-top: 2rem;\n}\n\n.question-review {\n  margin-bottom: 2rem;\n  padding: 1rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: #fff;\n}\n\n.question-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n  padding-bottom: 0.5rem;\n  border-bottom: 1px solid #e0e0e0;\n}\n\n.question-number {\n  font-weight: bold;\n  color: #666;\n}\n\n.answer-status {\n  padding: 0.25rem 0.75rem;\n  border-radius: 4px;\n  font-weight: bold;\n}\n\n.answer-status.correct {\n  background-color: #E8F5E9;\n  color: #2E7D32;\n}\n\n.answer-status.incorrect {\n  background-color: #FFEBEE;\n  color: #C62828;\n}\n\n.question-text {\n  font-size: 1.1rem;\n  margin-bottom: 1rem;\n  color: #333;\n}\n\n.answer-details {\n  background-color: #f8f9fa;\n  padding: 1rem;\n  border-radius: 4px;\n}\n\n.your-answer, .correct-answer {\n  margin-bottom: 0.5rem;\n}\n\n.question-explanation {\n  margin-top: 1rem;\n  padding-top: 1rem;\n  border-top: 1px solid #e0e0e0;\n}\n\n.explanation-text {\n  margin-top: 1rem;\n  padding: 1rem;\n  background-color: #f8f9fa;\n  border-left: 3px solid #2196F3;\n  border-radius: 4px;\n  color: #333;\n  font-size: 0.95rem;\n  line-height: 1.5;\n}\n\n.explanation-text p {\n  margin: 0.5rem 0;\n}\n\n.explanation-text strong {\n  color: #2196F3;\n}\n\n.supported-formats {\n  margin-top: 1rem;\n  text-align: left;\n  display: inline-block;\n}\n\n.supported-formats ul {\n  list-style: none;\n  padding: 0;\n  margin: 0.5rem 0;\n}\n\n.supported-formats li {\n  margin: 0.3rem 0;\n  color: #555;\n}\n\n.format-icon {\n  margin-right: 0.5rem;\n}\n\n.predicted-score-container {\n  text-align: center;\n  padding: 2rem;\n  background-color: #fff;\n  border-radius: 12px;\n  box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n}\n\n.score-prediction {\n  margin: 2rem 0;\n}\n\n.score-circle {\n  width: 180px;\n  height: 180px;\n  border-radius: 50%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  margin: 0 auto;\n  transition: all 0.3s ease;\n}\n\n.score-circle.high {\n  background-color: #e8f5e9;\n  border: 4px solid #4CAF50;\n}\n\n.score-circle.medium {\n  background-color: #fff3e0;\n  border: 4px solid #ff9800;\n}\n\n.score-circle.low {\n  background-color: #ffebee;\n  border: 4px solid #f44336;\n}\n\n.predicted-value {\n  font-size: 3rem;\n  font-weight: bold;\n  line-height: 1;\n  margin-bottom: 0.5rem;\n}\n\n.prediction-label {\n  font-size: 1rem;\n  opacity: 0.8;\n}\n\n.prediction-explanation {\n  color: #666;\n  margin: 1.5rem 0;\n  font-size: 1.1rem;\n  line-height: 1.5;\n}\n\n.start-quiz-btn {\n  background-color: #2196F3;\n  color: white;\n  padding: 1rem 2.5rem;\n  border: none;\n  border-radius: 25px;\n  font-size: 1.2rem;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);\n}\n\n.start-quiz-btn:hover {\n  background-color: #1976D2;\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(33, 150, 243, 0.4);\n}\n\n.loading-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: rgba(255, 255, 255, 0.85);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n  backdrop-filter: blur(2px);\n}\n\n.loading-content {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  font-size: 2rem;\n  color: #333;\n  font-weight: 500;\n}\n\n.typewriter {\n  overflow: hidden;\n  white-space: nowrap;\n  animation: typing 3s steps(14) infinite;\n  border-right: 3px solid #4CAF50;\n}\n\n.dots {\n  display: flex;\n}\n\n.dots span {\n  opacity: 0;\n  animation: dot 1.5s infinite;\n  animation-fill-mode: both;\n}\n\n.dots span:nth-child(2) {\n  animation-delay: 0.2s;\n}\n\n.dots span:nth-child(3) {\n  animation-delay: 0.4s;\n}\n\n@keyframes typing {\n  0%, 90%, 100% {\n    width: 0;\n  }\n  30%, 60% {\n    width: 14ch;\n  }\n}\n\n@keyframes dot {\n  0%, 100% {\n    opacity: 0;\n  }\n  50% {\n    opacity: 1;\n  }\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}